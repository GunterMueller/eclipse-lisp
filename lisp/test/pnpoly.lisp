(defun pnpoly (npol xp yp x y)
  (declare ;(optimize (speed 3) (safety 0))
           (fixnum npol)
           (double-float x y)
           (type (simple-array double-float (*)) xp yp))
  (let* ((c nil)
         (j (1- npol)))
    (declare (fixnum j))
    (dotimes (i npol c)
      (declare (fixnum i))
      (if (and (or (and (<= (aref yp i) y) (< y (aref yp j)))
                   (and (<= (aref yp j) y) (< y (aref yp i))))
               (< x (+ (aref xp i) (/ (* (- (aref xp j) (aref xp i))
                                         (- y (aref yp i)))
                                      (- (aref yp j) (aref yp i))))))
          (setq c (not c)))
      (setq j i))))

(defun pnpolymain (npol div)
  (declare ;(optimize (speed 3) (safety 0))
           (fixnum npol div)
           )
  (let* ((xp (make-array npol :element-type 'double-float))
         (yp (make-array npol :element-type 'double-float))
         (theta 0.0d0)
         (a 10.0d0)
         (fdiv (/ (* 2 a) div))
         (count 0))
    (declare (double-float fdiv a theta)
             (fixnum count)
             (type (simple-array double-float (*)) xp yp))
    (dotimes (i npol)
      (declare (fixnum i))
      (setq theta (/ (* 2 i pi) npol))
      (setf (aref xp i) (+ a (* a (expt (cos theta) 3)))
            (aref yp i) (+ a (* a (expt (sin theta) 3)))))
    (dotimes (u (1+ div))
      (declare (fixnum u))
      (dotimes (v (1+ div))
        (declare (fixnum v))
        (if (pnpoly npol xp yp (* u fdiv) (* v fdiv)) (incf count))))
    (format t "~%Area:  ~a" (/ (* count 4 a a) (* (1+ div) (1+
div))))))
