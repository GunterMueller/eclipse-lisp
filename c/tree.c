/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Wednesday the eighth of April, 1998, 10:16:38 am CDT. */
#include <eclipse.h>

clObject clApply(clProto), clAssoc(clProto), clAtom(clProto),
  clCar(clProto), clCdr(clProto),
  clCharpSimpleBaseString __P((clCharp)), clCheckKeys(clProto),
  clCons(clProto), clConsp(clProto), clCopyTree(clProto),
  clEq(clProto), clExtraArgs(clProto), clFuncall(clProto),
  clKeyArg(clProto), clMakeKeyword(clProto), clMissingArgs(clProto),
  clNot(clProto), clNull(clProto), clRplaca(clProto),
  clRplacd(clProto), clSatisfiesTheTest(clProto), clSubst1(clProto);

extern clObject clCOPY_TREE, clFROM_ALIST, clNONE, clNSUBLIS, clNSUBST,
  clNSUBST_IF, clNSUBST_IF_NOT, clSUBLIS, clSUBST, clSUBST_IF,
  clSUBST_IF_NOT, clSUBST1, clTREE_EQUAL;

static clObject CONS_0, CONS_1, CONS_2, CONS_3, I_1, I_2, I_3, I_4,
  I_5, I_6, I_7, keyKEY, keyTEST, keyTEST_NOT, STR_KEY__2,
  STR_TEST_NOT__1, STR_TEST__0;

clObject clTreeEqual clVdecl(_ap)
{ clObject L_ap, x, y, keys, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(y, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST, keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test, clCar(L_0, clEOA)); }
    else clSetq(test, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST_NOT, keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test_not, clCar(L_0, clEOA)); }
    else clSetq(test_not, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_g395;
    if (clTrue(clConsp(x, clEOA)))
      if (clTrue(clConsp(y, clEOA)))
        { clObject L_test__R2;
          { clObject L_2, L_1, L_0;
            clSetq(L_0, clSymbolFunctionValue(clTREE_EQUAL));
            clSetq(L_1, clCar(x, clEOA));
            clSetq(L_2, clCar(y, clEOA));
            clSetq(L_test__R2, clApply(L_0, L_1, L_2, keys, clEOA)); }
          if (clTrue(L_test__R2))
            { clObject L_2, L_1, L_0;
              clSetq(L_0, clSymbolFunctionValue(clTREE_EQUAL));
              clSetq(L_1, clCdr(x, clEOA));
              clSetq(L_2, clCdr(y, clEOA));
              clSetq(L_g395, clApply(L_0, L_1, L_2, keys, clEOA)); }
          else clSetq(L_g395, clNIL); }
      else clSetq(L_g395, clNIL);
    else clSetq(L_g395, clNIL);
    if (clTrue(L_g395))
      return(clValues1(L_g395));
    else
      { clObject L_g396;
        clSetq(L_g396,
               (clTrue(clNull(x, clEOA)) ? clNull(y, clEOA) : clNIL));
        if (clTrue(L_g396))
          return(clValues1(L_g396));
        else
          { clObject L_4, L_3, L_2;
            clSetq(L_2, test);
            clSetq(L_3, test_not);
            clSetq(L_4, key);
            return(clSatisfiesTheTest(x,
                                      y,
                                      L_2,
                                      L_3,
                                      L_4,
                                      clEOA)); } } } }

clObject clCopyTree clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clConsp(object, clEOA)))
    { clObject L_0;
      clSetq(L_0, clCopyTree(clCar(object, clEOA), clEOA));
      return(clCons(L_0, clCopyTree(clCdr(object, clEOA), clEOA),
                    clEOA)); }
  else return(clValues1(object)); }

clObject clSubst1 clVdecl(_ap)
{ clObject CL_new, old, tree, test, test_not, key, copy, alist;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(old,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    clSetq(test_not,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_5, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_6, clEOA)));
    clSetq(copy,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_7, clEOA)));
    clSetq(alist, clEq(old, clFROM_ALIST, clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    if (clTrue(alist))
      { clObject L_0;
        clSetq(L_0,
               (clTrue(key) ? clFuncall(key, tree, clEOA) : tree));
        clSetq(L_test,
               clSetq(alist,
                      clAssoc(L_0,
                              CL_new,
                              keyTEST,
                              test,
                              keyTEST_NOT,
                              test_not,
                              clEOA))); }
    else clSetq(L_test, clNIL);
    if (clTrue(L_test))
      { clObject L_0; clSetq(L_0, alist); return(clCdr(L_0, clEOA)); }
    else
      { clObject L_test__R1;
        { clObject L_test__R2;
          { clObject L_0;
            clSetq(L_0, alist);
            clSetq(L_test__R2, clNot(L_0, clEOA)); }
          clSetq(L_test__R1,
                 (clTrue(L_test__R2) ?
                  clSatisfiesTheTest(old,
                                     tree,
                                     test,
                                     test_not,
                                     key,
                                     clEOA) :
                  clNIL)); }
        if (clTrue(L_test__R1))
          return(clValues1(CL_new));
        else if (clTrue(clAtom(tree, clEOA)))
          return(clValues1(tree));
        else
          { clObject car, cdr;
            { clObject L_2;
              clSetq(L_2, clCar(tree, clEOA));
              clSetq(car,
                     clSubst1(CL_new,
                              old,
                              L_2,
                              test,
                              test_not,
                              key,
                              copy,
                              clEOA)); }
            { clObject L_2;
              clSetq(L_2, clCdr(tree, clEOA));
              clSetq(cdr,
                     clSubst1(CL_new,
                              old,
                              L_2,
                              test,
                              test_not,
                              key,
                              copy,
                              clEOA)); }
            if (clTrue((_clEq(car, clCar(tree, clEOA)) ?
                        clEq(cdr, clCdr(tree, clEOA), clEOA) :
                        clNIL)))
              return(clValues1(tree));
            else if (clTrue(copy))
              return(clCons(car, cdr, clEOA));
            else
              { clRplaca(tree, car, clEOA);
                clRplacd(tree, cdr, clEOA);
                return(clValues1(tree)); } } } } }

clObject clSubst clVdecl(_ap)
{ clObject L_ap, CL_new, old, tree, L_keys, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(old,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test, clCar(L_0, clEOA)); }
    else clSetq(test, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST_NOT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test_not, clCar(L_0, clEOA)); }
    else clSetq(test_not, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_5, L_4, L_3;
    clSetq(L_3, test);
    clSetq(L_4, test_not);
    clSetq(L_5, key);
    return(clSubst1(CL_new, old, tree, L_3, L_4, L_5, clT, clEOA)); } }

clObject clSubstIf clVdecl(_ap)
{ clObject L_ap, CL_new, test, tree, L_keys, key;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_3, clEOA);
    clEndParse(_ap); }
  { clObject L_5;
    clSetq(L_5, key);
    return(clSubst1(CL_new, clNONE, tree, test, clNIL, L_5, clT,
                    clEOA)); } }

clObject clSubstIfNot clVdecl(_ap)
{ clObject L_ap, CL_new, test, tree, L_keys, key;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_3, clEOA);
    clEndParse(_ap); }
  { clObject L_5;
    clSetq(L_5, key);
    return(clSubst1(CL_new, clNONE, tree, clNIL, test, L_5, clT,
                    clEOA)); } }

clObject clNsubst clVdecl(_ap)
{ clObject L_ap, CL_new, old, tree, L_keys, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(old,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test, clCar(L_0, clEOA)); }
    else clSetq(test, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST_NOT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test_not, clCar(L_0, clEOA)); }
    else clSetq(test_not, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_5, L_4, L_3;
    clSetq(L_3, test);
    clSetq(L_4, test_not);
    clSetq(L_5, key);
    return(clSubst1(CL_new, old, tree, L_3, L_4, L_5, clNIL,
                    clEOA)); } }

clObject clNsubstIf clVdecl(_ap)
{ clObject L_ap, CL_new, test, tree, L_keys, key;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_3, clEOA);
    clEndParse(_ap); }
  { clObject L_5;
    clSetq(L_5, key);
    return(clSubst1(CL_new, clNONE, tree, test, clNIL, L_5, clNIL,
                    clEOA)); } }

clObject clNsubstIfNot clVdecl(_ap)
{ clObject L_ap, CL_new, test, tree, L_keys, key;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_3, clEOA);
    clEndParse(_ap); }
  { clObject L_5;
    clSetq(L_5, key);
    return(clSubst1(CL_new, clNONE, tree, clNIL, test, L_5, clNIL,
                    clEOA)); } }

clObject clSublis clVdecl(_ap)
{ clObject L_ap, alist, tree, L_keys, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(alist,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test, clCar(L_0, clEOA)); }
    else clSetq(test, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST_NOT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test_not, clCar(L_0, clEOA)); }
    else clSetq(test_not, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_5, L_4, L_3;
    clSetq(L_3, test);
    clSetq(L_4, test_not);
    clSetq(L_5, key);
    return(clSubst1(alist, clFROM_ALIST, tree, L_3, L_4, L_5, clT,
                    clEOA)); } }

clObject clNsublis clVdecl(_ap)
{ clObject L_ap, alist, tree, L_keys, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(alist,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(tree,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test, clCar(L_0, clEOA)); }
    else clSetq(test, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST_NOT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test_not, clCar(L_0, clEOA)); }
    else clSetq(test_not, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_5, L_4, L_3;
    clSetq(L_3, test);
    clSetq(L_4, test_not);
    clSetq(L_5, key);
    return(clSubst1(alist, clFROM_ALIST, tree, L_3, L_4, L_5, clNIL,
                    clEOA)); } }

void clInitTree __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(STR_TEST__0,
         clCharpSimpleBaseString("TEST"));
  clSetq(keyTEST, clMakeKeyword(STR_TEST__0, clEOA));
  clSetq(STR_TEST_NOT__1,
         clCharpSimpleBaseString("TEST-NOT"));
  clSetq(keyTEST_NOT, clMakeKeyword(STR_TEST_NOT__1, clEOA));
  clSetq(STR_KEY__2,
         clCharpSimpleBaseString("KEY"));
  clSetq(keyKEY, clMakeKeyword(STR_KEY__2, clEOA));
  clSetq(CONS_2, clCons(keyTEST, clNIL, clEOA));
  clSetq(CONS_1, clCons(keyTEST_NOT, CONS_2, clEOA));
  clSetq(CONS_0, clCons(keyKEY, CONS_1, clEOA));
  clSetq(I_3, clIntFixnum(3));
  clSetq(I_4, clIntFixnum(4));
  clSetq(I_5, clIntFixnum(5));
  clSetq(I_6, clIntFixnum(6));
  clSetq(I_7, clIntFixnum(7));
  clSetq(CONS_3, clCons(keyKEY, clNIL, clEOA));

  clSetSymbolFunctionValue(clTREE_EQUAL,
                           clMakeClosure(0, clTreeEqual, clNULL_HOOK));
  (void) clTREE_EQUAL;
  clSetSymbolFunctionValue(clCOPY_TREE,
                           clMakeClosure(0, clCopyTree, clNULL_HOOK));
  (void) clCOPY_TREE;
  clSetSymbolFunctionValue(clSUBST1,
                           clMakeClosure(0, clSubst1, clNULL_HOOK));
  (void) clSUBST1;
  clSetSymbolFunctionValue(clSUBST,
                           clMakeClosure(0, clSubst, clNULL_HOOK));
  (void) clSUBST;
  clSetSymbolFunctionValue(clSUBST_IF,
                           clMakeClosure(0, clSubstIf, clNULL_HOOK));
  (void) clSUBST_IF;
  clSetSymbolFunctionValue(clSUBST_IF_NOT,
                           clMakeClosure(0,
                                         clSubstIfNot,
                                         clNULL_HOOK));
  (void) clSUBST_IF_NOT;
  clSetSymbolFunctionValue(clNSUBST,
                           clMakeClosure(0, clNsubst, clNULL_HOOK));
  (void) clNSUBST;
  clSetSymbolFunctionValue(clNSUBST_IF,
                           clMakeClosure(0, clNsubstIf, clNULL_HOOK));
  (void) clNSUBST_IF;
  clSetSymbolFunctionValue(clNSUBST_IF_NOT,
                           clMakeClosure(0,
                                         clNsubstIfNot,
                                         clNULL_HOOK));
  (void) clNSUBST_IF_NOT;
  clSetSymbolFunctionValue(clSUBLIS,
                           clMakeClosure(0, clSublis, clNULL_HOOK));
  (void) clSUBLIS;
  clSetSymbolFunctionValue(clNSUBLIS,
                           clMakeClosure(0, clNsublis, clNULL_HOOK));
  (void) clNSUBLIS;
  clUnwind(4); }
