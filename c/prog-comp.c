/* Generated by Eclipse Common Lisp 1.1-HOSTED for howard on circe.
   Friday the sixth of March, 1998, 4:25:26 pm CST. */
#include <eclipse.h>

clObject clCar(clProto), clCdr(clProto),
  clCharpSimpleBaseString __P((clCharp)), clCheckKeys(clProto),
  clCons(clProto), clConsp(clProto), clEq(clProto),
  clExtraArgs(clProto), clFirst(clProto), clGensym(clProto),
  clKeyArg(clProto), clList(clProto), clListSTAR(clProto),
  clListp(clProto), cl_SETF_MacroFunction(clProto),
  clMakeKeyword(clProto), clMakeSymbol(clProto),
  clMissingArgs(clProto), clNot(clProto), clSecond(clProto),
  clSignalProgramError(clProto), clSymbolName(clProto),
  clSymbolp(clProto), clValues(clProto), clWarn(clProto);

extern clObject clampersandALLOW_OTHER_KEYS, clampersandAUX,
  clampersandBODY, clampersandKEY, clampersandOPTIONAL,
  clampersandREST, clampersandWHOLE, clDYNAMIC_EXTENT, clIF, clLAMBDA,
  clQUOTE, clSETQ, clADD, clCAR, clCHECK_KEYS, clDOTTED_LIST,
  clEXTRA_ARGS, clFUNCTION, clKEY_ARG, clMISSING_ARGS, clNREVERSE,
  clPARSE_LAMBDA, clPOP, clUNBOUND_FLAG, clVARGS, clVP, clVPOP, clWHEN;

static clObject CONS_0, CONS_1, CONS_2, CONS_3, CONS_4, I_0, I_1, I_2,
  keyDEFAULT, keyMACRO, keyVARARGS, STR_DEFAULT__1, STR_KEYS__5,
  STR_MACRO__0, STR_VARARGS__2, STRn_3, STRn_4;

clObject clLambda clVdecl(_ap)
{ clObject L_form, L_ignored, lambda_list, forms;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top456;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top456, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(lambda_list, L_top456); }
    else clSetq(lambda_list, clMissingArgs(I_1, clEOA));
    clSetq(forms, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clList(clFUNCTION,
                clListSTAR(clLAMBDA, lambda_list, forms, clEOA),
                clEOA)); }

clDeclareEnv(clParseLambda_Parse_CheckMissingRest);
static clObject clParseLambda_Parse_CheckMissingRest clVdecl(_ap)
{ clUseEnv(clParseLambda_Parse_CheckMissingRest);
  { { clBeginParse(_ap);
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clNot(clEnv(0, *rest_var), clEOA)))
      { clObject arg;
        clSetq(arg, clMakeSymbol(STR_KEYS__5, clEOA));
        { clObject L_1, L_0;
          clSetq(L_0, clSetq(clEnv(0, *rest_var), arg));
          clSetq(L_1, clEnv(2, *argslist));
          clFuncallFunction(clEnv(1, clEnv(1, *_AddVar_)),
                            L_0,
                            L_1,
                            clEOA); }
        { clObject L_0;
          clSetq(L_0, clList(clDYNAMIC_EXTENT, arg, clEOA));
          return(clValues1(clSetq(clEnv(3, clEnv(2, *decls)),
                                  clCons(L_0,
                                         clEnv(3, clEnv(2, *decls)),
                                         clEOA)))); } }
    else return(clValues1(clNIL)); } }

static clObject clParseLambda_BadKey clVdecl(_ap)
{ clObject key;
  { clBeginParse(_ap);
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clSignalProgramError(STRn_3, key, clEOA)); }

clDeclareEnv(clParseLambda_SetTmp);
static clObject clParseLambda_SetTmp clVdecl(_ap)
{ clUseEnv(clParseLambda_SetTmp);
  { clObject val;
    { clBeginParse(_ap);
      clSetq(val,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clNot(clEnv(0, *tmp), clEOA)))
      clSetq(clEnv(0, *tmp),
             clMakeSymbol(clSymbolName(clEnv(1, *whole_name), clEOA),
                          clEOA));
    return(clList(clSETQ, clEnv(0, *tmp), val, clEOA)); } }

clDeclareEnv(clParseLambda_SimpleBinding);
static clObject clParseLambda_SimpleBinding clVdecl(_ap)
{ clUseEnv(clParseLambda_SimpleBinding);
  { clObject v, init;
    { clBeginParse(_ap);
      clSetq(v,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(init,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject L_0;
      clSetq(L_0, clList(v, init, clEOA));
      return(clValues1(clSetq(clEnv(0, *bindings),
                              clCons(L_0,
                                     clEnv(0, *bindings),
                                     clEOA)))); } } }

clDeclareEnv(clParseLambda_AddVar);
static clObject clParseLambda_AddVar clVdecl(_ap)
{ clUseEnv(clParseLambda_AddVar);
  { clObject v, init;
    { clBeginParse(_ap);
      clSetq(v,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(init,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clSymbolp(v, clEOA)))
      return(clFuncallFunction(clEnv(0, *_SimpleBinding_),
                               v,
                               init,
                               clEOA));
    else
      { { clObject L_test__R1;
          { clObject L_0;
            clSetq(L_0, clEnv(1, *macro));
            clSetq(L_test__R1, clNot(L_0, clEOA)); }
          if (clTrue(L_test__R1)) clWarn(STRn_4, clEOA); }
        { clObject whole;
          clSetq(whole, clGensym(clEOA));
          clFuncallFunction(clEnv(0, *_SimpleBinding_),
                            whole,
                            init,
                            clEOA);
          return(clFuncallFunction(clEnv(2, *_Parse_),
                                   v,
                                   whole,
                                   clEOA)); } } } }

clDeclareEnv(clParseLambda_Parse);
static clObject clParseLambda_Parse clVdecl(_ap)
{ clUseEnv(clParseLambda_Parse);
  { clObject vl, whole, *rest_var = clMakeBinding(), argsp, argspop,
    *argslist = clMakeBinding();
    { clBeginParse(_ap);
      clSetq(vl,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(whole,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      clSetq(*rest_var, clNIL);
      clSetq(argsp,
             (clTrue(clEnv(0, *varargs)) ? clList(clVP, whole, clEOA) :
              whole));
      clSetq(argspop,
             (clTrue(clEnv(0, *varargs)) ?
              clList(clVPOP, whole, clEOA) :
              clList(clPOP, whole, clEOA)));
      clSetq(*argslist,
             (clTrue(clEnv(0, *varargs)) ?
              clList(clVARGS, whole, clEOA) : whole));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject _CheckMissingRest_;
      clSetq(_CheckMissingRest_,
             clMakeClosure(4,
                           clParseLambda_Parse_CheckMissingRest,
                           &clEnvHook(clParseLambda_Parse_CheckMissingRest),
                           &*rest_var,
                           &clEnv(1, *_AddVar_),
                           &*argslist,
                           &clEnv(2, *decls)));
      { clObject v, keys, wholeQUESTION, optionalQUESTION,
        restQUESTION, keyQUESTION, allow_other_keysQUESTION,
        auxQUESTION;
        clSetq(v, clNIL);
        clSetq(keys, clNIL);
        clSetq(wholeQUESTION, clNIL);
        clSetq(optionalQUESTION, clNIL);
        clSetq(restQUESTION, clNIL);
        clSetq(keyQUESTION, clNIL);
        clSetq(allow_other_keysQUESTION, clNIL);
        clSetq(auxQUESTION, clNIL);
        clLabel(l_ITERATE458);
        if (clTrue(clNot(clConsp(vl, clEOA), clEOA)))
          { if (clTrue(vl))
              { if (clTrue(restQUESTION))
                  clFuncallFunction(clEnv(3, *_BadKey_),
                                    clDOTTED_LIST,
                                    clEOA);
                clSetq(restQUESTION, clT);
                clFuncallFunction(clEnv(4, *_SimpleBinding_),
                                  vl,
                                  whole,
                                  clEOA); }
            if (clTrue((clTrue(keyQUESTION) ?
                        clNot(allow_other_keysQUESTION, clEOA) :
                        clNIL)))
              { clFuncallFunction(_CheckMissingRest_, clEOA);
                { clObject L_0;
                  { clObject L_1__R1;
                    clSetq(L_1__R1, *rest_var);
                    clSetq(L_0,
                           clList(clCHECK_KEYS,
                                  L_1__R1,
                                  clList(clQUOTE, keys, clEOA),
                                  clEOA)); }
                  return(clValues1(clSetq(clEnv(5, *checks),
                                          clCons(L_0,
                                                 clEnv(5, *checks),
                                                 clEOA)))); } }
            else
              { clObject L_test__R2;
                { clObject L_0;
                  clSetq(L_0, restQUESTION);
                  clSetq(L_test__R2, clNot(L_0, clEOA)); }
                if (clTrue(L_test__R2))
                  { clObject L_1, L_0;
                    { clObject L_2, L_1__R1;
                      clSetq(L_1__R1, argsp);
                      { clObject L_1__R2;
                        clSetq(L_1__R2, *argslist);
                        clSetq(L_2,
                               clList(clEXTRA_ARGS, L_1__R2, clEOA)); }
                      clSetq(L_0,
                             clList(clWHEN, L_1__R1, L_2, clEOA)); }
                    clSetq(L_1, clEnv(5, *checks));
                    return(clValues1(clSetq(clEnv(5, *checks),
                                            clCons(L_0,
                                                   L_1,
                                                   clEOA)))); }
                else return(clValues1(clNIL)); } }
        { clObject L_key459;
          { clObject L_top460;
            clSetq(L_top460, clCar(vl, clEOA));
            { clObject L_0;
              clSetq(L_0, vl);
              clSetq(vl, clCdr(L_0, clEOA)); }
            clSetq(L_key459, clSetq(v, L_top460)); }
          if (_clEq(L_key459, clampersandWHOLE))
            { { clObject L_test__R1;
                if (clTrue(wholeQUESTION))
                  clSetq(L_test__R1, wholeQUESTION);
                else
                  { clObject L_0;
                    clSetq(L_0, clEnv(6, *macro));
                    clSetq(L_test__R1, clNot(L_0, clEOA)); }
                if (clTrue(L_test__R1))
                  clFuncallFunction(clEnv(3, *_BadKey_),
                                    clampersandWHOLE,
                                    clEOA); }
              { clObject L_1, L_0;
                { clObject L_top462;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, vl);
                    clSetq(L_top462, clCar(L_0__R1, clEOA)); }
                  { clObject L_0__R1;
                    clSetq(L_0__R1, vl);
                    clSetq(vl, clCdr(L_0__R1, clEOA)); }
                  clSetq(L_0, L_top462); }
                clSetq(L_1, *argslist);
                clFuncallFunction(clEnv(1, *_AddVar_),
                                  L_0,
                                  L_1,
                                  clEOA); }
              clSetq(wholeQUESTION, clT); }
          else if (_clEq(L_key459, clampersandOPTIONAL))
            { if (clTrue(optionalQUESTION))
                { clObject L_0;
                  clSetq(L_0, v);
                  clFuncallFunction(clEnv(3, *_BadKey_), L_0, clEOA); }
              clSetq(optionalQUESTION, clT); }
          else if (clTrue((_clEq(L_key459, clampersandREST) ?
                           CONS_3 :
                           (_clEq(L_key459, clampersandBODY) ?
                            CONS_4 :
                            clNIL))))
            { if (clTrue(restQUESTION))
                { clObject L_0;
                  clSetq(L_0, v);
                  clFuncallFunction(clEnv(3, *_BadKey_), L_0, clEOA); }
              { clObject L_1, L_0;
                { clObject L_top465;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, vl);
                    clSetq(L_top465, clCar(L_0__R1, clEOA)); }
                  { clObject L_0__R1;
                    clSetq(L_0__R1, vl);
                    clSetq(vl, clCdr(L_0__R1, clEOA)); }
                  clSetq(L_0, clSetq(*rest_var, L_top465)); }
                clSetq(L_1, *argslist);
                clFuncallFunction(clEnv(1, *_AddVar_),
                                  L_0,
                                  L_1,
                                  clEOA); }
              clSetq(optionalQUESTION, clT);
              clSetq(restQUESTION, clT); }
          else if (_clEq(L_key459, clampersandKEY))
            { if (clTrue(keyQUESTION))
                clFuncallFunction(clEnv(3, *_BadKey_),
                                  clampersandKEY,
                                  clEOA);
              clSetq(keyQUESTION, clT);
              clSetq(optionalQUESTION, clT);
              clSetq(restQUESTION, clT); }
          else if (_clEq(L_key459, clampersandALLOW_OTHER_KEYS))
            { { clObject L_test__R5;
                { clObject L_g466;
                  { clObject L_0;
                    clSetq(L_0, keyQUESTION);
                    clSetq(L_g466, clNot(L_0, clEOA)); }
                  clSetq(L_test__R5,
                         (clTrue(L_g466) ?
                          L_g466 :
                          allow_other_keysQUESTION)); }
                if (clTrue(L_test__R5))
                  clFuncallFunction(clEnv(3, *_BadKey_),
                                    clampersandALLOW_OTHER_KEYS,
                                    clEOA); }
              clSetq(allow_other_keysQUESTION, clT); }
          else if (_clEq(L_key459, clampersandAUX))
            { if (clTrue(auxQUESTION))
                clFuncallFunction(clEnv(3, *_BadKey_),
                                  clampersandAUX,
                                  clEOA);
              clSetq(auxQUESTION, clT);
              clSetq(optionalQUESTION, clT); }
          else
            { clSetq(clEnv(7, *counter),
                     clFuncallFunction(clSymbolFunctionValue(clADD),
                                       clEnv(7, *counter),
                                       I_1,
                                       clEOA));
              { clObject CL_default, sv;
                clSetq(CL_default, clEnv(8, *CL_default));
                clSetq(sv, clNIL);
                { clObject L_test__R6;
                  if (clTrue(optionalQUESTION))
                    { clObject L_0;
                      clSetq(L_0, v);
                      clSetq(L_test__R6, clListp(L_0, clEOA)); }
                  else clSetq(L_test__R6, clNIL);
                  if (clTrue(L_test__R6))
                    { clObject L_form467, v1, d1, sv1;
                      clSetq(L_form467, v);
                      if (clTrue(L_form467))
                      { clObject L_top468;
                        clSetq(L_top468, clCar(L_form467, clEOA));
                        { clObject L_0;
                          clSetq(L_0, L_form467);
                          clSetq(L_form467, clCdr(L_0, clEOA)); }
                        clSetq(v1, L_top468); }
                      else
                      clSetq(v1, clMissingArgs(I_1, clEOA));
                      if (clTrue(L_form467))
                      { clObject L_top469;
                        { clObject L_0;
                          clSetq(L_0, L_form467);
                          clSetq(L_top469, clCar(L_0, clEOA)); }
                        { clObject L_0;
                          clSetq(L_0, L_form467);
                          clSetq(L_form467, clCdr(L_0, clEOA)); }
                        clSetq(d1, L_top469); }
                      else
                      clSetq(d1, CL_default);
                      if (clTrue(L_form467))
                      { clObject L_top470;
                        { clObject L_0;
                          clSetq(L_0, L_form467);
                          clSetq(L_top470, clCar(L_0, clEOA)); }
                        { clObject L_0;
                          clSetq(L_0, L_form467);
                          clSetq(L_form467, clCdr(L_0, clEOA)); }
                        clSetq(sv1, L_top470); }
                      else
                      clSetq(sv1, clNIL);
                      if (clTrue(L_form467))
                      { clObject L_0;
                        clSetq(L_0, L_form467);
                        clExtraArgs(L_0, clEOA); }
                      clSetq(v, v1);
                      clSetq(CL_default, d1);
                      clSetq(sv, sv1); } }
                if (clTrue(auxQUESTION))
                  { clObject L_1, L_0;
                    clSetq(L_0, v);
                    clSetq(L_1, CL_default);
                    clFuncallFunction(clEnv(1, *_AddVar_),
                                      L_0,
                                      L_1,
                                      clEOA); }
                else if (clTrue(keyQUESTION))
                  { clFuncallFunction(_CheckMissingRest_, clEOA);
                    { clObject key;
                      clSetq(key, clNIL);
                      { clObject L_test__R8;
                        { clObject L_0;
                          clSetq(L_0, v);
                          clSetq(L_test__R8, clListp(L_0, clEOA)); }
                        if (clTrue(L_test__R8))
                        { { clObject L_0;
                            clSetq(L_0, v);
                            clSetq(key, clFirst(L_0, clEOA)); }
                          { clObject L_0;
                            clSetq(L_0, v);
                            clSetq(v, clSecond(L_0, clEOA)); } }
                        else
                        { clObject L_0;
                          { clObject L_0__R1;
                            clSetq(L_0__R1, v);
                            clSetq(L_0,
                                   clSymbolName(L_0__R1, clEOA)); }
                          clSetq(key, clMakeKeyword(L_0, clEOA)); } }
                      { clObject L_1, L_0;
                        clSetq(L_0, v);
                        { clObject L_3, L_2, L_1__R1;
                          { clObject L_0__R2;
                            { clObject L_2__R1, L_1__R2;
                              { clObject L_1__R3;
                                clSetq(L_1__R3, key);
                                clSetq(L_1__R2,
                                       clList(clQUOTE,
                                              L_1__R3,
                                              clEOA)); }
                              clSetq(L_2__R1, *rest_var);
                              clSetq(L_0__R2,
                                     clList(clKEY_ARG,
                                            L_1__R2,
                                            L_2__R1,
                                            clEOA)); }
                            clSetq(L_1__R1,
                                   clFuncallFunction(clEnv(9, *_SetTmp_),
                                                     L_0__R2,
                                                     clEOA)); }
                          { clObject L_1__R2;
                            clSetq(L_1__R2, clEnv(10, *tmp));
                            clSetq(L_2,
                                   clList(clCAR, L_1__R2, clEOA)); }
                          clSetq(L_3, CL_default);
                          clSetq(L_1,
                                 clList(clIF,
                                        L_1__R1,
                                        L_2,
                                        L_3,
                                        clEOA)); }
                        clFuncallFunction(clEnv(1, *_AddVar_),
                                          L_0,
                                          L_1,
                                          clEOA); }
                      if (clTrue(sv))
                      { clObject L_1, L_0;
                        clSetq(L_0, sv);
                        clSetq(L_1, clEnv(10, *tmp));
                        clFuncallFunction(clEnv(1, *_AddVar_),
                                          L_0,
                                          L_1,
                                          clEOA); }
                      { clObject L_1, L_0;
                        clSetq(L_0, key);
                        clSetq(L_1, keys);
                        clSetq(keys, clCons(L_0, L_1, clEOA)); } } }
                else
                  { { clObject L_1, L_0;
                      clSetq(L_0, v);
                      { clObject L_3, L_2, L_1__R1;
                        if (clTrue(sv))
                        { clObject L_0__R2;
                          clSetq(L_0__R2, argsp);
                          clSetq(L_1__R1,
                                 clFuncallFunction(clEnv(9, *_SetTmp_),
                                                   L_0__R2,
                                                   clEOA)); }
                        else
                        clSetq(L_1__R1, argsp);
                        clSetq(L_2, argspop);
                        clSetq(L_3,
                               (clTrue(optionalQUESTION) ?
                                CL_default :
                                clList(clMISSING_ARGS,
                                       clEnv(7, *counter),
                                       clEOA)));
                        clSetq(L_1,
                               clList(clIF,
                                      L_1__R1,
                                      L_2,
                                      L_3,
                                      clEOA)); }
                      clFuncallFunction(clEnv(1, *_AddVar_),
                                        L_0,
                                        L_1,
                                        clEOA); }
                    if (clTrue(sv))
                      { clObject L_1, L_0;
                        clSetq(L_0, sv);
                        clSetq(L_1, clEnv(10, *tmp));
                        clFuncallFunction(clEnv(1, *_AddVar_),
                                          L_0,
                                          L_1,
                                          clEOA); } } } } }
        goto l_ITERATE458; } } } }

clObject clParseLambda clVdecl(_ap)
{ clObject L_ap, lambda_list, *whole_name = clMakeBinding(), L_keys,
  *macro = clMakeBinding(), *CL_default = clMakeBinding(),
  *varargs = clMakeBinding(), *tmp = clMakeBinding(),
  *bindings = clMakeBinding(), *checks = clMakeBinding(),
  *decls = clMakeBinding(), *counter = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(lambda_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(*whole_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyMACRO, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(*macro, clCar(L_0, clEOA)); }
    else clSetq(*macro, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyDEFAULT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(*CL_default, clCar(L_0, clEOA)); }
    else clSetq(*CL_default, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyVARARGS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(*varargs, clCar(L_0, clEOA)); }
    else clSetq(*varargs, clNIL);
    clSetq(*tmp, clNIL);
    clSetq(*bindings, clNIL);
    clSetq(*checks, clNIL);
    clSetq(*decls, clNIL);
    clSetq(*counter, I_0);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject *_Parse_ = clMakeBinding(), *_AddVar_ = clMakeBinding(),
    *_SimpleBinding_ = clMakeBinding(), *_SetTmp_ = clMakeBinding(),
    *_BadKey_ = clMakeBinding();
    clSetq(*_BadKey_,
           clMakeClosure(0, clParseLambda_BadKey, clNULL_HOOK));
    clSetq(*_SetTmp_,
           clMakeClosure(2,
                         clParseLambda_SetTmp,
                         &clEnvHook(clParseLambda_SetTmp),
                         &*tmp,
                         &*whole_name));
    clSetq(*_SimpleBinding_,
           clMakeClosure(1,
                         clParseLambda_SimpleBinding,
                         &clEnvHook(clParseLambda_SimpleBinding),
                         &*bindings));
    clSetq(*_AddVar_,
           clMakeClosure(3,
                         clParseLambda_AddVar,
                         &clEnvHook(clParseLambda_AddVar),
                         &*_SimpleBinding_,
                         &*macro,
                         &*_Parse_));
    clSetq(*_Parse_,
           clMakeClosure(11,
                         clParseLambda_Parse,
                         &clEnvHook(clParseLambda_Parse),
                         &*varargs,
                         &*_AddVar_,
                         &*decls,
                         &*_BadKey_,
                         &*_SimpleBinding_,
                         &*checks,
                         &*macro,
                         &*counter,
                         &*CL_default,
                         &*_SetTmp_,
                         &*tmp));
    { clObject L_1;
      clSetq(L_1, *whole_name);
      clFuncallFunction(*_Parse_, lambda_list, L_1, clEOA); }
    { clObject L_0;
      clSetq(L_0, *bindings);
      clSetq(*bindings,
             clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                               L_0,
                               clEOA)); }
    { clObject full_bindings;
      if (clTrue(*tmp))
        { clObject L_1, L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, *tmp);
            clSetq(L_0, clList(L_0__R1, clUNBOUND_FLAG, clEOA)); }
          clSetq(L_1, *bindings);
          clSetq(full_bindings, clCons(L_0, L_1, clEOA)); }
      else clSetq(full_bindings, *bindings);
      { clObject L_3, L_2, L_1, L_0;
        clSetq(L_0, full_bindings);
        { clObject L_0__R1;
          clSetq(L_0__R1, *checks);
          clSetq(L_1,
                 clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                   L_0__R1,
                                   clEOA)); }
        clSetq(L_2, *decls);
        clSetq(L_3, *bindings);
        return(clValues(L_0, L_1, L_2, L_3, clEOA)); } } } }

void clInitProgComp __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(STR_MACRO__0,
         clCharpSimpleBaseString("MACRO"));
  clSetq(keyMACRO, clMakeKeyword(STR_MACRO__0, clEOA));
  clSetq(STR_DEFAULT__1,
         clCharpSimpleBaseString("DEFAULT"));
  clSetq(keyDEFAULT, clMakeKeyword(STR_DEFAULT__1, clEOA));
  clSetq(STR_VARARGS__2,
         clCharpSimpleBaseString("VARARGS"));
  clSetq(keyVARARGS, clMakeKeyword(STR_VARARGS__2, clEOA));
  clSetq(I_0, clIntFixnum(0));
  clSetq(CONS_2, clCons(keyMACRO, clNIL, clEOA));
  clSetq(CONS_1, clCons(keyDEFAULT, CONS_2, clEOA));
  clSetq(CONS_0, clCons(keyVARARGS, CONS_1, clEOA));
  clSetq(STRn_3,
         clCharpSimpleBaseString("Misplaced ~s in lambda-list."));
  clSetq(STRn_4,
         clCharpSimpleBaseString("Non-ANSI destructuring of normal function lambda-list."));
  clSetq(STR_KEYS__5,
         clCharpSimpleBaseString("KEYS"));
  clSetq(CONS_4, clCons(clampersandBODY, clNIL, clEOA));
  clSetq(CONS_3, clCons(clampersandREST, CONS_4, clEOA));

  { { clObject L_value454;
      clSetq(L_value454, clMakeClosure(0, clLambda, clNULL_HOOK));
      cl_SETF_MacroFunction(L_value454, clLAMBDA, clEOA); }
    (void) clLAMBDA; }
  clSetSymbolFunctionValue(clPARSE_LAMBDA,
                           clMakeClosure(0,
                                         clParseLambda,
                                         clNULL_HOOK));
  (void) clPARSE_LAMBDA;
  clUnwind(4); }
