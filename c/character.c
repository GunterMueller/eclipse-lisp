/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Wednesday the sixth of May, 1998, 1:47:18 pm CDT. */
#include <eclipse.h>
#include "chars.h"

clObject clLESS_FUNC(clProto), clAssoc(clProto), clCar(clProto),
  clCdr(clProto), clCharDowncase(clProto), clCharInt(clProto),
  clCharLESSEQUAL(clProto), clCharEQUAL(clProto),
  clCharpSimpleBaseString __P((clCharp)), clCheckKeys(clProto),
  clCodeChar(clProto), clCons(clProto), clDifferent(clProto),
  clEndp(clProto), clEq(clProto), clError(clProto),
  clExtraArgs(clProto), clFuncall(clProto),
  cl_SETF_GlobalDeclaration(clProto), clIntInteger __P((int)),
  clKeyArg(clProto), clLength(clProto), clLogand(clProto),
  clLogior(clProto), clLowerCaseP(clProto), clMakeKeyword(clProto),
  clMissingArgs(clProto), clMonotonic(clProto), clNot(clProto),
  clNull(clProto), clRassoc(clProto), clRest(clProto),
  clRplaca(clProto), clString(clProto), clUpperCaseP(clProto);

extern clObject clSPECIAL, clSYMBOL, clstarCHARACTER_NAMESstar,
  cllesssymbol, cllessequalsymbol, clequalsymbol, clgreatersymbol,
  clgreaterequalsymbol, clADD, clALPHA_CHAR_P, clALPHANUMERICP,
  clBOTH_CASE_P, clCHAR, clCHAR_BIT, clCHAR_CODE, clCHAR_DOWNCASE,
  clCHAR_EQUAL, clCHAR_GREATERP, clCHAR_INT, clCHAR_KEY, clCHAR_LESSP,
  clCHAR_NAME, clCHAR_NOT_EQUAL, clCHAR_NOT_GREATERP, clCHAR_NOT_LESSP,
  clCHAR_UPCASE, clCHARslashequal, clCHARless, clCHARlessequal,
  clCHARequal, clCHARgreater, clCHARgreaterequal, clCHARACTER,
  clCHARACTER_DESIGNATOR, clCODE_CHAR, clCOMPLEX_BASE_STRING,
  clCOMPLEX_EXTENDED_STRING, clCOMPLEX_STRING, clDIFFERENT,
  clDIGIT_CHAR, clDIGIT_CHAR_P, clEQ_NUMBER, clGLOBAL_VARIABLE,
  clGRAPHIC_CHAR_P, clGT, clLOWER_CASE_P, clLT, clMONOTONIC,
  clNAME_CHAR, clNULL, clOR, clSET_CHAR_BIT, clSIMPLE_BASE_STRING,
  clSIMPLE_EXTENDED_STRING, clSIMPLE_STRING, clSTANDARD_CHAR_P,
  clSTRING, clSTRING_EQUAL, clSUBT, clTYPE_ERROR, clUPPER_CASE_P;

static clObject C_Backspace, C_Bell, C_Escape, C_Newline, C_Null,
  C_Page, C_Return, C_Rubout, C_Space, C_Tab, C_tilde, CONS_0, CONS_1,
  CONS_10, CONS_11, CONS_12, CONS_13, CONS_14, CONS_15, CONS_16,
  CONS_17, CONS_18, CONS_19, CONS_2, CONS_20, CONS_21, CONS_22,
  CONS_23, CONS_24, CONS_25, CONS_26, CONS_27, CONS_28, CONS_29,
  CONS_3, CONS_30, CONS_31, CONS_32, CONS_33, CONS_34, CONS_35,
  CONS_36, CONS_37, CONS_38, CONS_39, CONS_4, CONS_5, CONS_6, CONS_7,
  CONS_8, CONS_9, I_minus1, I_0, I_1, I_10, I_1114112, I_127, I_128,
  I_159, I_2, I_256, I_3, I_32, I_37, I_4, I_48, I_55, I_64, I_87,
  keyCONTROL, keyDATUM, keyDEFAULT, keyEXPECTED_TYPE, keyMETA, keyTEST,
  STR_Backspace__9, STR_Bell__12, STR_CONTROL__15, STR_DATUM__0,
  STR_DEFAULT__17, STR_Delete__13, STR_EXPECTED_TYPE__1,
  STR_Escape__10, STR_Linefeed__8, STR_META__16, STR_Newline__2,
  STR_Null__11, STR_Page__5, STR_Return__7, STR_Rubout__6,
  STR_Space__3, STR_TEST__14, STR_Tab__4;

clObject clStandardCharP clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g395;
    { clObject L_1;
      clSetq(L_1, CL_char);
      clSetq(L_g395, clCharLESSEQUAL(C_Space, L_1, C_tilde, clEOA)); }
    if (clTrue(L_g395))
      return(clValues1(L_g395));
    else
      { clObject L_0;
        clSetq(L_0, CL_char);
        return(clCharEQUAL(L_0, C_Newline, clEOA)); } } }

clObject clGraphicCharP clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { wint_t L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, CL_char);
        L_0__R1 = clCharacterInt(L_0__R2); }
      L_0 = iswprint(L_0__R1); }
    return(clValues1(clTest(L_0))); } }

clObject clAlphaCharP clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { wint_t L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, CL_char);
        L_0__R1 = clCharacterInt(L_0__R2); }
      L_0 = iswalpha(L_0__R1); }
    return(clValues1(clTest(L_0))); } }

clObject clUpperCaseP clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { wint_t L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, CL_char);
        L_0__R1 = clCharacterInt(L_0__R2); }
      L_0 = iswupper(L_0__R1); }
    return(clValues1(clTest(L_0))); } }

clObject clLowerCaseP clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { wint_t L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, CL_char);
        L_0__R1 = clCharacterInt(L_0__R2); }
      L_0 = iswlower(L_0__R1); }
    return(clValues1(clTest(L_0))); } }

clObject clBothCaseP clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { wint_t L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, CL_char);
        L_0__R1 = clCharacterInt(L_0__R2); }
      L_0 = iswalpha(L_0__R1); }
    return(clValues1(clTest(L_0))); } }

clObject clDigitCharP clVdecl(_ap)
{ clObject CL_char, radix, code;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(radix, (_clVp(_ap) ? clVpop(_ap) : I_10));
    { clObject L_0;
      clSetq(L_0, CL_char);
      clSetq(code, clCharInt(L_0, clEOA)); }
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, code);
    { clObject L_test;
      { clObject L_0__R1;
        clSetq(L_0__R1, CL_char);
        clSetq(L_test, clUpperCaseP(L_0__R1, clEOA)); }
      if (clTrue(L_test))
        clSetq(L_1, I_55);
      else
        { clObject L_test__R1;
          { clObject L_0__R1;
            clSetq(L_0__R1, CL_char);
            clSetq(L_test__R1, clLowerCaseP(L_0__R1, clEOA)); }
          clSetq(L_1, (clTrue(L_test__R1) ? I_87 : I_48)); } }
    clSetq(code,
           clFuncallFunction(clSymbolFunctionValue(clSUBT),
                             L_0,
                             L_1,
                             clEOA)); }
  { clObject L_test;
    { clObject L_mid409, L_high410;
      clSetq(L_mid409, code);
      clSetq(L_high410, radix);
      clSetq(L_test,
             (clTrue(clFuncallFunction(clSymbolFunctionValue(clLT),
                                       I_minus1,
                                       L_mid409,
                                       clEOA)) ?
              clFuncallFunction(clSymbolFunctionValue(clLT),
                                L_mid409,
                                L_high410,
                                clEOA) :
              clNIL)); }
    if (clTrue(L_test))
      return(clValues1(code));
    else return(clValues1(clNIL)); } }

clObject clAlphanumericp clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { wint_t L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, CL_char);
        L_0__R1 = clCharacterInt(L_0__R2); }
      L_0 = iswalnum(L_0__R1); }
    return(clValues1(clTest(L_0))); } }

clObject clMonotonic clVdecl(_ap)
{ clObject CL_char, rest, test, key, item;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(rest,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    { clObject L_1, L_0;
      clSetq(L_0, key);
      clSetq(L_1, CL_char);
      clSetq(item, clFuncall(L_0, L_1, clEOA)); }
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_sublist411, next;
    clSetq(L_sublist411, rest);
    clSetq(next, clCar(L_sublist411, clEOA));
    clLabel(l_ITERATE412);
    if (clTrue(clEndp(L_sublist411, clEOA))) return(clValues1(clT));
    { clObject old;
      clSetq(old, item);
      { clObject L_test;
        { clObject L_0;
          { clObject L_2, L_0__R1;
            clSetq(L_0__R1, test);
            { clObject L_0__R2;
              clSetq(L_0__R2, key);
              clSetq(L_2,
                     clSetq(item, clFuncall(L_0__R2, next, clEOA))); }
            clSetq(L_0, clFuncall(L_0__R1, old, L_2, clEOA)); }
          clSetq(L_test, clNot(L_0, clEOA)); }
        if (clTrue(L_test)) return(clValues1(clNIL)); } }
    { clObject L_0;
      clSetq(L_0, L_sublist411);
      clSetq(L_sublist411, clCdr(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, L_sublist411);
      clSetq(next, clCar(L_0, clEOA)); }
    goto l_ITERATE412; } }

clObject clCharKey clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, CL_char);
      clSetq(L_0, clCharDowncase(L_0__R1, clEOA)); }
    return(clCharInt(L_0, clEOA)); } }

clObject clCharEQUAL clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(clequalsymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_INT),
                       clEOA)); } }

clObject clCharLESS clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(cllesssymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_INT),
                       clEOA)); } }

clObject clCharGREATER clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(clgreatersymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_INT),
                       clEOA)); } }

clObject clCharLESSEQUAL clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(cllessequalsymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_INT),
                       clEOA)); } }

clObject clCharGREATEREQUAL clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(clgreaterequalsymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_INT),
                       clEOA)); } }

clObject clCharEqual clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(clequalsymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_KEY),
                       clEOA)); } }

clObject clCharLessp clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(cllesssymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_KEY),
                       clEOA)); } }

clObject clCharGreaterp clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(clgreatersymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_KEY),
                       clEOA)); } }

clObject clCharNotGreaterp clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(cllessequalsymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_KEY),
                       clEOA)); } }

clObject clCharNotLessp clVdecl(_ap)
{ clObject character, more_characters;
  { clBeginParse(_ap);
    clSetq(character,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(more_characters, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, character);
    clSetq(L_2, clSymbolFunctionValue(clgreaterequalsymbol));
    return(clMonotonic(L_0,
                       more_characters,
                       L_2,
                       clSymbolFunctionValue(clCHAR_KEY),
                       clEOA)); } }

clObject clDifferent clVdecl(_ap)
{ clObject args, key;
  { clBeginParse(_ap);
    clSetq(args,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject remaining, current;
    clSetq(remaining, args);
    clSetq(current, clNIL);
    clLabel(l_ITERATE504);
    if (clTrue(clNull(remaining, clEOA))) return(clValues1(clT));
    { clObject L_0;
      clSetq(L_0, key);
      clSetq(current,
             clFuncall(L_0, clCar(remaining, clEOA), clEOA)); }
    { clObject L_g507;
      clSetq(L_g507, current);
      clRplaca(remaining, L_g507, clEOA);
      (void) L_g507; }
    { clObject previous;
      clSetq(previous, args);
      clLabel(l_ITERATE508);
      if (_clEq(previous, remaining)) clLocalReturn(NIL);
      { clObject L_test;
        { clObject L_1, L_0;
          clSetq(L_0, clCar(previous, clEOA));
          clSetq(L_1, current);
          clSetq(L_test,
                 clFuncallFunction(clSymbolFunctionValue(clEQ_NUMBER),
                                   L_0,
                                   L_1,
                                   clEOA)); }
        if (clTrue(L_test)) return(clValues1(clNIL)); }
      { clObject L_value509;
        clSetq(L_value509, clCdr(previous, clEOA));
        clSetq(previous, L_value509); }
      goto l_ITERATE508; }
    clBlockEnd(NIL);
    { clObject L_value510;
      clSetq(L_value510, clRest(remaining, clEOA));
      clSetq(remaining, L_value510); }
    goto l_ITERATE504; } }

clObject clCharDIVEQUAL clVdecl(_ap)
{ clObject chars;
  { clBeginParse(_ap); clSetq(chars, clVargs(_ap)); clEndParse(_ap); }
  return(clDifferent(chars, clSymbolFunctionValue(clCHAR_INT),
                     clEOA)); }

clObject clCharNotEqual clVdecl(_ap)
{ clObject chars;
  { clBeginParse(_ap); clSetq(chars, clVargs(_ap)); clEndParse(_ap); }
  return(clDifferent(chars, clSymbolFunctionValue(clCHAR_KEY),
                     clEOA)); }

clObject clCharInt clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { int L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, CL_char);
      L_0 = clCharacterInt(L_0__R1); }
    return(clValues1(clIntInteger(L_0))); } }

clObject clCodeChar clVdecl(_ap)
{ clObject code;
  { clBeginParse(_ap);
    clSetq(code,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0, code);
      clSetq(L_test,
             clFuncallFunction(clSymbolFunctionValue(clLT),
                               L_0,
                               I_1114112,
                               clEOA)); }
    if (clTrue(L_test))
      { int L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, code);
          L_0 = clFixnumInt(L_0__R1); }
        return(clValues1(clIntCharacter(L_0))); }
    else return(clValues1(clNIL)); } }

clObject clCharacter clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g511;
    clSetq(L_g511, object);
    { clObject L_class_name513;
      clSetq(L_class_name513, clInstanceTag(L_g511));
      if (_clEq(L_class_name513, clCHARACTER))
        return(clValues1(object));
      else if (clTrue((_clEq(L_class_name513, clSYMBOL) ?
                       CONS_0 :
                       (_clEq(L_class_name513, clNULL) ?
                        CONS_1 :
                        (_clEq(L_class_name513, clCOMPLEX_STRING) ?
                         CONS_2 :
                         (_clEq(L_class_name513, clSIMPLE_STRING) ?
                          CONS_3 :
                          (_clEq(L_class_name513, clCOMPLEX_EXTENDED_STRING) ?
                           CONS_4 :
                           (_clEq(L_class_name513, clCOMPLEX_BASE_STRING) ?
                            CONS_5 :
                            (_clEq(L_class_name513, clSIMPLE_EXTENDED_STRING) ?
                             CONS_6 :
                             (_clEq(L_class_name513, clSIMPLE_BASE_STRING) ?
                              CONS_7 :
                              clNIL))))))))))
        { clObject string;
          { clObject L_0;
            clSetq(L_0, object);
            clSetq(string, clString(L_0, clEOA)); }
          { clObject L_test__R2;
            { clObject L_0;
              clSetq(L_0, clLength(string, clEOA));
              clSetq(L_test__R2,
                     clFuncallFunction(clSymbolFunctionValue(clEQ_NUMBER),
                                       L_0,
                                       I_1,
                                       clEOA)); }
            if (clTrue(L_test__R2))
              return(clFuncallFunction(clSymbolFunctionValue(clCHAR),
                                       string,
                                       I_0,
                                       clEOA));
            else
              { clObject L_2;
                clSetq(L_2, object);
                return(clError(clTYPE_ERROR,
                               keyDATUM,
                               L_2,
                               keyEXPECTED_TYPE,
                               clCHARACTER_DESIGNATOR,
                               clEOA)); } } }
      else
        return(clError(clTYPE_ERROR,
                       keyDATUM,
                       L_g511,
                       keyEXPECTED_TYPE,
                       CONS_8,
                       clEOA)); } } }

clObject clCharUpcase clVdecl(_ap)
{ clObject CL_char;
  wint_t code;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    { clObject L_0;
      clSetq(L_0, CL_char);
      code = clCharacterWint(L_0); }
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clTest(iswlower(code))))
    return(clValues1(clWintCharacter(towupper(code))));
  else return(clValues1(CL_char)); }

clObject clCharDowncase clVdecl(_ap)
{ clObject CL_char;
  wint_t code;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    { clObject L_0;
      clSetq(L_0, CL_char);
      code = clCharacterWint(L_0); }
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clTest(iswupper(code))))
    return(clValues1(clWintCharacter(towlower(code))));
  else return(clValues1(CL_char)); }

clObject clDigitChar clVdecl(_ap)
{ clObject weight, radix;
  { clBeginParse(_ap);
    clSetq(weight,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(radix, (_clVp(_ap) ? clVpop(_ap) : I_10));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_2, L_1;
      clSetq(L_1, weight);
      clSetq(L_2, radix);
      clSetq(L_test, clLESS_FUNC(I_minus1, L_1, L_2, I_37, clEOA)); }
    if (clTrue(L_test))
      { clObject L_0;
        { clObject L_1, L_0__R1;
          clSetq(L_0__R1, weight);
          { clObject L_test__R1;
            { clObject L_0__R2;
              clSetq(L_0__R2, weight);
              clSetq(L_test__R1,
                     clFuncallFunction(clSymbolFunctionValue(clLT),
                                       L_0__R2,
                                       I_10,
                                       clEOA)); }
            clSetq(L_1, (clTrue(L_test__R1) ? I_48 : I_55)); }
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clADD),
                                   L_0__R1,
                                   L_1,
                                   clEOA)); }
        return(clCodeChar(L_0, clEOA)); }
    else return(clValues1(clNIL)); } }

clObject clCharName clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_1, L_0__R1;
      clSetq(L_0__R1, CL_char);
      clSetq(L_1, clSymbolValue(clstarCHARACTER_NAMESstar, clEOA));
      clSetq(L_0,
             clAssoc(L_0__R1, L_1, keyTEST,
                     clSymbolFunctionValue(clCHARequal), clEOA)); }
    return(clCdr(L_0, clEOA)); } }

clObject clNameChar clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_1, L_0__R1;
      { clObject L_0__R2;
        clSetq(L_0__R2, name);
        clSetq(L_0__R1, clString(L_0__R2, clEOA)); }
      clSetq(L_1, clSymbolValue(clstarCHARACTER_NAMESstar, clEOA));
      clSetq(L_0,
             clRassoc(L_0__R1,
                      L_1,
                      keyTEST,
                      clSymbolFunctionValue(clSTRING_EQUAL),
                      clEOA)); }
    return(clCar(L_0, clEOA)); } }

clObject clCharBit clVdecl(_ap)
{ clObject L_ap, CL_char, L_keys, control, meta, code;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyCONTROL, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(control, clCar(L_0, clEOA)); }
    else clSetq(control, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyMETA, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(meta, clCar(L_0, clEOA)); }
    else clSetq(meta, clNIL);
    { clObject L_0;
      clSetq(L_0, CL_char);
      clSetq(code, clCharInt(L_0, clEOA)); }
    clCheckKeys(L_keys, CONS_38, clEOA);
    clEndParse(_ap); }
  if (clTrue(clFuncallFunction(clSymbolFunctionValue(clLT),
                               code,
                               I_256,
                               clEOA)))
    { clObject L_g531;
      if (clTrue(control))
        { clObject L_0;
          clSetq(L_0, clLogand(I_127, code, clEOA));
          clSetq(L_g531,
                 clFuncallFunction(clSymbolFunctionValue(clLT),
                                   L_0,
                                   I_32,
                                   clEOA)); }
      else clSetq(L_g531, clNIL);
      if (clTrue(L_g531))
        return(clValues1(L_g531));
      else if (clTrue(meta))
        return(clFuncallFunction(clSymbolFunctionValue(clGT),
                                 code,
                                 I_127,
                                 clEOA));
      else return(clValues1(clNIL)); }
  else return(clValues1(clNIL)); }

clObject clSetCharBit clVdecl(_ap)
{ clObject L_ap, CL_char, L_keys, control, meta;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyCONTROL, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(control, clCar(L_0, clEOA)); }
    else clSetq(control, keyDEFAULT);
    if (clTrue(clSetq(L_ap, clKeyArg(keyMETA, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(meta, clCar(L_0, clEOA)); }
    else clSetq(meta, keyDEFAULT);
    clCheckKeys(L_keys, CONS_38, clEOA);
    clEndParse(_ap); }
  { clObject code;
    { clObject L_0;
      clSetq(L_0, CL_char);
      clSetq(code, clCharInt(L_0, clEOA)); }
    if (clTrue(clFuncallFunction(clSymbolFunctionValue(clLT),
                                 code,
                                 I_256,
                                 clEOA)))
      { { clObject L_key532;
          clSetq(L_key532, control);
          if (_clEq(L_key532, clNIL))
            { clObject L_test__R2;
              { clObject L_0;
                clSetq(L_0, clLogand(I_127, code, clEOA));
                clSetq(L_test__R2,
                       clFuncallFunction(clSymbolFunctionValue(clLT),
                                         L_0,
                                         I_32,
                                         clEOA)); }
              if (clTrue(L_test__R2))
                { clObject L_1;
                  clSetq(L_1, code);
                  clSetq(code, clLogior(I_64, L_1, clEOA)); } }
          else if (!_clEq(L_key532, keyDEFAULT))
            { clObject L_1;
              clSetq(L_1, code);
              clSetq(code, clLogand(I_159, L_1, clEOA)); } }
        { clObject L_key533;
          clSetq(L_key533, meta);
          if (_clEq(L_key533, clNIL))
            { clObject L_1;
              clSetq(L_1, code);
              clSetq(code, clLogand(I_127, L_1, clEOA)); }
          else if (!_clEq(L_key533, keyDEFAULT))
            { clObject L_1;
              clSetq(L_1, code);
              clSetq(code, clLogior(I_128, L_1, clEOA)); } } }
    { clObject L_0;
      clSetq(L_0, code);
      return(clCodeChar(L_0, clEOA)); } } }

clObject clCharCode clVdecl(_ap)
{ clObject CL_char;
  { clBeginParse(_ap);
    clSetq(CL_char,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject code;
    { clObject L_0;
      clSetq(L_0, CL_char);
      clSetq(code, clCharInt(L_0, clEOA)); }
    if (clTrue(clFuncallFunction(clSymbolFunctionValue(clLT),
                                 code,
                                 I_256,
                                 clEOA)))
      { { clObject L_1;
          clSetq(L_1, code);
          clSetq(code, clLogand(I_127, L_1, clEOA)); }
        { clObject L_test__R1;
          { clObject L_0;
            clSetq(L_0, code);
            clSetq(L_test__R1,
                   clFuncallFunction(clSymbolFunctionValue(clLT),
                                     L_0,
                                     I_32,
                                     clEOA)); }
          if (clTrue(L_test__R1))
            { clObject L_1;
              clSetq(L_1, code);
              clSetq(code, clLogior(I_64, L_1, clEOA)); } } }
    return(clValues1(code)); } }

void clInitCharacter __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(C_Space, clIntCharacter(' '));
  clSetq(C_tilde, clIntCharacter('~'));
  clSetq(C_Newline, clIntCharacter('\n'));
  clSetq(I_10, clIntFixnum(10));
  clSetq(I_55, clIntFixnum(55));
  clSetq(I_87, clIntFixnum(87));
  clSetq(I_48, clIntFixnum(48));
  clSetq(I_minus1, clIntFixnum(-1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(I_3, clIntFixnum(3));
  clSetq(I_4, clIntFixnum(4));
  clSetq(I_1114112, clIntFixnum(1114112));
  clSetq(CONS_7, clCons(clSIMPLE_BASE_STRING, clNIL, clEOA));
  clSetq(CONS_6, clCons(clSIMPLE_EXTENDED_STRING, CONS_7, clEOA));
  clSetq(CONS_5, clCons(clCOMPLEX_BASE_STRING, CONS_6, clEOA));
  clSetq(CONS_4, clCons(clCOMPLEX_EXTENDED_STRING, CONS_5, clEOA));
  clSetq(CONS_3, clCons(clSIMPLE_STRING, CONS_4, clEOA));
  clSetq(CONS_2, clCons(clCOMPLEX_STRING, CONS_3, clEOA));
  clSetq(CONS_1, clCons(clNULL, CONS_2, clEOA));
  clSetq(CONS_0, clCons(clSYMBOL, CONS_1, clEOA));
  clSetq(I_0, clIntFixnum(0));
  clSetq(STR_DATUM__0, clCharpSimpleBaseString("DATUM"));
  clSetq(keyDATUM, clMakeKeyword(STR_DATUM__0, clEOA));
  clSetq(STR_EXPECTED_TYPE__1,
         clCharpSimpleBaseString("EXPECTED-TYPE"));
  clSetq(keyEXPECTED_TYPE, clMakeKeyword(STR_EXPECTED_TYPE__1, clEOA));
  clSetq(CONS_13, clCons(clSYMBOL, clNIL, clEOA));
  clSetq(CONS_12, clCons(clSTRING, CONS_13, clEOA));
  clSetq(CONS_11, clCons(clOR, CONS_12, clEOA));
  clSetq(CONS_10, clCons(CONS_11, clNIL, clEOA));
  clSetq(CONS_9, clCons(clCHARACTER, CONS_10, clEOA));
  clSetq(CONS_8, clCons(clOR, CONS_9, clEOA));
  clSetq(I_37, clIntFixnum(37));
  clSetq(STR_Newline__2, clCharpSimpleBaseString("Newline"));
  clSetq(CONS_15, clCons(C_Newline, STR_Newline__2, clEOA));
  clSetq(STR_Space__3, clCharpSimpleBaseString("Space"));
  clSetq(CONS_17, clCons(C_Space, STR_Space__3, clEOA));
  clSetq(C_Tab, clIntCharacter('\t'));
  clSetq(STR_Tab__4, clCharpSimpleBaseString("Tab"));
  clSetq(CONS_19, clCons(C_Tab, STR_Tab__4, clEOA));
  clSetq(C_Page, clIntCharacter('\f'));
  clSetq(STR_Page__5, clCharpSimpleBaseString("Page"));
  clSetq(CONS_21, clCons(C_Page, STR_Page__5, clEOA));
  clSetq(C_Rubout, clIntCharacter('\177'));
  clSetq(STR_Rubout__6, clCharpSimpleBaseString("Rubout"));
  clSetq(CONS_23, clCons(C_Rubout, STR_Rubout__6, clEOA));
  clSetq(C_Return, clIntCharacter('\r'));
  clSetq(STR_Return__7, clCharpSimpleBaseString("Return"));
  clSetq(CONS_25, clCons(C_Return, STR_Return__7, clEOA));
  clSetq(STR_Linefeed__8, clCharpSimpleBaseString("Linefeed"));
  clSetq(CONS_27, clCons(C_Newline, STR_Linefeed__8, clEOA));
  clSetq(C_Backspace, clIntCharacter('\b'));
  clSetq(STR_Backspace__9, clCharpSimpleBaseString("Backspace"));
  clSetq(CONS_29, clCons(C_Backspace, STR_Backspace__9, clEOA));
  clSetq(C_Escape, clIntCharacter('\033'));
  clSetq(STR_Escape__10, clCharpSimpleBaseString("Escape"));
  clSetq(CONS_31, clCons(C_Escape, STR_Escape__10, clEOA));
  clSetq(C_Null, clIntCharacter('\0'));
  clSetq(STR_Null__11, clCharpSimpleBaseString("Null"));
  clSetq(CONS_33, clCons(C_Null, STR_Null__11, clEOA));
  clSetq(C_Bell, clIntCharacter('\007'));
  clSetq(STR_Bell__12, clCharpSimpleBaseString("Bell"));
  clSetq(CONS_35, clCons(C_Bell, STR_Bell__12, clEOA));
  clSetq(STR_Delete__13, clCharpSimpleBaseString("Delete"));
  clSetq(CONS_37, clCons(C_Rubout, STR_Delete__13, clEOA));
  clSetq(CONS_36, clCons(CONS_37, clNIL, clEOA));
  clSetq(CONS_34, clCons(CONS_35, CONS_36, clEOA));
  clSetq(CONS_32, clCons(CONS_33, CONS_34, clEOA));
  clSetq(CONS_30, clCons(CONS_31, CONS_32, clEOA));
  clSetq(CONS_28, clCons(CONS_29, CONS_30, clEOA));
  clSetq(CONS_26, clCons(CONS_27, CONS_28, clEOA));
  clSetq(CONS_24, clCons(CONS_25, CONS_26, clEOA));
  clSetq(CONS_22, clCons(CONS_23, CONS_24, clEOA));
  clSetq(CONS_20, clCons(CONS_21, CONS_22, clEOA));
  clSetq(CONS_18, clCons(CONS_19, CONS_20, clEOA));
  clSetq(CONS_16, clCons(CONS_17, CONS_18, clEOA));
  clSetq(CONS_14, clCons(CONS_15, CONS_16, clEOA));
  clSetq(STR_TEST__14, clCharpSimpleBaseString("TEST"));
  clSetq(keyTEST, clMakeKeyword(STR_TEST__14, clEOA));
  clSetq(STR_CONTROL__15, clCharpSimpleBaseString("CONTROL"));
  clSetq(keyCONTROL, clMakeKeyword(STR_CONTROL__15, clEOA));
  clSetq(STR_META__16, clCharpSimpleBaseString("META"));
  clSetq(keyMETA, clMakeKeyword(STR_META__16, clEOA));
  clSetq(CONS_39, clCons(keyCONTROL, clNIL, clEOA));
  clSetq(CONS_38, clCons(keyMETA, CONS_39, clEOA));
  clSetq(I_256, clIntFixnum(256));
  clSetq(I_127, clIntFixnum(127));
  clSetq(I_32, clIntFixnum(32));
  clSetq(STR_DEFAULT__17, clCharpSimpleBaseString("DEFAULT"));
  clSetq(keyDEFAULT, clMakeKeyword(STR_DEFAULT__17, clEOA));
  clSetq(I_64, clIntFixnum(64));
  clSetq(I_159, clIntFixnum(159));
  clSetq(I_128, clIntFixnum(128));

  clSetSymbolFunctionValue(clSTANDARD_CHAR_P,
                           clMakeClosure(0,
                                         clStandardCharP,
                                         clNULL_HOOK));
  (void) clSTANDARD_CHAR_P;
  clSetSymbolFunctionValue(clGRAPHIC_CHAR_P,
                           clMakeClosure(0,
                                         clGraphicCharP,
                                         clNULL_HOOK));
  (void) clGRAPHIC_CHAR_P;
  clSetSymbolFunctionValue(clALPHA_CHAR_P,
                           clMakeClosure(0,
                                         clAlphaCharP,
                                         clNULL_HOOK));
  (void) clALPHA_CHAR_P;
  clSetSymbolFunctionValue(clUPPER_CASE_P,
                           clMakeClosure(0,
                                         clUpperCaseP,
                                         clNULL_HOOK));
  (void) clUPPER_CASE_P;
  clSetSymbolFunctionValue(clLOWER_CASE_P,
                           clMakeClosure(0,
                                         clLowerCaseP,
                                         clNULL_HOOK));
  (void) clLOWER_CASE_P;
  clSetSymbolFunctionValue(clBOTH_CASE_P,
                           clMakeClosure(0, clBothCaseP, clNULL_HOOK));
  (void) clBOTH_CASE_P;
  clSetSymbolFunctionValue(clDIGIT_CHAR_P,
                           clMakeClosure(0,
                                         clDigitCharP,
                                         clNULL_HOOK));
  (void) clDIGIT_CHAR_P;
  clSetSymbolFunctionValue(clALPHANUMERICP,
                           clMakeClosure(0,
                                         clAlphanumericp,
                                         clNULL_HOOK));
  (void) clALPHANUMERICP;
  clSetSymbolFunctionValue(clMONOTONIC,
                           clMakeClosure(0, clMonotonic, clNULL_HOOK));
  (void) clMONOTONIC;
  clSetSymbolFunctionValue(clCHAR_KEY,
                           clMakeClosure(0, clCharKey, clNULL_HOOK));
  (void) clCHAR_KEY;
  clSetSymbolFunctionValue(clCHARequal,
                           clMakeClosure(0, clCharEQUAL, clNULL_HOOK));
  (void) clCHARequal;
  clSetSymbolFunctionValue(clCHARless,
                           clMakeClosure(0, clCharLESS, clNULL_HOOK));
  (void) clCHARless;
  clSetSymbolFunctionValue(clCHARgreater,
                           clMakeClosure(0,
                                         clCharGREATER,
                                         clNULL_HOOK));
  (void) clCHARgreater;
  clSetSymbolFunctionValue(clCHARlessequal,
                           clMakeClosure(0,
                                         clCharLESSEQUAL,
                                         clNULL_HOOK));
  (void) clCHARlessequal;
  clSetSymbolFunctionValue(clCHARgreaterequal,
                           clMakeClosure(0,
                                         clCharGREATEREQUAL,
                                         clNULL_HOOK));
  (void) clCHARgreaterequal;
  clSetSymbolFunctionValue(clCHAR_EQUAL,
                           clMakeClosure(0, clCharEqual, clNULL_HOOK));
  (void) clCHAR_EQUAL;
  clSetSymbolFunctionValue(clCHAR_LESSP,
                           clMakeClosure(0, clCharLessp, clNULL_HOOK));
  (void) clCHAR_LESSP;
  clSetSymbolFunctionValue(clCHAR_GREATERP,
                           clMakeClosure(0,
                                         clCharGreaterp,
                                         clNULL_HOOK));
  (void) clCHAR_GREATERP;
  clSetSymbolFunctionValue(clCHAR_NOT_GREATERP,
                           clMakeClosure(0,
                                         clCharNotGreaterp,
                                         clNULL_HOOK));
  (void) clCHAR_NOT_GREATERP;
  clSetSymbolFunctionValue(clCHAR_NOT_LESSP,
                           clMakeClosure(0,
                                         clCharNotLessp,
                                         clNULL_HOOK));
  (void) clCHAR_NOT_LESSP;
  clSetSymbolFunctionValue(clDIFFERENT,
                           clMakeClosure(0, clDifferent, clNULL_HOOK));
  (void) clDIFFERENT;
  clSetSymbolFunctionValue(clCHARslashequal,
                           clMakeClosure(0,
                                         clCharDIVEQUAL,
                                         clNULL_HOOK));
  (void) clCHARslashequal;
  clSetSymbolFunctionValue(clCHAR_NOT_EQUAL,
                           clMakeClosure(0,
                                         clCharNotEqual,
                                         clNULL_HOOK));
  (void) clCHAR_NOT_EQUAL;
  clSetSymbolFunctionValue(clCHAR_INT,
                           clMakeClosure(0, clCharInt, clNULL_HOOK));
  (void) clCHAR_INT;
  clSetSymbolFunctionValue(clCODE_CHAR,
                           clMakeClosure(0, clCodeChar, clNULL_HOOK));
  (void) clCODE_CHAR;
  clSetSymbolFunctionValue(clCHARACTER,
                           clMakeClosure(0, clCharacter, clNULL_HOOK));
  (void) clCHARACTER;
  clSetSymbolFunctionValue(clCHAR_UPCASE,
                           clMakeClosure(0,
                                         clCharUpcase,
                                         clNULL_HOOK));
  (void) clCHAR_UPCASE;
  clSetSymbolFunctionValue(clCHAR_DOWNCASE,
                           clMakeClosure(0,
                                         clCharDowncase,
                                         clNULL_HOOK));
  (void) clCHAR_DOWNCASE;
  clSetSymbolFunctionValue(clDIGIT_CHAR,
                           clMakeClosure(0, clDigitChar, clNULL_HOOK));
  (void) clDIGIT_CHAR;
  cl_SETF_GlobalDeclaration(clT,
                            clstarCHARACTER_NAMESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarCHARACTER_NAMESstar, CONS_14);
  (void) clstarCHARACTER_NAMESstar;
  clSetSymbolFunctionValue(clCHAR_NAME,
                           clMakeClosure(0, clCharName, clNULL_HOOK));
  (void) clCHAR_NAME;
  clSetSymbolFunctionValue(clNAME_CHAR,
                           clMakeClosure(0, clNameChar, clNULL_HOOK));
  (void) clNAME_CHAR;
  clSetSymbolFunctionValue(clCHAR_BIT,
                           clMakeClosure(0, clCharBit, clNULL_HOOK));
  (void) clCHAR_BIT;
  clSetSymbolFunctionValue(clSET_CHAR_BIT,
                           clMakeClosure(0,
                                         clSetCharBit,
                                         clNULL_HOOK));
  (void) clSET_CHAR_BIT;
  clSetSymbolFunctionValue(clCHAR_CODE,
                           clMakeClosure(0, clCharCode, clNULL_HOOK));
  (void) clCHAR_CODE;
  clUnwind(4); }
