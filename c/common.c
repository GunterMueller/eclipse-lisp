/* Generated by Eclipse Common Lisp 1.1-HOSTED for howard on circe.
   Friday the sixth of March, 1998, 3:41:54 pm CST. */
#include <eclipse.h>

clObject clBoundp(clProto), clCadr(clProto), clCar(clProto),
  clCddr(clProto), clCdr(clProto),
  clCharpSimpleBaseString __P((clCharp)), clCons(clProto),
  clConsp(clProto), clConstantp(clProto), clEndp(clProto),
  clEq(clProto), clError(clProto), clExtraArgs(clProto),
  clFuncall(clProto), clGet(clProto), cl_SETF_Get(clProto),
  clGetf(clProto), cl_SETF_GlobalDeclaration(clProto), clList(clProto),
  clListp(clProto), clMakeKeyword(clProto), clMissingArgs(clProto),
  clNot(clProto), clNull(clProto), clPutf(clProto),
  clRedefineConstant(clProto), clRplaca(clProto), clSecond(clProto),
  clSetfFunctionNameP(clProto), clSignalProgramError(clProto),
  clSymbolp(clProto), clWarn(clProto);

extern clObject clampersandALLOW_OTHER_KEYS, clampersandAUX,
  clampersandBODY, clampersandENVIRONMENT, clampersandKEY,
  clampersandOPTIONAL, clampersandREST, clampersandWHOLE, clSPECIAL,
  clstarCONSTANT_CHECK_HOOKstar, clBINDINGFORM_INITFORM,
  clBINDINGFORM_NAME, clCAR_EQ, clCONSTANT, clEXTRA_ARGS,
  clFUNCTION_NAME, clFUNCTION_NAME_KEY, clGLOBAL_DECLARATION,
  clGLOBAL_VARIABLE, clKEY_ARG, clKEY_NOT_ALLOWED,
  clLAMBDA_LIST_KEYWORD_P, clLAMBDA_LIST_KEYWORDS, clLIST_ARG,
  clMISSING_ARGS, clREDEFINE_CONSTANT, clSETF, clSETF_FUNCTION_NAME_P,
  clTYPE_ERROR, clXOR;

static clObject CONS_0, CONS_1, CONS_10, CONS_11, CONS_2, CONS_3,
  CONS_4, CONS_5, CONS_6, CONS_7, CONS_8, CONS_9, I_1, I_2, I_3, I_4,
  keyDATUM, keyEXPECTED_TYPE, STR_DATUM__4, STR_EXPECTED_TYPE__3,
  STRn_0, STRn_1, STRn_2, STRn_5;

clObject clMissingArgs clVdecl(_ap)
{ clObject v;
  { clBeginParse(_ap);
    clSetq(v, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clEndParse(_ap); }
  return(clSignalProgramError(STRn_0, v, clEOA)); }

clObject clExtraArgs clVdecl(_ap)
{ clObject args;
  { clBeginParse(_ap);
    clSetq(args,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clEndParse(_ap); }
  return(clSignalProgramError(STRn_1, args, clEOA)); }

clObject clKeyNotAllowed clVdecl(_ap)
{ clObject key, format, args;
  { clBeginParse(_ap);
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(format, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    clSetq(args, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_2;
    clSetq(L_2, format);
    return(clSignalProgramError(STRn_2, key, L_2, args, clEOA)); } }

clObject clLambdaListKeywordP clVdecl(_ap)
{ clObject parameter_spec;
  { clBeginParse(_ap);
    clSetq(parameter_spec,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_sub115;
    clSetq(L_sub115, CONS_0);
    clLabel(l_ITERATE118);
    if (clTrue(clEndp(L_sub115, clEOA))) return(clValues1(clNIL));
    if (_clEq(parameter_spec, clCar(L_sub115, clEOA)))
      return(clValues1(L_sub115));
    { clObject L_value119;
      clSetq(L_value119, clCdr(L_sub115, clEOA));
      clSetq(L_sub115, L_value119); }
    goto l_ITERATE118; } }

clObject clCarEq clVdecl(_ap)
{ clObject x, expected_car;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(expected_car,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clConsp(x, clEOA)))
    { clObject L_0;
      clSetq(L_0, clCar(x, clEOA));
      return(clEq(L_0, expected_car, clEOA)); }
  else return(clValues1(clNIL)); }

clObject clXor clVdecl(_ap)
{ clObject a, b;
  { clBeginParse(_ap);
    clSetq(a, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(b, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(a)) return(clNot(b, clEOA)); else return(clValues1(b)); }

clObject clSetfFunctionNameP clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clConsp(name, clEOA)))
    { clObject L_form120, key, block, more;
      clSetq(L_form120, name);
      if (clTrue(L_form120))
        { clObject L_top121;
          clSetq(L_top121, clCar(L_form120, clEOA));
          { clObject L_0;
            clSetq(L_0, L_form120);
            clSetq(L_form120, clCdr(L_0, clEOA)); }
          clSetq(key, L_top121); }
      else clSetq(key, clNIL);
      if (clTrue(L_form120))
        { clObject L_top122;
          { clObject L_0;
            clSetq(L_0, L_form120);
            clSetq(L_top122, clCar(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, L_form120);
            clSetq(L_form120, clCdr(L_0, clEOA)); }
          clSetq(block, L_top122); }
      else clSetq(block, clNIL);
      clSetq(more, L_form120);
      if (clTrue(clNull(more, clEOA)))
        { clObject L_test__R2;
          { clObject L_0;
            clSetq(L_0, block);
            clSetq(L_test__R2, clSymbolp(L_0, clEOA)); }
          if (clTrue(L_test__R2))
            { clObject L_item123;
              clSetq(L_item123, key);
              if (_clEq(L_item123, clSETF))
                return(clValues1(CONS_8));
              else if (_clEq(L_item123, clSETF))
                return(clValues1(CONS_9));
              else return(clValues1(clNIL)); }
          else return(clValues1(clNIL)); }
      else return(clValues1(clNIL)); }
  else return(clValues1(clNIL)); }

clObject clKeyArg clVdecl(_ap)
{ clObject item, plist;
  { clBeginParse(_ap);
    clSetq(item,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(plist,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject list;
    clSetq(list, plist);
    clLabel(l_ITERATE124);
    if (clTrue(clEndp(list, clEOA))) return(clValues1(clNIL));
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0, clCar(list, clEOA));
        clSetq(L_test, clEq(L_0, item, clEOA)); }
      if (clTrue(L_test)) return(clCdr(list, clEOA)); }
    { clObject L_value125;
      clSetq(L_value125, clCddr(list, clEOA));
      clSetq(list, L_value125); }
    goto l_ITERATE124; } }

clObject clBindingformName clVdecl(_ap)
{ clObject bindingform;
  { clBeginParse(_ap);
    clSetq(bindingform,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clConsp(bindingform, clEOA)))
    return(clCar(bindingform, clEOA));
  else return(clValues1(bindingform)); }

clObject clBindingformInitform clVdecl(_ap)
{ clObject bindingform, CL_default;
  { clBeginParse(_ap);
    clSetq(bindingform,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(CL_default, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clConsp(bindingform, clEOA)))
    return(clCadr(bindingform, clEOA));
  else return(clValues1(CL_default)); }

clObject clFunctionNameKey clVdecl(_ap)
{ clObject name, setfp;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(setfp,
           (_clVp(_ap) ? clVpop(_ap) :
            clSetfFunctionNameP(name, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(setfp))
    return(clSecond(name, clEOA));
  else if (clTrue(clSymbolp(name, clEOA)))
    return(clValues1(name));
  else
    return(clError(clTYPE_ERROR, keyEXPECTED_TYPE, clFUNCTION_NAME,
                   keyDATUM, name, clEOA)); }

clDeclareEnv(clListArg);
clObject clListArg clVdecl(_ap)
{ clUseEnv(clListArg);
  { clObject list;
    { clBeginParse(_ap);
      clSetq(list,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clListp(list, clEOA)))
      return(clValues1(list));
    else
      return(clRplaca(clEnv(0, *STARsymbol_listSTAR), list, clEOA)); } }

clObject clRedefineConstant clVdecl(_ap)
{ clObject name, CL_new, old;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(old, clSymbolValue(name, clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1,
               clSymbolValue(clstarCONSTANT_CHECK_HOOKstar, clEOA));
        clSetq(L_0, clFuncall(L_0__R1, old, CL_new, clEOA)); }
      clSetq(L_test, clNot(L_0, clEOA)); }
    if (clTrue(L_test))
      { if (clTrue(clConstantp(name, clEOA)))
          clWarn(STRn_5, name, old, CL_new, clEOA);
        return(clValues1(clSetSymbolValueValue(name, CL_new))); }
    else return(clValues1(clNIL)); } }

clObject clGlobalDeclaration clVdecl(_ap)
{ clObject name, category, key;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(category,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject decs;
    clSetq(decs, clGet(name, category, clEOA));
    if (clTrue(key))
      return(clGetf(decs, key, clEOA));
    else return(clValues1(decs)); } }

clObject cl_SETF_GlobalDeclaration clVdecl(_ap)
{ clObject value, variable, category, key;
  { clBeginParse(_ap);
    clSetq(value,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(category,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_value130;
    { clObject L_0;
      clSetq(L_0, clGet(variable, category, clEOA));
      clSetq(L_value130, clPutf(L_0, key, value, clEOA)); }
    cl_SETF_Get(L_value130, variable, category, clEOA);
    return(clValues1(value)); } }

void clInitCommon __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(STRn_0,
         clCharpSimpleBaseString("Too few arguments.~@[ Argument ~s not supplied.~]"));
  clSetq(STRn_1,
         clCharpSimpleBaseString("Too many arguments.~@[ Extra arguments are ~s.~]"));
  clSetq(STRn_2,
         clCharpSimpleBaseString("Illegal key ~s~@[ ~?~]."));
  clSetq(CONS_7, clCons(clampersandWHOLE, clNIL, clEOA));
  clSetq(CONS_6, clCons(clampersandREST, CONS_7, clEOA));
  clSetq(CONS_5, clCons(clampersandOPTIONAL, CONS_6, clEOA));
  clSetq(CONS_4, clCons(clampersandKEY, CONS_5, clEOA));
  clSetq(CONS_3, clCons(clampersandENVIRONMENT, CONS_4, clEOA));
  clSetq(CONS_2, clCons(clampersandBODY, CONS_3, clEOA));
  clSetq(CONS_1, clCons(clampersandAUX, CONS_2, clEOA));
  clSetq(CONS_0, clCons(clampersandALLOW_OTHER_KEYS, CONS_1, clEOA));
  clSetq(I_2, clIntFixnum(2));
  clSetq(CONS_9, clCons(clSETF, clNIL, clEOA));
  clSetq(CONS_8, clCons(clSETF, CONS_9, clEOA));
  clSetq(STR_EXPECTED_TYPE__3,
         clCharpSimpleBaseString("EXPECTED-TYPE"));
  clSetq(keyEXPECTED_TYPE, clMakeKeyword(STR_EXPECTED_TYPE__3, clEOA));
  clSetq(STR_DATUM__4,
         clCharpSimpleBaseString("DATUM"));
  clSetq(keyDATUM, clMakeKeyword(STR_DATUM__4, clEOA));
  clSetq(STRn_5,
         clCharpSimpleBaseString("Constant ~S being redefined from ~s to ~s."));
  clSetq(I_3, clIntFixnum(3));
  clSetq(I_4, clIntFixnum(4));
  clSetq(CONS_11, clCons(clGLOBAL_DECLARATION, clNIL, clEOA));
  clSetq(CONS_10, clCons(clSETF, CONS_11, clEOA));

  clSetSymbolFunctionValue(clMISSING_ARGS,
                           clMakeClosure(0,
                                         clMissingArgs,
                                         clNULL_HOOK));
  (void) clMISSING_ARGS;
  clSetSymbolFunctionValue(clEXTRA_ARGS,
                           clMakeClosure(0, clExtraArgs, clNULL_HOOK));
  (void) clEXTRA_ARGS;
  clSetSymbolFunctionValue(clKEY_NOT_ALLOWED,
                           clMakeClosure(0,
                                         clKeyNotAllowed,
                                         clNULL_HOOK));
  (void) clKEY_NOT_ALLOWED;
  cl_SETF_GlobalDeclaration(clT,
                            clLAMBDA_LIST_KEYWORDS,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clBoundp(clLAMBDA_LIST_KEYWORDS, clEOA)))
    { if (clTrue(clSymbolValue(clstarCONSTANT_CHECK_HOOKstar, clEOA)))
        clRedefineConstant(clLAMBDA_LIST_KEYWORDS, CONS_0, clEOA); }
  else clSetSymbolValueValue(clLAMBDA_LIST_KEYWORDS, CONS_0);
  cl_SETF_GlobalDeclaration(clT,
                            clLAMBDA_LIST_KEYWORDS,
                            clGLOBAL_VARIABLE,
                            clCONSTANT,
                            clEOA);
  (void) clLAMBDA_LIST_KEYWORDS;
  clSetSymbolFunctionValue(clLAMBDA_LIST_KEYWORD_P,
                           clMakeClosure(0,
                                         clLambdaListKeywordP,
                                         clNULL_HOOK));
  (void) clLAMBDA_LIST_KEYWORD_P;
  clSetSymbolFunctionValue(clCAR_EQ,
                           clMakeClosure(0, clCarEq, clNULL_HOOK));
  (void) clCAR_EQ;
  clSetSymbolFunctionValue(clXOR,
                           clMakeClosure(0, clXor, clNULL_HOOK));
  (void) clXOR;
  clSetSymbolFunctionValue(clSETF_FUNCTION_NAME_P,
                           clMakeClosure(0,
                                         clSetfFunctionNameP,
                                         clNULL_HOOK));
  (void) clSETF_FUNCTION_NAME_P;
  clSetSymbolFunctionValue(clKEY_ARG,
                           clMakeClosure(0, clKeyArg, clNULL_HOOK));
  (void) clKEY_ARG;
  clSetSymbolFunctionValue(clBINDINGFORM_NAME,
                           clMakeClosure(0,
                                         clBindingformName,
                                         clNULL_HOOK));
  (void) clBINDINGFORM_NAME;
  clSetSymbolFunctionValue(clBINDINGFORM_INITFORM,
                           clMakeClosure(0,
                                         clBindingformInitform,
                                         clNULL_HOOK));
  (void) clBINDINGFORM_INITFORM;
  clSetSymbolFunctionValue(clFUNCTION_NAME_KEY,
                           clMakeClosure(0,
                                         clFunctionNameKey,
                                         clNULL_HOOK));
  (void) clFUNCTION_NAME_KEY;
  { clObject *STARsymbol_listSTAR = clMakeBinding();
    clSetq(*STARsymbol_listSTAR, clList(clNIL, clEOA));
    { clObject L_1;
      clSetq(L_1,
             clMakeClosure(1,
                           clListArg,
                           &clEnvHook(clListArg),
                           &*STARsymbol_listSTAR));
      clSetSymbolFunctionValue(clLIST_ARG, L_1); }
    (void) clLIST_ARG; }
  cl_SETF_GlobalDeclaration(clT,
                            clstarCONSTANT_CHECK_HOOKstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarCONSTANT_CHECK_HOOKstar, clNIL);
  (void) clstarCONSTANT_CHECK_HOOKstar;
  clSetSymbolFunctionValue(clREDEFINE_CONSTANT,
                           clMakeClosure(0,
                                         clRedefineConstant,
                                         clNULL_HOOK));
  (void) clREDEFINE_CONSTANT;
  clSetSymbolFunctionValue(clGLOBAL_DECLARATION,
                           clMakeClosure(0,
                                         clGlobalDeclaration,
                                         clNULL_HOOK));
  (void) clGLOBAL_DECLARATION;
  clSetSymbolSetfFunctionValue(clGLOBAL_DECLARATION,
                               clMakeClosure(0,
                                             cl_SETF_GlobalDeclaration,
                                             clNULL_HOOK));
  (void) CONS_10;
  clUnwind(4); }
