/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Friday the twenty-second of May, 1998, 5:12:16 pm CDT. */
#include <eclipse.h>

clObject clAddIntegerInteger __P((clObject, clObject)),
  clAppend(clProto), clApply(clProto), clCar(clProto), clCdr(clProto),
  clCharpSimpleBaseString __P((clCharp)),
  clCheckForGlobalMacroEnv(clProto), clClassOf(clProto),
  clCons(clProto), clError(clProto), clExtraArgs(clProto),
  clFastFindSlot __P((clObject, clObject)), clFboundp(clProto),
  clFunctionNameKey(clProto),
  clGeIntegerInteger __P((clObject, clObject)), clGensym(clProto),
  cl_SETF_GlobalDeclaration(clProto), clIntern(clProto),
  clList(clProto), clListSTAR(clProto), clMakeKeyword(clProto),
  clMakeMacroFunction(clProto), clMakeSlots __P((clObject)),
  clMakeSymbols(clProto), clMapcar(clProto), clMissingArgs(clProto),
  clSetfFunctionNameP(clProto), clSignalProgramError(clProto),
  clSlotValue(clProto), clValues(clProto);

extern clObject clCOMPILER_MACRO, clLAMBDA, clSPECIAL, clSTRING,
  clstarMACROEXPAND_HOOKstar, clADD_INTEGER,
  clCHECK_FOR_GLOBAL_MACRO_ENV, clCOMPILER_MACRO_FUNCTION,
  clCONCATENATE, clCONCATENATE_NAMES, clCONTROL_ERROR, clENV,
  clFUNCALL, clFUNCTION, clFUNCTION_LAMBDA_EXPRESSION,
  clFUNCTION_SOURCE, clGE_INTEGER, clGENERATE_SETF_METHOD,
  clGLOBAL_VARIABLE, clLIST, clMACRO_FUNCTION,
  clMACRO_FUNCTION_CLASSOBJ, clMACRO_FUNCTION_FUNCTION,
  clMACRO_FUNCTION_P, clMAKE_MACRO_FUNCTION,
  clMAKE_SYMBOL_MACRO_FUNCTION, clNAME, clSETF, clSETF_COMPILER_MACRO,
  clSLOT_VALUE_USING_CLASS, clSTRING, clSYMBOL_MACRO,
  clSYMBOL_MACRO_FUNCTION, clTYPEP;

static clObject CONS_0, CONS_1, CONS_2, CONS_3, CONS_4, CONS_5, CONS_6,
  CONS_7, CONS_8, CONS_9, I_0, I_1, I_2, I_3, I_4, keyFORMAT_ARGUMENTS,
  keyFORMAT_CONTROL, STR_ARG__5, STR_FORMAT_ARGUMENTS__3,
  STR_FORMAT_CONTROL__1, STR_VALUE__4, STRn_0, STRn_2;

clObject clConcatenateNames clVdecl(_ap)
{ clObject names;
  { clBeginParse(_ap); clSetq(names, clVargs(_ap)); clEndParse(_ap); }
  { clObject L_0;
    { clObject L_2, L_0__R1;
      clSetq(L_0__R1, clSymbolFunctionValue(clCONCATENATE));
      { clObject L_0__R2;
        clSetq(L_0__R2, clSymbolFunctionValue(clSTRING));
        clSetq(L_2, clMapcar(L_0__R2, names, clEOA)); }
      clSetq(L_0, clApply(L_0__R1, clSTRING, L_2, clEOA)); }
    return(clIntern(L_0, clEOA)); } }

clObject clAddInteger clVdecl(_ap)
{ clObject x, y;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(y, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, x);
    clSetq(L_1, y);
    return(clValues1(clAddIntegerInteger(L_0, L_1))); } }

clObject clGeInteger clVdecl(_ap)
{ clObject x, y;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(y, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, x);
    clSetq(L_1, y);
    return(clValues1(clGeIntegerInteger(L_0, L_1))); } }

clObject clCheckForGlobalMacroEnv clVdecl(_ap)
{ clObject name, env;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(env))
    { clObject L_1;
      clSetq(L_1, name);
      return(clSignalProgramError(STRn_0, L_1, clEOA)); }
  else return(clValues1(clNIL)); }

clDeclareEnv(clMakeMacroFunction_IllegalMacroCall);
static clObject clMakeMacroFunction_IllegalMacroCall clVdecl(_ap)
{ clUseEnv(clMakeMacroFunction_IllegalMacroCall);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    return(clError(clCONTROL_ERROR, keyFORMAT_CONTROL, STRn_2,
                   keyFORMAT_ARGUMENTS,
                   clList(clEnv(0, *func), args, clEOA), clEOA)); } }

clObject clMakeMacroFunction clVdecl(_ap)
{ clObject mname, mfunc;
  { clBeginParse(_ap);
    clSetq(mname,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(mfunc,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject *func = clMakeBinding();
    clSetq(*func, clNIL);
    { clObject _IllegalMacroCall_;
      clSetq(_IllegalMacroCall_,
             clMakeClosure(1,
                           clMakeMacroFunction_IllegalMacroCall,
                           &clEnvHook(clMakeMacroFunction_IllegalMacroCall),
                           &*func));
      clSetq(*func, _IllegalMacroCall_);
      { clObject L_0;
        clSetq(L_0, *func);
        clSetTaggedInstanceClass(L_0, clMACRO_FUNCTION_CLASSOBJ); }
      { clObject L_0;
        clSetq(L_0, *func);
        clSetStandardInstanceSlots(L_0, clMakeSlots(I_4)); }
      if (clTrue((clTrue(clFboundp(clFUNCTION_LAMBDA_EXPRESSION,
                                   clEOA)) ?
                  clFboundp(clFUNCTION_SOURCE, clEOA) : clNIL)))
        { clObject L_values396, mlambda, menv;
          { clMultipleValueCall(MVC);
            clSetq(MVC, clSymbolFunctionValue(clLIST));
            { clObject L_0;
              clSetq(L_0, mfunc);
              clFuncallFunction(clSymbolFunctionValue(clFUNCTION_LAMBDA_EXPRESSION),
                                L_0,
                                clEOA); }
            clAccumulateValues(MVC);
            clSetq(L_values396, clMultipleValueFuncall(MVC)); }
          clSetq(mlambda, clCar(L_values396, clEOA));
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, L_values396);
              clSetq(L_0,
                     clSetq(L_values396, clCdr(L_0__R1, clEOA))); }
            clSetq(menv, clCar(L_0, clEOA)); }
          { clObject L_instance397, L_class398, L_function402,
            L_env401, L_lambda400, L_name399;
            clSetq(L_instance397, *func);
            clSetq(L_class398, clClassOf(L_instance397, clEOA));
            clSetq(L_function402,
                   clFastFindSlot(L_class398, clFUNCTION));
            clSetq(L_env401, clFastFindSlot(L_class398, clENV));
            clSetq(L_lambda400, clFastFindSlot(L_class398, clLAMBDA));
            clSetq(L_name399, clFastFindSlot(L_class398, clNAME));
            { clObject L_value403;
              clSetq(L_value403, mname);
              clFuncallFunction(clFdefinition(CONS_0, clEOA),
                                L_value403,
                                L_class398,
                                L_instance397,
                                L_name399,
                                clEOA); }
            { clObject L_value407;
              clSetq(L_value407, mfunc);
              clFuncallFunction(clFdefinition(CONS_0, clEOA),
                                L_value407,
                                L_class398,
                                L_instance397,
                                L_function402,
                                clEOA); }
            clFuncallFunction(clFdefinition(CONS_0, clEOA),
                              mlambda,
                              L_class398,
                              L_instance397,
                              L_lambda400,
                              clEOA);
            clFuncallFunction(clFdefinition(CONS_0, clEOA),
                              menv,
                              L_class398,
                              L_instance397,
                              L_env401,
                              clEOA); } }
      else
        { { clObject L_g419, L_g420;
            clSetq(L_g419, *func);
            clSetq(L_g420, mname);
            { clObject L_1, L_0;
              clSetq(L_0, clStandardInstanceSlots(L_g419));
              clSetq(L_1, clFixnumIndex(I_2));
              clSetSlot(L_0, L_1, L_g420); } }
          { clObject L_g421, L_g422;
            clSetq(L_g421, *func);
            clSetq(L_g422, mfunc);
            { clObject L_1, L_0;
              clSetq(L_0, clStandardInstanceSlots(L_g421));
              clSetq(L_1, clFixnumIndex(I_3));
              clSetSlot(L_0, L_1, L_g422); } }
          { clObject L_g423;
            clSetq(L_g423, *func);
            { clObject L_1, L_0;
              clSetq(L_0, clStandardInstanceSlots(L_g423));
              clSetq(L_1, clFixnumIndex(I_0));
              clSetSlot(L_0, L_1, clNIL); } }
          { clObject L_g425;
            clSetq(L_g425, *func);
            { clObject L_1, L_0;
              clSetq(L_0, clStandardInstanceSlots(L_g425));
              clSetq(L_1, clFixnumIndex(I_1));
              clSetSlot(L_0, L_1, clNIL); } } } }
    return(clValues1(*func)); } }

clObject clMacroFunctionP clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, x);
    return(clFuncallFunction(clSymbolFunctionValue(clTYPEP),
                             L_0,
                             clMACRO_FUNCTION_CLASSOBJ,
                             clEOA)); } }

clObject clMacroFunctionFunction clVdecl(_ap)
{ clObject name, macro_function;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(macro_function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, macro_function);
    return(clSlotValue(L_0, clFUNCTION, clEOA)); } }

clDeclareEnv(clMakeSymbolMacroFunction_Lambda);
static clObject clMakeSymbolMacroFunction_Lambda clVdecl(_ap)
{ clUseEnv(clMakeSymbolMacroFunction_Lambda);
  { clObject form, env;
    { clBeginParse(_ap);
      clSetq(form,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(env,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    return(clValues1(clEnv(0, *expansion))); } }

clObject clMakeSymbolMacroFunction clVdecl(_ap)
{ clObject *expansion = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(*expansion,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clMakeClosure(1,
                                 clMakeSymbolMacroFunction_Lambda,
                                 &clEnvHook(clMakeSymbolMacroFunction_Lambda),
                                 &*expansion))); }

clObject cl_SETF_MacroFunction clVdecl(_ap)
{ clObject expander, name, env;
  { clBeginParse(_ap);
    clSetq(expander,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(env, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, name);
    clSetq(L_1, env);
    clCheckForGlobalMacroEnv(L_0, L_1, clEOA); }
  { clObject L_1, L_0;
    clSetq(L_0, name);
    { clObject L_1__R1, L_0__R1;
      clSetq(L_0__R1, name);
      clSetq(L_1__R1, expander);
      clSetq(L_1, clMakeMacroFunction(L_0__R1, L_1__R1, clEOA)); }
    return(clValues1(clSetSymbolFunctionValue(L_0, L_1))); } }

clObject cl_SETF_SymbolMacroFunction clVdecl(_ap)
{ clObject expander, symbol, env;
  { clBeginParse(_ap);
    clSetq(expander,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(env, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, symbol);
    clSetq(L_1, env);
    clCheckForGlobalMacroEnv(L_0, L_1, clEOA); }
  { clObject L_2, L_0;
    clSetq(L_0, symbol);
    clSetq(L_2, expander);
    return(clValues1(clSystemPropertySetter(L_0,
                                            clSYMBOL_MACRO,
                                            L_2))); } }

clObject cl_SETF_CompilerMacroFunction clVdecl(_ap)
{ clObject def, function_name, env;
  { clBeginParse(_ap);
    clSetq(def,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(function_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(env, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, function_name);
    clSetq(L_1, env);
    clCheckForGlobalMacroEnv(L_0, L_1, clEOA); }
  { clObject setfp;
    { clObject L_0;
      clSetq(L_0, function_name);
      clSetq(setfp, clSetfFunctionNameP(L_0, clEOA)); }
    { clObject L_2, L_1, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, function_name);
        clSetq(L_0, clFunctionNameKey(L_0__R1, setfp, clEOA)); }
      clSetq(L_1,
             (clTrue(setfp) ? clSETF_COMPILER_MACRO :
              clCOMPILER_MACRO));
      clSetq(L_2, def);
      return(clValues1(clSystemPropertySetter(L_0, L_1, L_2))); } } }

clObject cl_SETF_SetfExpander clVdecl(_ap)
{ clObject expander, key;
  { clBeginParse(_ap);
    clSetq(expander,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, key);
    clSetq(L_1, expander);
    return(clValues1(clSetSetfExpander(L_0, L_1))); } }

clObject clGenerateSetfMethod clVdecl(_ap)
{ clObject form, inverse, setf_function_p;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(inverse,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(setf_function_p,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_form431, accessor, subforms;
    clSetq(L_form431, form);
    if (clTrue(L_form431))
      { clObject L_top432;
        clSetq(L_top432, clCar(L_form431, clEOA));
        { clObject L_0;
          clSetq(L_0, L_form431);
          clSetq(L_form431, clCdr(L_0, clEOA)); }
        clSetq(accessor, L_top432); }
    else clSetq(accessor, clMissingArgs(I_1, clEOA));
    clSetq(subforms, L_form431);
    { clObject new_var, vars;
      clSetq(new_var, clGensym(STR_VALUE__4, clEOA));
      clSetq(vars, clMakeSymbols(subforms, STR_ARG__5, clEOA));
      { clObject L_4, L_3, L_2;
        clSetq(L_2, clList(new_var, clEOA));
        if (clTrue(setf_function_p))
          { clObject L_0__R1;
            clSetq(L_0__R1, inverse);
            clSetq(L_3,
                   clAppend(L_0__R1,
                            clListSTAR(new_var, vars, clEOA),
                            clEOA)); }
        else
          { clObject L_0__R1;
            clSetq(L_0__R1, inverse);
            clSetq(L_3,
                   clAppend(L_0__R1,
                            vars,
                            clList(new_var, clEOA),
                            clEOA)); }
        { clObject L_0__R1;
          clSetq(L_0__R1, accessor);
          clSetq(L_4, clListSTAR(L_0__R1, vars, clEOA)); }
        return(clValues(vars, subforms, L_2, L_3, L_4, clEOA)); } } } }

void clInitMopInit __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(STRn_0,
         clCharpSimpleBaseString("Attempt to install ~a in non-null lexical environment."));
  clSetq(STR_FORMAT_CONTROL__1,
         clCharpSimpleBaseString("FORMAT-CONTROL"));
  clSetq(keyFORMAT_CONTROL,
         clMakeKeyword(STR_FORMAT_CONTROL__1, clEOA));
  clSetq(STRn_2,
         clCharpSimpleBaseString("Cannot funcall ~s on args: ~s."));
  clSetq(STR_FORMAT_ARGUMENTS__3,
         clCharpSimpleBaseString("FORMAT-ARGUMENTS"));
  clSetq(keyFORMAT_ARGUMENTS,
         clMakeKeyword(STR_FORMAT_ARGUMENTS__3, clEOA));
  clSetq(I_4, clIntFixnum(4));
  clSetq(CONS_1, clCons(clSLOT_VALUE_USING_CLASS, clNIL, clEOA));
  clSetq(CONS_0, clCons(clSETF, CONS_1, clEOA));
  clSetq(I_3, clIntFixnum(3));
  clSetq(I_0, clIntFixnum(0));
  clSetq(CONS_3, clCons(clMACRO_FUNCTION, clNIL, clEOA));
  clSetq(CONS_2, clCons(clSETF, CONS_3, clEOA));
  clSetq(CONS_5, clCons(clSYMBOL_MACRO_FUNCTION, clNIL, clEOA));
  clSetq(CONS_4, clCons(clSETF, CONS_5, clEOA));
  clSetq(CONS_7, clCons(clCOMPILER_MACRO_FUNCTION, clNIL, clEOA));
  clSetq(CONS_6, clCons(clSETF, CONS_7, clEOA));
  clSetq(CONS_9, clCons(clSETF_EXPANDER, clNIL, clEOA));
  clSetq(CONS_8, clCons(clSETF, CONS_9, clEOA));
  clSetq(STR_VALUE__4, clCharpSimpleBaseString("VALUE"));
  clSetq(STR_ARG__5, clCharpSimpleBaseString("ARG"));

  clSetSymbolFunctionValue(clCONCATENATE_NAMES,
                           clMakeClosure(0,
                                         clConcatenateNames,
                                         clNULL_HOOK));
  (void) clCONCATENATE_NAMES;
  clSetSymbolFunctionValue(clADD_INTEGER,
                           clMakeClosure(0,
                                         clAddInteger,
                                         clNULL_HOOK));
  (void) clADD_INTEGER;
  clSetSymbolFunctionValue(clGE_INTEGER,
                           clMakeClosure(0, clGeInteger, clNULL_HOOK));
  (void) clGE_INTEGER;
  clSetSymbolFunctionValue(clCHECK_FOR_GLOBAL_MACRO_ENV,
                           clMakeClosure(0,
                                         clCheckForGlobalMacroEnv,
                                         clNULL_HOOK));
  (void) clCHECK_FOR_GLOBAL_MACRO_ENV;
  clSetSymbolFunctionValue(clMAKE_MACRO_FUNCTION,
                           clMakeClosure(0,
                                         clMakeMacroFunction,
                                         clNULL_HOOK));
  (void) clMAKE_MACRO_FUNCTION;
  clSetSymbolFunctionValue(clMACRO_FUNCTION_P,
                           clMakeClosure(0,
                                         clMacroFunctionP,
                                         clNULL_HOOK));
  (void) clMACRO_FUNCTION_P;
  clSetSymbolFunctionValue(clMACRO_FUNCTION_FUNCTION,
                           clMakeClosure(0,
                                         clMacroFunctionFunction,
                                         clNULL_HOOK));
  (void) clMACRO_FUNCTION_FUNCTION;
  clSetSymbolFunctionValue(clMAKE_SYMBOL_MACRO_FUNCTION,
                           clMakeClosure(0,
                                         clMakeSymbolMacroFunction,
                                         clNULL_HOOK));
  (void) clMAKE_SYMBOL_MACRO_FUNCTION;
  clSetSymbolSetfFunctionValue(clMACRO_FUNCTION,
                               clMakeClosure(0,
                                             cl_SETF_MacroFunction,
                                             clNULL_HOOK));
  (void) CONS_2;
  clSetSymbolSetfFunctionValue(clSYMBOL_MACRO_FUNCTION,
                               clMakeClosure(0,
                                             cl_SETF_SymbolMacroFunction,
                                             clNULL_HOOK));
  (void) CONS_4;
  clSetSymbolSetfFunctionValue(clCOMPILER_MACRO_FUNCTION,
                               clMakeClosure(0,
                                             cl_SETF_CompilerMacroFunction,
                                             clNULL_HOOK));
  (void) CONS_6;
  clSetSymbolSetfFunctionValue(clSETF_EXPANDER,
                               clMakeClosure(0,
                                             cl_SETF_SetfExpander,
                                             clNULL_HOOK));
  (void) CONS_8;
  cl_SETF_GlobalDeclaration(clT,
                            clstarMACROEXPAND_HOOKstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarMACROEXPAND_HOOKstar,
                        clSymbolFunctionValue(clFUNCALL));
  (void) clstarMACROEXPAND_HOOKstar;
  clSetSymbolFunctionValue(clGENERATE_SETF_METHOD,
                           clMakeClosure(0,
                                         clGenerateSetfMethod,
                                         clNULL_HOOK));
  (void) clGENERATE_SETF_METHOD;
  clUnwind(4); }
