/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Friday the thirteenth of March, 1998, 4:41:51 pm CST. */
#include <eclipse.h>

clObject cl1PLUS_FUNC(clProto), clAccessorSpecializers(clProto),
  clAdjoin(clProto), clApply(clProto), clAssoc(clProto),
  clAtom(clProto), clBindingformKeyword(clProto),
  clBindingformName(clProto), clCadr(clProto),
  clCanonicalizeClass(clProto), clCar(clProto), clCddr(clProto),
  clCdr(clProto), clCerror(clProto),
  clCharpSimpleBaseString __P((clCharp)), clCheckKeys(clProto),
  clClassOf(clProto), clClassp(clProto),
  clComputeClassAllocatedSlot(clProto), clCongruentLambdaP(clProto),
  clCons(clProto), clConsp(clProto), clCopyList(clProto),
  clDelete(clProto), clEndp(clProto), clEnsureGenericFunction(clProto),
  clEnsureMethodUsingClass(clProto), clEq(clProto), clEql(clProto),
  clError(clProto), clExtraArgs(clProto),
  clFastFind __P((clObject, clObject)), clFboundp(clProto),
  clFind(clProto), clFindIf(clProto), clFindListEqEnd(clProto),
  cl_SETF_FindMethodCombinationType(clProto),
  clFindMethodCombinationType(clProto), clFindType(clProto),
  clFmakunbound(clProto), clFormatMethod(clProto), clFuncall(clProto),
  clGenericFunctionP(clProto), clGetMethod(clProto), clGetf(clProto),
  clIllegalChangeClass(clProto), clIllegalForwardReference(clProto),
  clInternInstance(clProto), clKeyArg(clProto),
  clLambdaListKeywordP(clProto), clList(clProto), clListSTAR(clProto),
  clListEq(clProto), clLocalSlotP(clProto),
  clMakeForwardReferencedClass(clProto), clMakeKeyword(clProto),
  clMapcar(clProto), clMissingArgs(clProto), clNconc(clProto),
  clNot(clProto), clNull(clProto), clPutf(clProto),
  clRemoveIf(clProto), clRest(clProto), clRplacd(clProto),
  clSecond(clProto),
  clSetFuncallableStandardInstanceFunction __P((clObject, clObject)),
  clSignalProgramError(clProto), clSlotBoundp(clProto),
  clSymbolp(clProto), clValues(clProto);

extern clObject clampersandALLOW_OTHER_KEYS, clampersandAUX,
  clampersandKEY, clampersandOPTIONAL, clampersandREST, clQUOTE,
  clABSTRACT_CLASS_P, clACCESSOR_SPECIALIZERS, clADD_ACCESSOR_METHODS,
  clADD_METHOD, clALLOCATE_INSTANCE, clBINDINGFORM_KEYWORD,
  clCANONICALIZE_CLASS, clCANONICALIZE_ENSURE_CLASS_ARGS,
  clCANONICALIZE_ENSURE_GENERIC_FUNCTION_ARGS,
  clCANONICALIZE_SPECIALIZER, clCHECK_CONGRUENT_LAMBDA,
  clCHECK_FOR_FORWARD_REFERENCES, clCLASS_DIRECT_SHARED_SLOTS,
  clCLASS_DIRECT_SUPERCLASSES, clCLASS_INSTANCES, clCLASS_NAME,
  clCLASS_PRECEDENCE_LIST, clCLASS_SLOTS, clCOLLECT_SUPERCLASSESstar,
  clCOMPUTE_CLASS_ALLOCATED_SLOT, clCOMPUTE_SLOT_LOCATIONS,
  clCONGRUENT_LAMBDA_P, clDIRECT_SLOT_DEFINITION_CLASS,
  clEFFECTIVE_SLOT_DEFINITION_CLASS, clENSURE_CLASS,
  clENSURE_CLASS_USING_CLASS, clENSURE_GENERIC_FUNCTION,
  clENSURE_GENERIC_FUNCTION_USING_CLASS, clENSURE_METHOD,
  clENSURE_METHOD_COMBINATION_TYPE, clENSURE_METHOD_USING_CLASS, clEQL,
  clEQL_SPECIALIZER, clEXTRACT_GENERIC_FUNCTION_LAMBDA_LIST,
  clEXTRACT_KEYWORDS, clEXTRACT_LAMBDA_LIST,
  clEXTRACT_SPECIALIZER_NAMES, clFIND_METHOD_COMBINATION_TYPE,
  clFORWARD_REFERENCED_CLASS, clFORWARD_REFERENCED_CLASS_CLASSOBJ,
  clFORWARD_REFERENCED_CLASS_P, clGENERIC_FUNCTION_CLASSOBJ,
  clGENERIC_FUNCTION_LAMBDA_LIST, clGENERIC_FUNCTION_METHOD_CLASS,
  clGENERIC_FUNCTION_METHODS, clGENERIC_FUNCTION_NAME,
  clGENERIC_FUNCTION_P, clGET_METHOD, clGETHASH,
  clILLEGAL_FORWARD_REFERENCE, clILLEGAL_SUPERCLASS,
  clINTERN_EQL_SPECIALIZER, clINTERN_INSTANCE,
  clINTERN_METHOD_COMBINATION, clLIST, clLOCAL_PRECEDENCE_ORDERING,
  clMAKE_DIRECT_SLOT_DEFINITION, clMAKE_EFFECTIVE_SLOT_DEFINITION,
  clMAKE_FORWARD_REFERENCED_CLASS, clMAKE_INSTANCE,
  clMAKE_LOAD_FORM_SAVING_SLOTS, clMEMBER, clMETHOD_COMBINATION_TYPE,
  clMETHOD_COMBINATION_TYPE_FUNCTION, clMETHOD_COMBINATION_TYPES,
  clMETHOD_LAMBDA_LIST, clMETHOD_QUALIFIERS, clMETHOD_SPECIALIZERS,
  clNAME, clNOT_FOUND, clREADER_METHOD_CLASS, clREINITIALIZE_INSTANCE,
  clREMOVE_ACCESSOR_METHODS, clREMOVE_METHOD, clREVERSE,
  clSEALED_CLASS_P, clSET_FUNCALLABLE_INSTANCE_FUNCTION, clSETF,
  clSLOT_BOUNDP_USING_CLASS, clSLOT_DEFINITION_ALLOCATION,
  clSLOT_DEFINITION_INITFUNCTION, clSLOT_DEFINITION_LOCATION,
  clSLOT_DEFINITION_NAME, clSLOT_DEFINITION_READERS,
  clSLOT_DEFINITION_WRITERS, clSLOT_VALUE_USING_CLASS,
  clSTANDARD_CHANGE_CLASS, clSTD_TIE_BREAKER_RULE, clT_CLASSOBJ,
  clTOPOLOGICAL_SORT, clTYPE_ERROR, clUNBOUND_FLAG,
  clUPDATE_INSTANCE_FOR_DIFFERENT_CLASS, clWITH_SLOTS,
  clWRITER_METHOD_CLASS;

static clObject CONS_0, CONS_1, CONS_10, CONS_11, CONS_12, CONS_13,
  CONS_14, CONS_15, CONS_16, CONS_17, CONS_18, CONS_19, CONS_2,
  CONS_20, CONS_21, CONS_3, CONS_4, CONS_5, CONS_6, CONS_7, CONS_8,
  CONS_9, I_0, I_1, I_2, I_3, I_4, keyCLASS, keyDATUM,
  keyDIRECT_SUPERCLASSES, keyENVIRONMENT, keyEXPECTED_TYPE,
  keyFUNCTION, keyGENERIC_FUNCTION_CLASS, keyINSTANCE, keyKEY,
  keyMETACLASS, keyMETHOD_CLASS, keyNAME, keyOBJECT, keyOPTIONS,
  keyREADERS, keySLOT_DEFINITION, keySLOT_NAMES, keySPECIALIZERS,
  keyTEST, keyWRITERS, STR_CLASS__14, STR_DATUM__8,
  STR_DIRECT_SUPERCLASSES__23, STR_ENVIRONMENT__21,
  STR_EXPECTED_TYPE__9, STR_FUNCTION__17, STR_INSTANCE__13,
  STR_KEY__12, STR_METACLASS__22, STR_METHOD_CLASS__25, STR_NAME__5,
  STR_OBJECT__16, STR_OPTIONS__18, STR_READERS__6,
  STR_SLOT_DEFINITION__10, STR_SLOT_NAMES__20, STR_SPECIALIZERS__11,
  STR_TEST__27, STR_WRITERS__7, STRn_0, STRn_1, STRn_15, STRn_19,
  STRn_2, STRn_24, STRn_26, STRn_3, STRn_4;

clObject clIllegalForwardReference clVdecl(_ap)
{ clObject metaobject, dependent;
  { clBeginParse(_ap);
    clSetq(metaobject,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(dependent, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2;
    clSetq(L_2, dependent);
    return(clSignalProgramError(STRn_0, metaobject, L_2, clEOA)); } }

clObject clIllegalSuperclass clVdecl(_ap)
{ clObject CL_class, super, name, namep;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(super,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(name, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    clSetq(namep, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_4, L_3, L_1;
    clSetq(L_1,
           clFuncallFunction(clSymbolFunctionValue(clABSTRACT_CLASS_P),
                             super,
                             clEOA));
    clSetq(L_3,
           clFuncallFunction(clSymbolFunctionValue(clABSTRACT_CLASS_P),
                             CL_class,
                             clEOA));
    clSetq(L_4,
           (clTrue(namep) ? name :
            (clTrue(clSlotBoundp(CL_class, clNAME, clEOA)) ?
             clFuncallFunction(clSymbolFunctionValue(clCLASS_NAME),
                               CL_class,
                               clEOA) :
             clNIL)));
    return(clError(STRn_1, L_1, super, L_3, L_4,
                   clClassOf(CL_class, clEOA), clEOA)); } }

clObject clCheckCongruentLambda clVdecl(_ap)
{ clObject gf, method;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(method,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1,
               clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_LAMBDA_LIST),
                                 gf,
                                 clEOA));
        clSetq(L_0,
               clCongruentLambdaP(L_0__R1,
                                  clFuncallFunction(clSymbolFunctionValue(clMETHOD_LAMBDA_LIST),
                                                    method,
                                                    clEOA),
                                  clEOA)); }
      clSetq(L_test, clNot(L_0, clEOA)); }
    if (clTrue(L_test))
      { clObject L_2, L_1;
        clSetq(L_1,
               clFormatMethod(clNIL,
                              method,
                              clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_NAME),
                                                gf,
                                                clEOA),
                              clEOA));
        clSetq(L_2,
               clFuncallFunction(clSymbolFunctionValue(clMETHOD_LAMBDA_LIST),
                                 method,
                                 clEOA));
        return(clSignalProgramError(STRn_2,
                                    L_1,
                                    L_2,
                                    clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_LAMBDA_LIST),
                                                      gf,
                                                      clEOA),
                                    clEOA)); }
    else return(clValues1(clNIL)); } }

clObject clCheckForForwardReferences clVdecl(_ap)
{ clObject CL_class, cpl;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(cpl,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject forward;
    clSetq(forward,
           clFindIf(clFORWARD_REFERENCED_CLASS_P, cpl, clEOA));
    if (clTrue(forward))
      return(clIllegalForwardReference(forward, CL_class, clEOA));
    else return(clValues1(clNIL)); } }

clObject clForwardReferencedClassP clVdecl(_ap)
{ clObject CL_class;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clClassp(CL_class, clFORWARD_REFERENCED_CLASS_CLASSOBJ,
                  clEOA)); }

clObject clGenericFunctionP clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clClassp(x, clGENERIC_FUNCTION_CLASSOBJ, clEOA)); }

clObject clCongruentLambdaP clVdecl(_ap)
{ clObject gf, method;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(method,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject gf__R1, m;
    clSetq(gf__R1, gf);
    clSetq(m, method);
    clLabel(l_ITERATE395);
    if (clTrue(clEndp(gf__R1, clEOA)))
      { clObject L_g396;
        clSetq(L_g396, clNull(m, clEOA));
        if (clTrue(L_g396))
          return(clValues1(L_g396));
        else
          { clObject L_0;
            clSetq(L_0, clCar(m, clEOA));
            return(clEq(L_0, clampersandAUX, clEOA)); } }
    if (clTrue(clNot(m, clEOA))) return(clValues1(clNIL));
    { clObject L_key397;
      clSetq(L_key397, clCar(gf__R1, clEOA));
      if (_clEq(L_key397, clampersandOPTIONAL))
        { clObject L_test__R1;
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, clCar(m, clEOA));
              clSetq(L_0, clEq(L_0__R1, clampersandOPTIONAL, clEOA)); }
            clSetq(L_test__R1, clNot(L_0, clEOA)); }
          if (clTrue(L_test__R1)) return(clValues1(clNIL)); }
      else if (clTrue((_clEq(L_key397, clampersandREST) ?
                       CONS_0 :
                       (_clEq(L_key397, clampersandKEY) ?
                        CONS_1 :
                        clNIL))))
        { clObject L_key399;
          clSetq(L_key399, clCar(m, clEOA));
          if (clTrue((_clEq(L_key399, clampersandREST) ?
                      CONS_0 :
                      (_clEq(L_key399, clampersandKEY) ?
                       CONS_1 :
                       clNIL))))
            { clObject m_keys, m_end;
              { clObject L_sub401;
                clSetq(L_sub401, m);
                clLabel(l_ITERATE404);
                if (clTrue(clEndp(L_sub401, clEOA)))
                  { clSetq(m_keys, clNIL); clLocalReturn(NIL); }
                if (_clEq(clampersandKEY, clCar(L_sub401, clEOA)))
                  { clSetq(m_keys, L_sub401);
                    clLocalReturn(l_MEMBER403); }
                { clObject L_value405;
                  clSetq(L_value405, clCdr(L_sub401, clEOA));
                  clSetq(L_sub401, L_value405); }
                goto l_ITERATE404; }
              clBlockEnd(NIL);
              clBlockEnd(l_MEMBER403);
              { clObject i, parameter, L_g0;
                clSetq(i, I_0);
                clSetq(parameter, clNIL);
                clSetq(L_g0, m);
                if (clTrue(clEndp(L_g0, clEOA))) goto END_LOOP;
                clSetq(parameter, clCar(L_g0, clEOA));
                clLabel(NEXT_LOOP);
                { clObject L_0;
                  clSetq(L_0, L_g0);
                  clSetq(L_g0, clCdr(L_0, clEOA)); }
                { clObject L_test__R3;
                  { clObject L_0;
                    clSetq(L_0, parameter);
                    clSetq(L_test__R3,
                           clEq(L_0, clampersandAUX, clEOA)); }
                  if (clTrue(L_test__R3))
                    { clSetq(m_end, i); clLocalReturn(NIL__r1); } }
                { clObject L_test__R3;
                  { clObject L_0;
                    clSetq(L_0, L_g0);
                    clSetq(L_test__R3, clEndp(L_0, clEOA)); }
                  if (clTrue(L_test__R3)) goto END_LOOP; }
                { clObject L_first_val406;
                  clSetq(L_first_val406, cl1PLUS_FUNC(i, clEOA));
                  { clObject L_0;
                    clSetq(L_0, L_g0);
                    clSetq(parameter, clCar(L_0, clEOA)); }
                  clSetq(i, L_first_val406); }
                goto NEXT_LOOP;
                clLabel(END_LOOP);
                clSetq(m_end, clNIL);
                clBlockEnd(NIL__r1); }
              { clObject L_test__R3;
                { clObject L_2, L_1;
                  clSetq(L_1, m_keys);
                  clSetq(L_2, m_end);
                  clSetq(L_test__R3,
                         clFindListEqEnd(clampersandALLOW_OTHER_KEYS,
                                         L_1,
                                         L_2,
                                         clEOA)); }
                if (clTrue(L_test__R3))
                  return(clValues1(clT));
                else
                  { clObject L_test__R4;
                    { clObject L_test__R5;
                      { clObject L_0;
                        clSetq(L_0, m_keys);
                        clSetq(L_test__R5, clNull(L_0, clEOA)); }
                      if (clTrue(L_test__R5))
                      { clObject L_0;
                        clSetq(L_0, clCar(m, clEOA));
                        clSetq(L_test__R4,
                               clEq(L_0, clampersandREST, clEOA)); }
                      else
                      clSetq(L_test__R4, clNIL); }
                    if (clTrue(L_test__R4))
                      return(clValues1(clT));
                    else
                      { clObject L_sublist407, gfk;
                        { clObject L_0;
                          { clObject L_sub409;
                            clSetq(L_sub409, gf__R1);
                            clLabel(l_ITERATE412);
                            if (clTrue(clEndp(L_sub409, clEOA)))
                            { clSetq(L_0, clNIL);
                              clLocalReturn(NIL__r2); }
                            if (_clEq(clampersandKEY, clCar(L_sub409,
                                                            clEOA)))
                            { clSetq(L_0, L_sub409);
                              clLocalReturn(l_MEMBER411); }
                            { clObject L_value413;
                              clSetq(L_value413,
                                     clCdr(L_sub409, clEOA));
                              clSetq(L_sub409, L_value413); }
                            goto l_ITERATE412; }
                          clBlockEnd(NIL__r2);
                          clBlockEnd(l_MEMBER411);
                          clSetq(L_sublist407, clRest(L_0, clEOA)); }
                        clSetq(gfk, clCar(L_sublist407, clEOA));
                        clLabel(l_ITERATE408);
                        if (clTrue(clEndp(L_sublist407, clEOA)))
                        return(clValues1(clT));
                        if (_clEq(gfk, clampersandALLOW_OTHER_KEYS))
                        return(clValues1(clT));
                        { clObject L_test__R5;
                          { clObject L_0;
                            { clObject L_2, L_1, L_0__R1;
                              clSetq(L_0__R1,
                                     clBindingformKeyword(gfk, clEOA));
                              clSetq(L_1, m_keys);
                              clSetq(L_2, m_end);
                              clSetq(L_0,
                                     clFindListEqEnd(L_0__R1,
                                                     L_1,
                                                     L_2,
                                                     clSymbolFunctionValue(clBINDINGFORM_KEYWORD),
                                                     clEOA)); }
                            clSetq(L_test__R5, clNot(L_0, clEOA)); }
                          if (clTrue(L_test__R5))
                          return(clValues1(clNIL)); }
                        { clObject L_0;
                          clSetq(L_0, L_sublist407);
                          clSetq(L_sublist407, clCdr(L_0, clEOA)); }
                        { clObject L_0;
                          clSetq(L_0, L_sublist407);
                          clSetq(gfk, clCar(L_0, clEOA)); }
                        goto l_ITERATE408; } } } }
          else return(clValues1(clNIL)); }
      else if (_clEq(L_key397, clampersandAUX))
        return(clValues1(clT)); }
    { clObject L_value414, L_value415;
      clSetq(L_value414, clCdr(gf__R1, clEOA));
      clSetq(L_value415, clCdr(m, clEOA));
      clSetq(gf__R1, L_value414);
      clSetq(m, L_value415); }
    goto l_ITERATE395; } }

clObject clEnsureClass clVdecl(_ap)
{ clObject name, keys;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(keys, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, clSymbolFunctionValue(clENSURE_CLASS_USING_CLASS));
    clSetq(L_1, clFindType(name, clNIL, clEOA));
    return(clApply(L_0, L_1, name, keys, clEOA)); } }

clObject clEnsureGenericFunction clVdecl(_ap)
{ clObject function_name, keys;
  { clBeginParse(_ap);
    clSetq(function_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(keys, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0,
           clSymbolFunctionValue(clENSURE_GENERIC_FUNCTION_USING_CLASS));
    if (clTrue(clFboundp(function_name, clEOA)))
      { clObject function;
        clSetq(function, clFdefinition(function_name, clEOA));
        clSetq(L_1,
               (clTrue(clGenericFunctionP(function, clEOA)) ?
                function :
                (clCerror(STRn_3,
                          STRn_4,
                          function_name,
                          function,
                          clEOA),
                 clFmakunbound(function_name, clEOA), clNIL))); }
    else clSetq(L_1, clNIL);
    return(clApply(L_0, L_1, function_name, keys, clEOA)); } }

clObject clEnsureMethodUsingClass clVdecl(_ap)
{ clObject gf, requested_method_class, keys;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(requested_method_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(keys,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject method;
    { clObject L_0;
      clSetq(L_0, clSymbolFunctionValue(clMAKE_INSTANCE));
      clSetq(method,
             clApply(L_0, requested_method_class, keys, clEOA)); }
    clFuncallFunction(clSymbolFunctionValue(clADD_METHOD),
                      gf,
                      method,
                      clEOA);
    return(clValues1(method)); } }

clObject clEnsureMethod clVdecl(_ap)
{ clObject gf, keys;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(keys, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_1;
    clSetq(L_1,
           clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_METHOD_CLASS),
                             gf,
                             clEOA));
    return(clEnsureMethodUsingClass(gf, L_1, keys, clEOA)); } }

clObject clEnsureMethodCombinationType clVdecl(_ap)
{ clObject name, keys;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(keys, clVargs(_ap));
    clEndParse(_ap); }
  { clObject current;
    clSetq(current, clFindMethodCombinationType(name, clNIL, clEOA));
    if (clTrue(current))
      { clObject L_0;
        clSetq(L_0, clSymbolFunctionValue(clREINITIALIZE_INSTANCE));
        clApply(L_0, current, keyNAME, name, keys, clEOA); }
    else
      { clObject L_value416;
        { clObject L_0;
          clSetq(L_0, clSymbolFunctionValue(clMAKE_INSTANCE));
          clSetq(L_value416,
                 clApply(L_0,
                         clMETHOD_COMBINATION_TYPE,
                         keyNAME,
                         name,
                         keys,
                         clEOA)); }
        cl_SETF_FindMethodCombinationType(L_value416, name, clEOA); } }
  return(clValues1(name)); }

clObject clMakeDirectSlotDefinition clVdecl(_ap)
{ clObject CL_class, spec;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(spec,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, clSymbolFunctionValue(clMAKE_INSTANCE));
    { clObject L_0__R1;
      clSetq(L_0__R1,
             clSymbolFunctionValue(clDIRECT_SLOT_DEFINITION_CLASS));
      clSetq(L_1, clApply(L_0__R1, CL_class, spec, clEOA)); }
    return(clApply(L_0, L_1, spec, clEOA)); } }

clObject clMakeEffectiveSlotDefinition clVdecl(_ap)
{ clObject CL_class, spec;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(spec,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    clSetq(L_0, clSymbolFunctionValue(clMAKE_INSTANCE));
    { clObject L_0__R1;
      clSetq(L_0__R1,
             clSymbolFunctionValue(clEFFECTIVE_SLOT_DEFINITION_CLASS));
      clSetq(L_1, clApply(L_0__R1, CL_class, spec, clEOA)); }
    return(clApply(L_0, L_1, spec, clEOA)); } }

clObject clAccessorSpecializers clVdecl(_ap)
{ clObject CL_class, key;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (_clEq(key, keyREADERS))
    return(clList(CL_class, clEOA));
  else if (_clEq(key, keyWRITERS))
    { clObject L_0;
      clSetq(L_0, clFindType(clT, clEOA));
      return(clList(L_0, CL_class, clEOA)); }
  else
    return(clError(clTYPE_ERROR, keyDATUM, key, keyEXPECTED_TYPE,
                   CONS_2, clEOA)); }

clObject clAddAccessorMethods clVdecl(_ap)
{ clObject CL_class, slot, key, accessors;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(accessors,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(accessors))
    { clObject class_function, plist;
      clSetq(class_function,
             (_clEq(key, keyWRITERS) ?
              clSymbolFunctionValue(clWRITER_METHOD_CLASS) :
              (_clEq(key, keyREADERS) ?
               clSymbolFunctionValue(clREADER_METHOD_CLASS) :
               clError(clTYPE_ERROR,
                       keyDATUM,
                       key,
                       keyEXPECTED_TYPE,
                       CONS_5,
                       clEOA))));
      clSetq(plist,
             clList(keySLOT_DEFINITION, slot, keySPECIALIZERS,
                    clAccessorSpecializers(CL_class, key, clEOA),
                    clEOA));
      { clObject L_sublist422, accessor;
        clSetq(L_sublist422, accessors);
        clSetq(accessor, clCar(L_sublist422, clEOA));
        clLabel(l_ITERATE423);
        if (clTrue(clEndp(L_sublist422, clEOA)))
          return(clValues1(clNIL));
        { clObject L_1, L_0;
          clSetq(L_0, clEnsureGenericFunction(accessor, clEOA));
          { clObject L_0__R1;
            clSetq(L_0__R1, class_function);
            clSetq(L_1,
                   clApply(L_0__R1, CL_class, slot, plist, clEOA)); }
          clEnsureMethodUsingClass(L_0, L_1, plist, clEOA); }
        { clObject L_0;
          clSetq(L_0, L_sublist422);
          clSetq(L_sublist422, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist422);
          clSetq(accessor, clCar(L_0, clEOA)); }
        goto l_ITERATE423; } }
  else return(clValues1(clNIL)); }

clObject clRemoveAccessorMethods clVdecl(_ap)
{ clObject CL_class, slot, key;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject existing_accessor, L_g1;
    clSetq(existing_accessor, clNIL);
    clSetq(L_g1,
           (_clEq(key, keyREADERS) ?
            clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_READERS),
                              slot,
                              clEOA) :
            (_clEq(key, keyWRITERS) ?
             clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_WRITERS),
                               slot,
                               clEOA) :
             clError(clTYPE_ERROR, keyDATUM, key, keyEXPECTED_TYPE,
                     CONS_2, clEOA))));
    { clObject specializers;
      clSetq(specializers,
             clAccessorSpecializers(CL_class, key, clEOA));
      clLabel(NEXT_LOOP);
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, L_g1);
          clSetq(L_test, clEndp(L_0, clEOA)); }
        if (clTrue(L_test)) goto END_LOOP; }
      { clObject L_0;
        clSetq(L_0, L_g1);
        clSetq(existing_accessor, clCar(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_g1);
        clSetq(L_g1, clCdr(L_0, clEOA)); }
      { clObject gf;
        { clObject L_0;
          clSetq(L_0, existing_accessor);
          clSetq(gf, clFdefinition(L_0, clEOA)); }
        clFuncallFunction(clSymbolFunctionValue(clREMOVE_METHOD),
                          gf,
                          clGetMethod(gf,
                                      clNIL,
                                      specializers,
                                      clT,
                                      clEOA),
                          clEOA); }
      goto NEXT_LOOP;
      clLabel(END_LOOP);
      return(clValues1(clNIL)); } } }

clObject clStandardChangeClass clVdecl(_ap)
{ clObject instance, new_class, initargs;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(new_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(initargs,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject copy, old_class;
    clSetq(copy,
           clFuncallFunction(clSymbolFunctionValue(clALLOCATE_INSTANCE),
                             new_class,
                             clEOA));
    clSetq(old_class, clClassOf(instance, clEOA));
    if (clTrue(clFuncallFunction(clSymbolFunctionValue(clSEALED_CLASS_P),
                                 old_class,
                                 clEOA)))
      clIllegalChangeClass(instance, new_class, clEOA);
    { clObject new_slot, L_g2;
      clSetq(new_slot, clNIL);
      clSetq(L_g2,
             clFuncallFunction(clSymbolFunctionValue(clCLASS_SLOTS),
                               new_class,
                               clEOA));
      { clObject old_slots;
        clSetq(old_slots,
               clFuncallFunction(clSymbolFunctionValue(clCLASS_SLOTS),
                                 old_class,
                                 clEOA));
        clLabel(NEXT_LOOP);
        if (clTrue(clEndp(L_g2, clEOA))) goto END_LOOP;
        clSetq(new_slot, clCar(L_g2, clEOA));
        { clObject L_0;
          clSetq(L_0, L_g2);
          clSetq(L_g2, clCdr(L_0, clEOA)); }
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, new_slot);
            clSetq(L_test, clLocalSlotP(L_0, clEOA)); }
          if (clTrue(L_test))
            { clObject slot_name, old_slot;
              { clObject L_0;
                clSetq(L_0, new_slot);
                clSetq(slot_name,
                       clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                                         L_0,
                                         clEOA)); }
              clSetq(old_slot,
                     clFind(slot_name,
                            old_slots,
                            keyKEY,
                            clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                            clEOA));
              if (clTrue((clTrue(old_slot) ?
                          clFuncallFunction(clSymbolFunctionValue(clSLOT_BOUNDP_USING_CLASS),
                                            old_class,
                                            instance,
                                            old_slot,
                                            clEOA) :
                          clNIL)))
                { clObject L_arg429, L_value426;
                  clSetq(L_arg429, new_slot);
                  clSetq(L_value426,
                         clFuncallFunction(clSymbolFunctionValue(clSLOT_VALUE_USING_CLASS),
                                           old_class,
                                           instance,
                                           old_slot,
                                           clEOA));
                  clFuncallFunction(clFdefinition(CONS_8, clEOA),
                                    L_value426,
                                    new_class,
                                    copy,
                                    L_arg429,
                                    clEOA); } } }
        goto NEXT_LOOP;
        clLabel(END_LOOP); } }
    { clObject temp;
      clSetq(temp, clTaggedInstanceClass(copy));
      clSetTaggedInstanceClass(copy, clTaggedInstanceClass(instance));
      clSetTaggedInstanceClass(instance, temp); }
    { clObject temp;
      clSetq(temp, clTaggedInstanceWrapper(copy));
      clSetTaggedInstanceWrapper(copy,
                                 clTaggedInstanceWrapper(instance));
      clSetTaggedInstanceWrapper(instance, temp); }
    { clObject temp;
      clSetq(temp, clStandardInstanceSlots(copy));
      clSetStandardInstanceSlots(copy,
                                 clStandardInstanceSlots(instance));
      clSetStandardInstanceSlots(instance, temp); }
    { clObject L_0;
      clSetq(L_0,
             clSymbolFunctionValue(clUPDATE_INSTANCE_FOR_DIFFERENT_CLASS));
      clApply(L_0, copy, instance, initargs, clEOA); }
    return(clValues1(instance)); } }

clObject clComputeClassAllocatedSlot clVdecl(_ap)
{ clObject CL_class, slot;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject name;
    clSetq(name,
           clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                             slot,
                             clEOA));
    { clObject L_g445;
      { clObject super, L_g3;
        clSetq(super, clNIL);
        clSetq(L_g3,
               clFuncallFunction(clSymbolFunctionValue(clCLASS_PRECEDENCE_LIST),
                                 CL_class,
                                 clEOA));
        { clObject L_g4;
          clSetq(L_g4, clNIL);
          clLabel(NEXT_LOOP);
          if (clTrue(clEndp(L_g3, clEOA))) goto END_LOOP;
          clSetq(super, clCar(L_g3, clEOA));
          { clObject L_0;
            clSetq(L_0, L_g3);
            clSetq(L_g3, clCdr(L_0, clEOA)); }
          { clObject L_test;
            { clObject L_test__R1;
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, super);
                  clSetq(L_0, clEq(L_0__R1, clT_CLASSOBJ, clEOA)); }
                clSetq(L_test__R1, clNot(L_0, clEOA)); }
              if (clTrue(L_test__R1))
                { clObject L_1;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, super);
                    clSetq(L_1,
                           clFuncallFunction(clSymbolFunctionValue(clCLASS_DIRECT_SHARED_SLOTS),
                                             L_0__R1,
                                             clEOA)); }
                  clSetq(L_test,
                         clSetq(L_g4, clAssoc(name, L_1, clEOA))); }
              else clSetq(L_test, clSetq(L_g4, clNIL)); }
            if (clTrue(L_test))
              { clSetq(L_g445, L_g4); clLocalReturn(NIL); } }
          goto NEXT_LOOP;
          clLabel(END_LOOP);
          clSetq(L_g445, clNIL);
          clBlockEnd(NIL); } }
      if (clTrue(L_g445))
        return(clValues1(L_g445));
      else
        { clObject func, CL_new;
          clSetq(func,
                 clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_INITFUNCTION),
                                   slot,
                                   clEOA));
          { clObject L_1;
            clSetq(L_1,
                   (clTrue(func) ? clFuncall(func, clEOA) :
                    clSymbolValueValue(clUNBOUND_FLAG)));
            clSetq(CL_new, clCons(name, L_1, clEOA)); }
          { clObject L_value446;
            clSetq(L_value446,
                   clCons(CL_new,
                          clFuncallFunction(clSymbolFunctionValue(clCLASS_DIRECT_SHARED_SLOTS),
                                            CL_class,
                                            clEOA),
                          clEOA));
            clFuncallFunction(clFdefinition(CONS_10, clEOA),
                              L_value446,
                              CL_class,
                              clEOA); }
          return(clValues1(CL_new)); } } } }

clObject clComputeSlotLocations clVdecl(_ap)
{ clObject CL_class, effective_slot_definitions;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(effective_slot_definitions,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject definition, L_g5;
    clSetq(definition, clNIL);
    clSetq(L_g5, effective_slot_definitions);
    { clObject position;
      clSetq(position, I_0);
      { clObject location;
        clSetq(location, clNIL);
        clLabel(NEXT_LOOP);
        if (clTrue(clEndp(L_g5, clEOA))) goto END_LOOP;
        clSetq(definition, clCar(L_g5, clEOA));
        { clObject L_0;
          clSetq(L_0, L_g5);
          clSetq(L_g5, clCdr(L_0, clEOA)); }
        { clObject L_key448;
          { clObject L_0;
            clSetq(L_0, definition);
            clSetq(L_key448,
                   clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_ALLOCATION),
                                     L_0,
                                     clEOA)); }
          if (_clEq(L_key448, keyINSTANCE))
            { clObject pos;
              clSetq(pos, position);
              clSetq(position, cl1PLUS_FUNC(pos, clEOA));
              clSetq(location, pos); }
          else if (_clEq(L_key448, keyCLASS))
            { clObject L_1;
              clSetq(L_1, definition);
              clSetq(location,
                     clComputeClassAllocatedSlot(CL_class,
                                                 L_1,
                                                 clEOA)); }
          else clSetq(location, clNIL); }
        if (clTrue(location))
          { clObject L_arg450, L_value449;
            clSetq(L_arg450, definition);
            clSetq(L_value449, location);
            clFuncallFunction(clFdefinition(CONS_12, clEOA),
                              L_value449,
                              L_arg450,
                              clEOA); }
        goto NEXT_LOOP;
        clLabel(END_LOOP); } } }
  return(clValues1(effective_slot_definitions)); }

clObject clSetFuncallableInstanceFunction clVdecl(_ap)
{ clObject funcallable_instance, function;
  { clBeginParse(_ap);
    clSetq(funcallable_instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clSetFuncallableStandardInstanceFunction(funcallable_instance,
                                                            function))); }

clObject clInternInstance clVdecl(_ap)
{ clObject L_ap, CL_class, keys, key, keyp;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, keys);
    clSetq(keyp, L_ap);
    clEndParse(_ap); }
  { clObject CL_class__R1, table;
    clSetq(CL_class__R1, clCanonicalizeClass(CL_class, clT, clEOA));
    clSetq(table,
           clFuncallFunction(clSymbolFunctionValue(clCLASS_INSTANCES),
                             CL_class__R1,
                             clEOA));
    { clObject L_g451;
      { clObject L_0;
        clSetq(L_0, key);
        clSetq(L_g451,
               clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                                 L_0,
                                 table,
                                 clEOA)); }
      if (clTrue(L_g451))
        return(clValues1(L_g451));
      else
        { if (clTrue(keyp))
            { { clObject L_0;
                clSetq(L_0, keys);
                clSetq(keys, clCopyList(L_0, clEOA)); }
              { clObject L_value452;
                clSetq(L_value452, keys);
                { clObject L_local454, L_local455;
                  clSetq(L_local454, L_value452);
                  clSetq(L_local455, clNIL);
                  clLabel(l_ITERATE456);
                  if (clTrue(clAtom(L_local454, clEOA)))
                    clLocalReturn(NIL);
                  if (clTrue(clAtom(clCdr(L_local454, clEOA), clEOA)))
                    clError(STRn_15, clEOA);
                  else
                    { clObject L_test__R3;
                      { clObject L_0;
                        clSetq(L_0, clCar(L_local454, clEOA));
                        clSetq(L_test__R3, clEq(L_0, keyKEY, clEOA)); }
                      if (clTrue(L_test__R3))
                      if (clTrue(L_local455))
                      { { clObject L_0;
                          clSetq(L_0, clCdr(L_local455, clEOA));
                          clRplacd(L_0,
                                   clCddr(L_local454, clEOA),
                                   clEOA); }
                        (void) clT;
                        clLocalReturn(NIL); }
                      else
                      { { clObject L_0;
                          clSetq(L_0, L_value452);
                          clSetq(L_value452, clCddr(L_0, clEOA)); }
                        clSetq(keys, L_value452);
                        (void) clT;
                        clLocalReturn(NIL); } }
                  { clObject L_value457, L_value458;
                    clSetq(L_value457, clCddr(L_local454, clEOA));
                    clSetq(L_value458, L_local454);
                    clSetq(L_local454, L_value457);
                    clSetq(L_local455, L_value458); }
                  goto l_ITERATE456; }
                clBlockEnd(NIL); } }
          { clObject L_arg460, L_value459;
            clSetq(L_arg460, key);
            { clObject L_2, L_0;
              clSetq(L_0, clSymbolFunctionValue(clMAKE_INSTANCE));
              clSetq(L_2, keys);
              clSetq(L_value459,
                     clApply(L_0, CL_class__R1, L_2, clEOA)); }
            return(clFuncallFunction(clFdefinition(CONS_14, clEOA),
                                     L_value459,
                                     L_arg460,
                                     table,
                                     clEOA)); } } } } }

clObject clInternEqlSpecializer clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_4;
    clSetq(L_4, clList(clEQL, object, clEOA));
    return(clInternInstance(clEQL_SPECIALIZER,
                            keyOBJECT,
                            object,
                            keyNAME,
                            L_4,
                            keyKEY,
                            object,
                            clEOA)); } }

clObject clInternMethodCombination clVdecl(_ap)
{ clObject args;
  { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
  { clObject name, CL_class, table;
    clSetq(name, clCar(args, clEOA));
    clSetq(CL_class, clFindMethodCombinationType(name, clEOA));
    clSetq(table,
           clFuncallFunction(clSymbolFunctionValue(clCLASS_INSTANCES),
                             CL_class,
                             clEOA));
    { clObject L_g462;
      clSetq(L_g462,
             clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                               args,
                               table,
                               clEOA));
      if (clTrue(L_g462))
        return(clValues1(L_g462));
      else
        { clObject options;
          clSetq(options, clRest(args, clEOA));
          { clObject L_value463;
            { clObject L_2;
              { clObject L_0__R1;
                clSetq(L_0__R1,
                       clFuncallFunction(clSymbolFunctionValue(clMETHOD_COMBINATION_TYPE_FUNCTION),
                                         CL_class,
                                         clEOA));
                clSetq(L_2, clApply(L_0__R1, options, clEOA)); }
              clSetq(L_value463,
                     clFuncallFunction(clSymbolFunctionValue(clMAKE_INSTANCE),
                                       CL_class,
                                       keyFUNCTION,
                                       L_2,
                                       keyOPTIONS,
                                       options,
                                       clEOA)); }
            return(clFuncallFunction(clFdefinition(CONS_14, clEOA),
                                     L_value463,
                                     args,
                                     table,
                                     clEOA)); } } } } }

clObject clFindMethodCombinationType clVdecl(_ap)
{ clObject name, errorp;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clT));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g466;
    clSetq(L_g466,
           clSystemProperty(name, clMETHOD_COMBINATION_TYPES, clNIL));
    if (clTrue(L_g466))
      return(clValues1(L_g466));
    else if (clTrue(errorp))
      return(clIllegalForwardReference(name, clEOA));
    else return(clValues1(clNIL)); } }

clObject cl_SETF_FindMethodCombinationType clVdecl(_ap)
{ clObject CL_class, name, errorp;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clSystemPropertySetter(name,
                                          clMETHOD_COMBINATION_TYPES,
                                          CL_class))); }

clObject clExtractSpecializerNames clVdecl(_ap)
{ clObject specialized_lambda_list;
  { clBeginParse(_ap);
    clSetq(specialized_lambda_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject parameter, L_g6;
    clSetq(parameter, clNIL);
    clSetq(L_g6, specialized_lambda_list);
    { clObject L_g7, L_g8, required;
      clSetq(L_g7, clList(clNIL, clEOA));
      clSetq(L_g8, L_g7);
      clSetq(required, clNIL);
      clLabel(NEXT_LOOP);
      if (clTrue(clEndp(L_g6, clEOA))) goto END_LOOP;
      clSetq(parameter, clCar(L_g6, clEOA));
      { clObject L_0;
        clSetq(L_0, L_g6);
        clSetq(L_g6, clCdr(L_0, clEOA)); }
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, parameter);
          clSetq(L_test, clLambdaListKeywordP(L_0, clEOA)); }
        if (clTrue(L_test)) return(clValues1(required)); }
      { clObject L_1, L_0;
        clSetq(L_0, L_g8);
        { clObject L_0__R1;
          { clObject L_test;
            { clObject L_0__R2;
              clSetq(L_0__R2, parameter);
              clSetq(L_test, clConsp(L_0__R2, clEOA)); }
            if (clTrue(L_test))
              { clObject L_0__R2;
                clSetq(L_0__R2, parameter);
                clSetq(L_0__R1, clSecond(L_0__R2, clEOA)); }
            else clSetq(L_0__R1, clT); }
          clSetq(L_1, clSetq(L_g8, clList(L_0__R1, clEOA))); }
        clRplacd(L_0, L_1, clEOA); }
      clSetq(required, clCdr(L_g7, clEOA));
      goto NEXT_LOOP;
      clLabel(END_LOOP);
      return(clValues1(required));
      return(clValues1(clNIL)); } } }

clObject clExtractLambdaList clVdecl(_ap)
{ clObject specialized_lambda_list;
  { clBeginParse(_ap);
    clSetq(specialized_lambda_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject parameters;
    clSetq(parameters, specialized_lambda_list);
    { clObject parameter;
      clSetq(parameter, clNIL);
      { clObject L_g9, L_g10, required;
        clSetq(L_g9, clList(clNIL, clEOA));
        clSetq(L_g10, L_g9);
        clSetq(required, clNIL);
        clLabel(NEXT_LOOP);
        if (clTrue(clAtom(parameters, clEOA))) goto END_LOOP;
        clSetq(parameter, clCar(parameters, clEOA));
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, parameter);
            clSetq(L_test, clLambdaListKeywordP(L_0, clEOA)); }
          if (clTrue(L_test))
            return(clNconc(required, parameters, clEOA)); }
        { clObject L_1, L_0;
          clSetq(L_0, L_g10);
          { clObject L_0__R1;
            { clObject L_0__R2;
              clSetq(L_0__R2, parameter);
              clSetq(L_0__R1, clBindingformName(L_0__R2, clEOA)); }
            clSetq(L_1, clSetq(L_g10, clList(L_0__R1, clEOA))); }
          clRplacd(L_0, L_1, clEOA); }
        clSetq(required, clCdr(L_g9, clEOA));
        { clObject L_0;
          clSetq(L_0, parameters);
          clSetq(parameters, clCdr(L_0, clEOA)); }
        goto NEXT_LOOP;
        clLabel(END_LOOP);
        return(clValues1(required));
        return(clValues1(clNIL)); } } } }

clObject clExtractGenericFunctionLambdaList clVdecl(_ap)
{ clObject lambda_list;
  { clBeginParse(_ap);
    clSetq(lambda_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject parameter, L_g11;
    clSetq(parameter, clNIL);
    clSetq(L_g11, lambda_list);
    { clObject bailp;
      clSetq(bailp, clNIL);
      { clObject L_g12, L_g13, list;
        clSetq(L_g12, clList(clNIL, clEOA));
        clSetq(L_g13, L_g12);
        clSetq(list, clNIL);
        clLabel(NEXT_LOOP);
        if (clTrue(clEndp(L_g11, clEOA))) goto END_LOOP;
        clSetq(parameter, clCar(L_g11, clEOA));
        { clObject L_0;
          clSetq(L_0, L_g11);
          clSetq(L_g11, clCdr(L_0, clEOA)); }
        if (clTrue(bailp)) return(clValues1(list));
        { clObject L_key467;
          clSetq(L_key467, parameter);
          if (clTrue((_clEq(L_key467, clampersandAUX) ?
                      CONS_18 :
                      (_clEq(L_key467, clampersandALLOW_OTHER_KEYS) ?
                       CONS_19 :
                       clNIL))))
            return(clValues1(list));
          else if (_clEq(L_key467, clampersandKEY))
            clSetq(bailp, clT); }
        { clObject L_1, L_0;
          clSetq(L_0, L_g13);
          { clObject L_0__R1;
            { clObject L_0__R2;
              clSetq(L_0__R2, parameter);
              clSetq(L_0__R1, clBindingformName(L_0__R2, clEOA)); }
            clSetq(L_1, clSetq(L_g13, clList(L_0__R1, clEOA))); }
          clRplacd(L_0, L_1, clEOA); }
        clSetq(list, clCdr(L_g12, clEOA));
        goto NEXT_LOOP;
        clLabel(END_LOOP);
        return(clValues1(list));
        return(clValues1(clNIL)); } } } }

clObject clBindingformKeyword clVdecl(_ap)
{ clObject key;
  { clBeginParse(_ap);
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clConsp(key, clEOA)))
    { clObject key__R1;
      clSetq(key__R1, clCar(key, clEOA));
      if (clTrue(clConsp(key__R1, clEOA)))
        return(clCar(key__R1, clEOA));
      else return(clMakeKeyword(key__R1, clEOA)); }
  else return(clMakeKeyword(key, clEOA)); }

clObject clExtractKeywords clVdecl(_ap)
{ clObject lambda_list;
  { clBeginParse(_ap);
    clSetq(lambda_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject collectp, keys;
    clSetq(collectp, clNIL);
    clSetq(keys, clNIL);
    { clObject L_sublist469, parameter;
      clSetq(L_sublist469, lambda_list);
      clSetq(parameter, clCar(L_sublist469, clEOA));
      clLabel(l_ITERATE470);
      if (clTrue(clEndp(L_sublist469, clEOA))) return(clValues1(keys));
      { clObject L_test;
        { clObject L_g471;
          clSetq(L_g471,
                 clEq(parameter, clampersandALLOW_OTHER_KEYS, clEOA));
          clSetq(L_test,
                 (clTrue(L_g471) ? L_g471 :
                  clEq(parameter, clampersandAUX, clEOA))); }
        if (clTrue(L_test))
          clSetq(collectp, clNIL);
        else if (clTrue(collectp))
          { clObject L_1, L_0;
            clSetq(L_0, clBindingformKeyword(parameter, clEOA));
            clSetq(L_1, keys);
            clSetq(keys, clCons(L_0, L_1, clEOA)); }
        else if (_clEq(parameter, clampersandKEY))
          clSetq(collectp, clT); }
      { clObject L_0;
        clSetq(L_0, L_sublist469);
        clSetq(L_sublist469, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist469);
        clSetq(parameter, clCar(L_0, clEOA)); }
      goto l_ITERATE470; } } }

clObject clGetMethod clVdecl(_ap)
{ clObject generic_function, method_qualifiers, specializers, errorp;
  { clBeginParse(_ap);
    clSetq(generic_function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(method_qualifiers,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(specializers,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(errorp,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_sublist472, method;
    clSetq(L_sublist472,
           clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_METHODS),
                             generic_function,
                             clEOA));
    clSetq(method, clCar(L_sublist472, clEOA));
    clLabel(l_ITERATE473);
    if (clTrue(clEndp(L_sublist472, clEOA)))
      if (clTrue(errorp))
        return(clError(STRn_19,
                       method_qualifiers,
                       specializers,
                       generic_function,
                       clEOA));
      else return(clValues1(clNIL));
    if (clTrue((clTrue(clListEq(method_qualifiers,
                                clFuncallFunction(clSymbolFunctionValue(clMETHOD_QUALIFIERS),
                                                  method,
                                                  clEOA),
                                clEOA)) ?
                clListEq(specializers,
                         clFuncallFunction(clSymbolFunctionValue(clMETHOD_SPECIALIZERS),
                                           method,
                                           clEOA),
                         clEOA) :
                clNIL)))
      return(clValues1(method));
    { clObject L_0;
      clSetq(L_0, L_sublist472);
      clSetq(L_sublist472, clCdr(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, L_sublist472);
      clSetq(method, clCar(L_0, clEOA)); }
    goto l_ITERATE473; } }

clObject clMakeLoadFormSavingSlots clVdecl(_ap)
{ clObject L_ap, object, L_keys, slot_names, namesp, environment;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keySLOT_NAMES, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(slot_names, clCar(L_0, clEOA)); }
    else clSetq(slot_names, clNIL);
    clSetq(namesp, L_ap);
    if (clTrue(clSetq(L_ap, clKeyArg(keyENVIRONMENT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(environment, clCar(L_0, clEOA)); }
    else clSetq(environment, clNIL);
    clCheckKeys(L_keys, CONS_20, clEOA);
    clEndParse(_ap); }
  { clObject CL_class, names, forms;
    clSetq(CL_class, clClassOf(object, clEOA));
    clSetq(names, clNIL);
    { clObject slot, L_g14;
      clSetq(slot, clNIL);
      clSetq(L_g14,
             clFuncallFunction(clSymbolFunctionValue(clCLASS_SLOTS),
                               CL_class,
                               clEOA));
      { clObject name;
        clSetq(name, clNIL);
        { clObject L_g15, L_g16;
          clSetq(L_g15, clList(clNIL, clEOA));
          clSetq(L_g16, L_g15);
          clLabel(NEXT_LOOP);
          if (clTrue(clEndp(L_g14, clEOA))) goto END_LOOP;
          clSetq(slot, clCar(L_g14, clEOA));
          { clObject L_0;
            clSetq(L_0, L_g14);
            clSetq(L_g14, clCdr(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, slot);
            clSetq(name,
                   clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                                     L_0,
                                     clEOA)); }
          { clObject L_test;
            { clObject L_test__R1;
              { clObject L_g474;
                clSetq(L_g474, clNull(namesp, clEOA));
                if (clTrue(L_g474))
                  clSetq(L_test__R1, L_g474);
                else
                  { { clObject L_item476, L_sub475;
                      clSetq(L_item476, name);
                      clSetq(L_sub475, slot_names);
                      clLabel(l_ITERATE478);
                      if (clTrue(clEndp(L_sub475, clEOA)))
                      { clSetq(L_test__R1, clNIL);
                        clLocalReturn(NIL__r1); }
                      if (clTrue(clEql(L_item476,
                                       clCar(L_sub475, clEOA),
                                       clEOA)))
                      { clSetq(L_test__R1, L_sub475);
                        clLocalReturn(l_MEMBER477__r1); }
                      { clObject L_value479;
                        clSetq(L_value479, clCdr(L_sub475, clEOA));
                        clSetq(L_sub475, L_value479); }
                      goto l_ITERATE478; }
                    clBlockEnd(NIL__r1);
                    clBlockEnd(l_MEMBER477__r1); } }
              if (clTrue(L_test__R1))
                { clObject L_test__R2;
                  { clObject L_0;
                    clSetq(L_0, slot);
                    clSetq(L_test__R2, clLocalSlotP(L_0, clEOA)); }
                  if (clTrue(L_test__R2))
                    { clObject L_2;
                      clSetq(L_2, slot);
                      clSetq(L_test,
                             clFuncallFunction(clSymbolFunctionValue(clSLOT_BOUNDP_USING_CLASS),
                                               CL_class,
                                               object,
                                               L_2,
                                               clEOA)); }
                  else clSetq(L_test, clNIL); }
              else clSetq(L_test, clNIL); }
            if (clTrue(L_test))
              { { clObject L_1, L_0;
                  clSetq(L_0, L_g16);
                  { clObject L_0__R1;
                    { clObject L_2, L_1__R1;
                      clSetq(L_1__R1, name);
                      { clObject L_1__R2;
                        { clObject L_2__R1;
                          clSetq(L_2__R1, slot);
                          clSetq(L_1__R2,
                                 clFuncallFunction(clSymbolFunctionValue(clSLOT_VALUE_USING_CLASS),
                                                   CL_class,
                                                   object,
                                                   L_2__R1,
                                                   clEOA)); }
                        clSetq(L_2, clList(clQUOTE, L_1__R2, clEOA)); }
                      clSetq(L_0__R1,
                             clList(clSETF, L_1__R1, L_2, clEOA)); }
                    clSetq(L_1,
                           clSetq(L_g16, clList(L_0__R1, clEOA))); }
                  clRplacd(L_0, L_1, clEOA); }
                { clObject L_1, L_0;
                  clSetq(L_0, name);
                  clSetq(L_1, names);
                  clSetq(names, clCons(L_0, L_1, clEOA)); } } }
          goto NEXT_LOOP;
          clLabel(END_LOOP);
          clSetq(forms, clCdr(L_g15, clEOA));
          clLocalReturn(NIL__r2);
          clSetq(forms, clNIL);
          clBlockEnd(NIL__r2); } } }
    { clObject L_1, L_0;
      clSetq(L_0,
             clList(clALLOCATE_INSTANCE,
                    clList(clQUOTE, CL_class, clEOA), clEOA));
      { clObject L_3, L_2, L_1__R1;
        clSetq(L_1__R1, names);
        clSetq(L_2, clList(clQUOTE, object, clEOA));
        clSetq(L_3, forms);
        clSetq(L_1,
               clListSTAR(clWITH_SLOTS, L_1__R1, L_2, L_3, clEOA)); }
      return(clValues(L_0, L_1, clEOA)); } } }

clObject clCanonicalizeClass clVdecl(_ap)
{ clObject class_or_name, errorp;
  { clBeginParse(_ap);
    clSetq(class_or_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clT));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolp(class_or_name, clEOA)))
    { clObject L_1;
      clSetq(L_1, errorp);
      return(clFindType(class_or_name, L_1, clEOA)); }
  else return(clValues1(class_or_name)); }

clObject clMakeForwardReferencedClass clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clFuncallFunction(clSymbolFunctionValue(clENSURE_CLASS_USING_CLASS),
                           clNIL,
                           name,
                           keyMETACLASS,
                           clFORWARD_REFERENCED_CLASS,
                           clEOA)); }

clObject clCanonicalizeSpecializer clVdecl(_ap)
{ clObject specializer_or_name;
  { clBeginParse(_ap);
    clSetq(specializer_or_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolp(specializer_or_name, clEOA)))
    { clObject L_g480;
      clSetq(L_g480, clFindType(specializer_or_name, clNIL, clEOA));
      if (clTrue(L_g480))
        return(clValues1(L_g480));
      else
        return(clMakeForwardReferencedClass(specializer_or_name,
                                            clEOA)); }
  else return(clValues1(specializer_or_name)); }

clObject clCanonicalizeEnsureClassArgs clVdecl(_ap)
{ clObject keys;
  { clBeginParse(_ap);
    clSetq(keys,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, keys);
    clSetq(keys, clCopyList(L_0, clEOA)); }
  { clObject L_value481;
    clSetq(L_value481, keys);
    { clObject L_local483, L_local484;
      clSetq(L_local483, L_value481);
      clSetq(L_local484, clNIL);
      clLabel(l_ITERATE485);
      if (clTrue(clAtom(L_local483, clEOA))) clLocalReturn(NIL);
      if (clTrue(clAtom(clCdr(L_local483, clEOA), clEOA)))
        clError(STRn_15, clEOA);
      else
        { clObject L_test__R1;
          { clObject L_0;
            clSetq(L_0, clCar(L_local483, clEOA));
            clSetq(L_test__R1, clEq(L_0, keyMETACLASS, clEOA)); }
          if (clTrue(L_test__R1))
            if (clTrue(L_local484))
              { { clObject L_0;
                  clSetq(L_0, clCdr(L_local484, clEOA));
                  clRplacd(L_0, clCddr(L_local483, clEOA), clEOA); }
                (void) clT;
                clLocalReturn(NIL); }
            else
              { { clObject L_0;
                  clSetq(L_0, L_value481);
                  clSetq(L_value481, clCddr(L_0, clEOA)); }
                clSetq(keys, L_value481);
                (void) clT;
                clLocalReturn(NIL); } }
      { clObject L_value486, L_value487;
        clSetq(L_value486, clCddr(L_local483, clEOA));
        clSetq(L_value487, L_local483);
        clSetq(L_local483, L_value486);
        clSetq(L_local484, L_value487); }
      goto l_ITERATE485; }
    clBlockEnd(NIL); }
  { clObject direct_superclasses;
    { clObject L_0;
      clSetq(L_0, keys);
      clSetq(direct_superclasses,
             clGetf(L_0, keyDIRECT_SUPERCLASSES, clNOT_FOUND,
                    clEOA)); }
    if (clTrue(clNot(clEq(direct_superclasses, clNOT_FOUND, clEOA),
                     clEOA)))
      { clObject L_newval489;
        { clObject super, L_g17;
          clSetq(super, clNIL);
          clSetq(L_g17, direct_superclasses);
          { clObject L_g18, L_g19;
            clSetq(L_g18, clList(clNIL, clEOA));
            clSetq(L_g19, L_g18);
            clLabel(NEXT_LOOP);
            if (clTrue(clEndp(L_g17, clEOA))) goto END_LOOP;
            clSetq(super, clCar(L_g17, clEOA));
            { clObject L_0;
              clSetq(L_0, L_g17);
              clSetq(L_g17, clCdr(L_0, clEOA)); }
            { clObject L_1, L_0;
              clSetq(L_0, L_g19);
              { clObject L_0__R1;
                { clObject L_g491;
                  { clObject L_0__R2;
                    clSetq(L_0__R2, super);
                    clSetq(L_g491,
                           clCanonicalizeClass(L_0__R2,
                                               clNIL,
                                               clEOA)); }
                  if (clTrue(L_g491))
                    clSetq(L_0__R1, L_g491);
                  else
                    { clObject L_0__R2;
                      clSetq(L_0__R2, super);
                      clSetq(L_0__R1,
                             clMakeForwardReferencedClass(L_0__R2,
                                                          clEOA)); } }
                clSetq(L_1, clSetq(L_g19, clList(L_0__R1, clEOA))); }
              clRplacd(L_0, L_1, clEOA); }
            goto NEXT_LOOP;
            clLabel(END_LOOP);
            clSetq(L_newval489, clCdr(L_g18, clEOA));
            clLocalReturn(NIL__r1);
            clSetq(L_newval489, clNIL);
            clBlockEnd(NIL__r1); } }
        { clObject L_value488;
          { clObject L_2, L_0;
            clSetq(L_0, keys);
            clSetq(L_2, L_newval489);
            clSetq(L_value488,
                   clPutf(L_0, keyDIRECT_SUPERCLASSES, L_2, clEOA)); }
          clSetq(keys, L_value488);
          (void) L_newval489; } } }
  return(clValues1(keys)); }

clObject clCanonicalizeEnsureGenericFunctionArgs clVdecl(_ap)
{ clObject keys;
  { clBeginParse(_ap);
    clSetq(keys,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, keys);
    clSetq(keys, clCopyList(L_0, clEOA)); }
  { clObject L_value492;
    clSetq(L_value492, keys);
    { clObject L_local494, L_local495;
      clSetq(L_local494, L_value492);
      clSetq(L_local495, clNIL);
      clLabel(l_ITERATE496);
      if (clTrue(clAtom(L_local494, clEOA))) clLocalReturn(NIL);
      if (clTrue(clAtom(clCdr(L_local494, clEOA), clEOA)))
        clError(STRn_15, clEOA);
      else
        { clObject L_test__R1;
          { clObject L_0;
            clSetq(L_0, clCar(L_local494, clEOA));
            clSetq(L_test__R1,
                   clEq(L_0, keyGENERIC_FUNCTION_CLASS, clEOA)); }
          if (clTrue(L_test__R1))
            if (clTrue(L_local495))
              { { clObject L_0;
                  clSetq(L_0, clCdr(L_local495, clEOA));
                  clRplacd(L_0, clCddr(L_local494, clEOA), clEOA); }
                (void) clT;
                clLocalReturn(NIL); }
            else
              { { clObject L_0;
                  clSetq(L_0, L_value492);
                  clSetq(L_value492, clCddr(L_0, clEOA)); }
                clSetq(keys, L_value492);
                (void) clT;
                clLocalReturn(NIL); } }
      { clObject L_value497, L_value498;
        clSetq(L_value497, clCddr(L_local494, clEOA));
        clSetq(L_value498, L_local494);
        clSetq(L_local494, L_value497);
        clSetq(L_local495, L_value498); }
      goto l_ITERATE496; }
    clBlockEnd(NIL); }
  { clObject L_value499;
    clSetq(L_value499, keys);
    { clObject L_local501, L_local502;
      clSetq(L_local501, L_value499);
      clSetq(L_local502, clNIL);
      clLabel(l_ITERATE503);
      if (clTrue(clAtom(L_local501, clEOA))) clLocalReturn(NIL__r1);
      if (clTrue(clAtom(clCdr(L_local501, clEOA), clEOA)))
        clError(STRn_15, clEOA);
      else
        { clObject L_test__R1;
          { clObject L_0;
            clSetq(L_0, clCar(L_local501, clEOA));
            clSetq(L_test__R1, clEq(L_0, keyENVIRONMENT, clEOA)); }
          if (clTrue(L_test__R1))
            if (clTrue(L_local502))
              { { clObject L_0;
                  clSetq(L_0, clCdr(L_local502, clEOA));
                  clRplacd(L_0, clCddr(L_local501, clEOA), clEOA); }
                (void) clT;
                clLocalReturn(NIL__r1); }
            else
              { { clObject L_0;
                  clSetq(L_0, L_value499);
                  clSetq(L_value499, clCddr(L_0, clEOA)); }
                clSetq(keys, L_value499);
                (void) clT;
                clLocalReturn(NIL__r1); } }
      { clObject L_value504, L_value505;
        clSetq(L_value504, clCddr(L_local501, clEOA));
        clSetq(L_value505, L_local501);
        clSetq(L_local501, L_value504);
        clSetq(L_local502, L_value505); }
      goto l_ITERATE503; }
    clBlockEnd(NIL__r1); }
  { clObject requested_method_class;
    { clObject L_0;
      clSetq(L_0, keys);
      clSetq(requested_method_class,
             clGetf(L_0, keyMETHOD_CLASS, clNOT_FOUND, clEOA)); }
    if (clTrue(clNot(clEq(requested_method_class, clNOT_FOUND, clEOA),
                     clEOA)))
      { clObject L_newval507;
        clSetq(L_newval507,
               clCanonicalizeClass(requested_method_class,
                                   clT,
                                   clEOA));
        { clObject L_value506;
          { clObject L_0;
            clSetq(L_0, keys);
            clSetq(L_value506,
                   clPutf(L_0, keyMETHOD_CLASS, L_newval507, clEOA)); }
          clSetq(keys, L_value506);
          (void) L_newval507; } } }
  return(clValues1(keys)); }

clDeclareEnv(clCollectSuperclassesSTAR_AllSuperclassesLoop);
static clObject clCollectSuperclassesSTAR_AllSuperclassesLoop clVdecl(_ap)
{ clUseEnv(clCollectSuperclassesSTAR_AllSuperclassesLoop);
  { clObject seen, superclasses;
    { clBeginParse(_ap);
      clSetq(seen,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(superclasses,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject class_to_process;
      { clObject L_sublist509, super;
        clSetq(L_sublist509, superclasses);
        clSetq(super, clCar(L_sublist509, clEOA));
        clLabel(l_ITERATE510);
        if (clTrue(clEndp(L_sublist509, clEOA)))
          { clSetq(class_to_process, clNIL); clLocalReturn(NIL); }
        if (clTrue(clNot(clFastFind(super, seen), clEOA)))
          { clSetq(class_to_process, super); clLocalReturn(NIL); }
        { clObject L_0;
          clSetq(L_0, L_sublist509);
          clSetq(L_sublist509, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist509);
          clSetq(super, clCar(L_0, clEOA)); }
        goto l_ITERATE510; }
      clBlockEnd(NIL);
      if (clTrue(class_to_process))
        { clObject L_1, L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, class_to_process);
            clSetq(L_0, clCons(L_0__R1, seen, clEOA)); }
          { clObject L_sublist511, super;
            { clObject L_0__R1;
              clSetq(L_0__R1, class_to_process);
              clSetq(L_sublist511,
                     clFuncallFunction(clSymbolFunctionValue(clCLASS_DIRECT_SUPERCLASSES),
                                       L_0__R1,
                                       clEOA)); }
            clSetq(super, clCar(L_sublist511, clEOA));
            clLabel(l_ITERATE512);
            if (clTrue(clEndp(L_sublist511, clEOA)))
              { clSetq(L_1, superclasses); clLocalReturn(NIL__r1); }
            { clObject L_1__R1;
              clSetq(L_1__R1, superclasses);
              clSetq(superclasses, clAdjoin(super, L_1__R1, clEOA)); }
            { clObject L_0__R1;
              clSetq(L_0__R1, L_sublist511);
              clSetq(L_sublist511, clCdr(L_0__R1, clEOA)); }
            { clObject L_0__R1;
              clSetq(L_0__R1, L_sublist511);
              clSetq(super, clCar(L_0__R1, clEOA)); }
            goto l_ITERATE512; }
          clBlockEnd(NIL__r1);
          return(clFuncallFunction(clEnv(0, *_AllSuperclassesLoop_),
                                   L_0,
                                   L_1,
                                   clEOA)); }
      else return(clValues1(superclasses)); } } }

clObject clCollectSuperclassesSTAR clVdecl(_ap)
{ clObject CL_class;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject *_AllSuperclassesLoop_ = clMakeBinding();
    clSetq(*_AllSuperclassesLoop_,
           clMakeClosure(1,
                         clCollectSuperclassesSTAR_AllSuperclassesLoop,
                         &clEnvHook(clCollectSuperclassesSTAR_AllSuperclassesLoop),
                         &*_AllSuperclassesLoop_));
    return(clFuncallFunction(*_AllSuperclassesLoop_,
                             clNIL,
                             clList(CL_class, clEOA),
                             clEOA)); } }

clDeclareEnv(clTopologicalSort_Lambda);
static clObject clTopologicalSort_Lambda clVdecl(_ap)
{ clUseEnv(clTopologicalSort_Lambda);
  { clObject CL_class;
    { clBeginParse(_ap);
      clSetq(CL_class,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject L_sub513;
      clSetq(L_sub513, clEnv(0, *remaining_constraints));
      clLabel(l_ITERATE516);
      if (clTrue(clEndp(L_sub513, clEOA))) return(clValues1(clNIL));
      if (clTrue(clEql(CL_class,
                       clCadr(clCar(L_sub513, clEOA), clEOA),
                       clEOA)))
        return(clValues1(L_sub513));
      { clObject L_value517;
        clSetq(L_value517, clCdr(L_sub513, clEOA));
        clSetq(L_sub513, L_value517); }
      goto l_ITERATE516; } } }

clObject clTopologicalSort clVdecl(_ap)
{ clObject elements, constraints, tie_breaker;
  { clBeginParse(_ap);
    clSetq(elements,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(constraints,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(tie_breaker,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject *remaining_constraints = clMakeBinding(),
    remaining_elements, result;
    clSetq(*remaining_constraints, constraints);
    clSetq(remaining_elements, elements);
    clSetq(result, clNIL);
    clLabel(l_LOOP20);
    { clObject minimal_elements;
      { clObject L_0;
        clSetq(L_0,
               clMakeClosure(1,
                             clTopologicalSort_Lambda,
                             &clEnvHook(clTopologicalSort_Lambda),
                             &*remaining_constraints));
        clSetq(minimal_elements,
               clRemoveIf(L_0, remaining_elements, clEOA)); }
      if (clTrue(clNull(minimal_elements, clEOA)))
        if (clTrue(clNull(remaining_elements, clEOA)))
          return(clValues1(result));
        else clError(STRn_26, clEOA);
      { clObject choice;
        clSetq(choice,
               (clTrue(clNull(clCdr(minimal_elements, clEOA), clEOA)) ?
                clCar(minimal_elements, clEOA) :
                clFuncall(tie_breaker,
                          minimal_elements,
                          result,
                          clEOA)));
        { clObject L_1, L_0;
          clSetq(L_0, result);
          { clObject L_0__R1;
            clSetq(L_0__R1, choice);
            clSetq(L_1, clList(L_0__R1, clEOA)); }
          clSetq(result, clNconc(L_0, L_1, clEOA)); }
        { clObject L_1, L_0;
          clSetq(L_0, choice);
          clSetq(L_1, remaining_elements);
          clSetq(remaining_elements, clDelete(L_0, L_1, clEOA)); }
        { clObject L_1, L_0;
          clSetq(L_0, choice);
          clSetq(L_1, *remaining_constraints);
          clSetq(*remaining_constraints,
                 clDelete(L_0,
                          L_1,
                          keyTEST,
                          clSymbolFunctionValue(clMEMBER),
                          clEOA)); } } }
    goto l_LOOP20; } }

clObject clStdTieBreakerRule clVdecl(_ap)
{ clObject minimal_elements, cpl_so_far;
  { clBeginParse(_ap);
    clSetq(minimal_elements,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(cpl_so_far,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_sublist518, cpl_constituent;
    clSetq(L_sublist518,
           clFuncallFunction(clSymbolFunctionValue(clREVERSE),
                             cpl_so_far,
                             clEOA));
    clSetq(cpl_constituent, clCar(L_sublist518, clEOA));
    clLabel(l_ITERATE519);
    if (clTrue(clEndp(L_sublist518, clEOA))) return(clValues1(clNIL));
    { clObject L_sublist520, element;
      clSetq(L_sublist520, minimal_elements);
      clSetq(element, clCar(L_sublist520, clEOA));
      clLabel(l_ITERATE521);
      if (clTrue(clEndp(L_sublist520, clEOA))) clLocalReturn(NIL);
      if (clTrue(clFastFind(element,
                            clFuncallFunction(clSymbolFunctionValue(clCLASS_DIRECT_SUPERCLASSES),
                                              cpl_constituent,
                                              clEOA))))
        return(clValues1(element));
      { clObject L_0;
        clSetq(L_0, L_sublist520);
        clSetq(L_sublist520, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist520);
        clSetq(element, clCar(L_0, clEOA)); }
      goto l_ITERATE521; }
    clBlockEnd(NIL);
    { clObject L_0;
      clSetq(L_0, L_sublist518);
      clSetq(L_sublist518, clCdr(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, L_sublist518);
      clSetq(cpl_constituent, clCar(L_0, clEOA)); }
    goto l_ITERATE519; } }

clObject clLocalPrecedenceOrdering clVdecl(_ap)
{ clObject CL_class;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject supers;
    clSetq(supers,
           clFuncallFunction(clSymbolFunctionValue(clCLASS_DIRECT_SUPERCLASSES),
                             CL_class,
                             clEOA));
    { clObject L_1, L_0;
      clSetq(L_0, clSymbolFunctionValue(clLIST));
      clSetq(L_1, clCons(CL_class, supers, clEOA));
      return(clMapcar(L_0, L_1, supers, clEOA)); } } }

void clInitClosDefine __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(STRn_0,
         clCharpSimpleBaseString("~s~@[ (used by ~s)~] has not been defined."));
  clSetq(I_2, clIntFixnum(2));
  clSetq(STRn_1,
         clCharpSimpleBaseString("~:[S~;Abstract s~]uperclass ~s is not compatible with ~:[~;abstract ~]~s (metaclass ~s)."));
  clSetq(STRn_2,
         clCharpSimpleBaseString("~a method parameters ~s are not congruent to ~s."));
  clSetq(CONS_1, clCons(clampersandKEY, clNIL, clEOA));
  clSetq(CONS_0, clCons(clampersandREST, CONS_1, clEOA));
  clSetq(I_0, clIntFixnum(0));
  clSetq(STRn_3,
         clCharpSimpleBaseString("Discard old definition of ~s~*."));
  clSetq(STRn_4,
         clCharpSimpleBaseString("~s names the non-generic-function ~s."));
  clSetq(I_3, clIntFixnum(3));
  clSetq(STR_NAME__5,
         clCharpSimpleBaseString("NAME"));
  clSetq(keyNAME, clMakeKeyword(STR_NAME__5, clEOA));
  clSetq(STR_READERS__6,
         clCharpSimpleBaseString("READERS"));
  clSetq(keyREADERS, clMakeKeyword(STR_READERS__6, clEOA));
  clSetq(STR_WRITERS__7,
         clCharpSimpleBaseString("WRITERS"));
  clSetq(keyWRITERS, clMakeKeyword(STR_WRITERS__7, clEOA));
  clSetq(STR_DATUM__8,
         clCharpSimpleBaseString("DATUM"));
  clSetq(keyDATUM, clMakeKeyword(STR_DATUM__8, clEOA));
  clSetq(STR_EXPECTED_TYPE__9,
         clCharpSimpleBaseString("EXPECTED-TYPE"));
  clSetq(keyEXPECTED_TYPE, clMakeKeyword(STR_EXPECTED_TYPE__9, clEOA));
  clSetq(CONS_4, clCons(keyWRITERS, clNIL, clEOA));
  clSetq(CONS_3, clCons(keyREADERS, CONS_4, clEOA));
  clSetq(CONS_2, clCons(clMEMBER, CONS_3, clEOA));
  clSetq(I_4, clIntFixnum(4));
  clSetq(CONS_7, clCons(keyREADERS, clNIL, clEOA));
  clSetq(CONS_6, clCons(keyWRITERS, CONS_7, clEOA));
  clSetq(CONS_5, clCons(clMEMBER, CONS_6, clEOA));
  clSetq(STR_SLOT_DEFINITION__10,
         clCharpSimpleBaseString("SLOT-DEFINITION"));
  clSetq(keySLOT_DEFINITION,
         clMakeKeyword(STR_SLOT_DEFINITION__10, clEOA));
  clSetq(STR_SPECIALIZERS__11,
         clCharpSimpleBaseString("SPECIALIZERS"));
  clSetq(keySPECIALIZERS, clMakeKeyword(STR_SPECIALIZERS__11, clEOA));
  clSetq(STR_KEY__12,
         clCharpSimpleBaseString("KEY"));
  clSetq(keyKEY, clMakeKeyword(STR_KEY__12, clEOA));
  clSetq(CONS_9, clCons(clSLOT_VALUE_USING_CLASS, clNIL, clEOA));
  clSetq(CONS_8, clCons(clSETF, CONS_9, clEOA));
  clSetq(CONS_11, clCons(clCLASS_DIRECT_SHARED_SLOTS, clNIL, clEOA));
  clSetq(CONS_10, clCons(clSETF, CONS_11, clEOA));
  clSetq(STR_INSTANCE__13,
         clCharpSimpleBaseString("INSTANCE"));
  clSetq(keyINSTANCE, clMakeKeyword(STR_INSTANCE__13, clEOA));
  clSetq(STR_CLASS__14,
         clCharpSimpleBaseString("CLASS"));
  clSetq(keyCLASS, clMakeKeyword(STR_CLASS__14, clEOA));
  clSetq(CONS_13, clCons(clSLOT_DEFINITION_LOCATION, clNIL, clEOA));
  clSetq(CONS_12, clCons(clSETF, CONS_13, clEOA));
  clSetq(STRn_15,
         clCharpSimpleBaseString("Odd-length property list in REMF."));
  clSetq(CONS_15, clCons(clGETHASH, clNIL, clEOA));
  clSetq(CONS_14, clCons(clSETF, CONS_15, clEOA));
  clSetq(STR_OBJECT__16,
         clCharpSimpleBaseString("OBJECT"));
  clSetq(keyOBJECT, clMakeKeyword(STR_OBJECT__16, clEOA));
  clSetq(STR_FUNCTION__17,
         clCharpSimpleBaseString("FUNCTION"));
  clSetq(keyFUNCTION, clMakeKeyword(STR_FUNCTION__17, clEOA));
  clSetq(STR_OPTIONS__18,
         clCharpSimpleBaseString("OPTIONS"));
  clSetq(keyOPTIONS, clMakeKeyword(STR_OPTIONS__18, clEOA));
  clSetq(CONS_17,
         clCons(clFIND_METHOD_COMBINATION_TYPE, clNIL, clEOA));
  clSetq(CONS_16, clCons(clSETF, CONS_17, clEOA));
  clSetq(CONS_19, clCons(clampersandALLOW_OTHER_KEYS, clNIL, clEOA));
  clSetq(CONS_18, clCons(clampersandAUX, CONS_19, clEOA));
  clSetq(STRn_19,
         clCharpSimpleBaseString("No method~@[~{ ~s~}~] ~s on ~s."));
  clSetq(STR_SLOT_NAMES__20,
         clCharpSimpleBaseString("SLOT-NAMES"));
  clSetq(keySLOT_NAMES, clMakeKeyword(STR_SLOT_NAMES__20, clEOA));
  clSetq(STR_ENVIRONMENT__21,
         clCharpSimpleBaseString("ENVIRONMENT"));
  clSetq(keyENVIRONMENT, clMakeKeyword(STR_ENVIRONMENT__21, clEOA));
  clSetq(CONS_21, clCons(keySLOT_NAMES, clNIL, clEOA));
  clSetq(CONS_20, clCons(keyENVIRONMENT, CONS_21, clEOA));
  clSetq(STR_METACLASS__22,
         clCharpSimpleBaseString("METACLASS"));
  clSetq(keyMETACLASS, clMakeKeyword(STR_METACLASS__22, clEOA));
  clSetq(STR_DIRECT_SUPERCLASSES__23,
         clCharpSimpleBaseString("DIRECT-SUPERCLASSES"));
  clSetq(keyDIRECT_SUPERCLASSES,
         clMakeKeyword(STR_DIRECT_SUPERCLASSES__23, clEOA));
  clSetq(STRn_24,
         clCharpSimpleBaseString("GENERIC-FUNCTION-CLASS"));
  clSetq(keyGENERIC_FUNCTION_CLASS, clMakeKeyword(STRn_24, clEOA));
  clSetq(STR_METHOD_CLASS__25,
         clCharpSimpleBaseString("METHOD-CLASS"));
  clSetq(keyMETHOD_CLASS, clMakeKeyword(STR_METHOD_CLASS__25, clEOA));
  clSetq(STRn_26,
         clCharpSimpleBaseString("Inconsistent precedence graph."));
  clSetq(STR_TEST__27,
         clCharpSimpleBaseString("TEST"));
  clSetq(keyTEST, clMakeKeyword(STR_TEST__27, clEOA));

  clSetSymbolFunctionValue(clILLEGAL_FORWARD_REFERENCE,
                           clMakeClosure(0,
                                         clIllegalForwardReference,
                                         clNULL_HOOK));
  (void) clILLEGAL_FORWARD_REFERENCE;
  clSetSymbolFunctionValue(clILLEGAL_SUPERCLASS,
                           clMakeClosure(0,
                                         clIllegalSuperclass,
                                         clNULL_HOOK));
  (void) clILLEGAL_SUPERCLASS;
  clSetSymbolFunctionValue(clCHECK_CONGRUENT_LAMBDA,
                           clMakeClosure(0,
                                         clCheckCongruentLambda,
                                         clNULL_HOOK));
  (void) clCHECK_CONGRUENT_LAMBDA;
  clSetSymbolFunctionValue(clCHECK_FOR_FORWARD_REFERENCES,
                           clMakeClosure(0,
                                         clCheckForForwardReferences,
                                         clNULL_HOOK));
  (void) clCHECK_FOR_FORWARD_REFERENCES;
  clSetSymbolFunctionValue(clFORWARD_REFERENCED_CLASS_P,
                           clMakeClosure(0,
                                         clForwardReferencedClassP,
                                         clNULL_HOOK));
  (void) clFORWARD_REFERENCED_CLASS_P;
  clSetSymbolFunctionValue(clGENERIC_FUNCTION_P,
                           clMakeClosure(0,
                                         clGenericFunctionP,
                                         clNULL_HOOK));
  (void) clGENERIC_FUNCTION_P;
  clSetSymbolFunctionValue(clCONGRUENT_LAMBDA_P,
                           clMakeClosure(0,
                                         clCongruentLambdaP,
                                         clNULL_HOOK));
  (void) clCONGRUENT_LAMBDA_P;
  clSetSymbolFunctionValue(clENSURE_CLASS,
                           clMakeClosure(0,
                                         clEnsureClass,
                                         clNULL_HOOK));
  (void) clENSURE_CLASS;
  clSetSymbolFunctionValue(clENSURE_GENERIC_FUNCTION,
                           clMakeClosure(0,
                                         clEnsureGenericFunction,
                                         clNULL_HOOK));
  (void) clENSURE_GENERIC_FUNCTION;
  clSetSymbolFunctionValue(clENSURE_METHOD_USING_CLASS,
                           clMakeClosure(0,
                                         clEnsureMethodUsingClass,
                                         clNULL_HOOK));
  (void) clENSURE_METHOD_USING_CLASS;
  clSetSymbolFunctionValue(clENSURE_METHOD,
                           clMakeClosure(0,
                                         clEnsureMethod,
                                         clNULL_HOOK));
  (void) clENSURE_METHOD;
  clSetSymbolFunctionValue(clENSURE_METHOD_COMBINATION_TYPE,
                           clMakeClosure(0,
                                         clEnsureMethodCombinationType,
                                         clNULL_HOOK));
  (void) clENSURE_METHOD_COMBINATION_TYPE;
  clSetSymbolFunctionValue(clMAKE_DIRECT_SLOT_DEFINITION,
                           clMakeClosure(0,
                                         clMakeDirectSlotDefinition,
                                         clNULL_HOOK));
  (void) clMAKE_DIRECT_SLOT_DEFINITION;
  clSetSymbolFunctionValue(clMAKE_EFFECTIVE_SLOT_DEFINITION,
                           clMakeClosure(0,
                                         clMakeEffectiveSlotDefinition,
                                         clNULL_HOOK));
  (void) clMAKE_EFFECTIVE_SLOT_DEFINITION;
  clSetSymbolFunctionValue(clACCESSOR_SPECIALIZERS,
                           clMakeClosure(0,
                                         clAccessorSpecializers,
                                         clNULL_HOOK));
  (void) clACCESSOR_SPECIALIZERS;
  clSetSymbolFunctionValue(clADD_ACCESSOR_METHODS,
                           clMakeClosure(0,
                                         clAddAccessorMethods,
                                         clNULL_HOOK));
  (void) clADD_ACCESSOR_METHODS;
  clSetSymbolFunctionValue(clREMOVE_ACCESSOR_METHODS,
                           clMakeClosure(0,
                                         clRemoveAccessorMethods,
                                         clNULL_HOOK));
  (void) clREMOVE_ACCESSOR_METHODS;
  clSetSymbolFunctionValue(clSTANDARD_CHANGE_CLASS,
                           clMakeClosure(0,
                                         clStandardChangeClass,
                                         clNULL_HOOK));
  (void) clSTANDARD_CHANGE_CLASS;
  clSetSymbolFunctionValue(clCOMPUTE_CLASS_ALLOCATED_SLOT,
                           clMakeClosure(0,
                                         clComputeClassAllocatedSlot,
                                         clNULL_HOOK));
  (void) clCOMPUTE_CLASS_ALLOCATED_SLOT;
  clSetSymbolFunctionValue(clCOMPUTE_SLOT_LOCATIONS,
                           clMakeClosure(0,
                                         clComputeSlotLocations,
                                         clNULL_HOOK));
  (void) clCOMPUTE_SLOT_LOCATIONS;
  clSetSymbolFunctionValue(clSET_FUNCALLABLE_INSTANCE_FUNCTION,
                           clMakeClosure(0,
                                         clSetFuncallableInstanceFunction,
                                         clNULL_HOOK));
  (void) clSET_FUNCALLABLE_INSTANCE_FUNCTION;
  clSetSymbolFunctionValue(clINTERN_INSTANCE,
                           clMakeClosure(0,
                                         clInternInstance,
                                         clNULL_HOOK));
  (void) clINTERN_INSTANCE;
  clSetSymbolFunctionValue(clINTERN_EQL_SPECIALIZER,
                           clMakeClosure(0,
                                         clInternEqlSpecializer,
                                         clNULL_HOOK));
  (void) clINTERN_EQL_SPECIALIZER;
  clSetSymbolFunctionValue(clINTERN_METHOD_COMBINATION,
                           clMakeClosure(0,
                                         clInternMethodCombination,
                                         clNULL_HOOK));
  (void) clINTERN_METHOD_COMBINATION;
  clSetSymbolFunctionValue(clFIND_METHOD_COMBINATION_TYPE,
                           clMakeClosure(0,
                                         clFindMethodCombinationType,
                                         clNULL_HOOK));
  (void) clFIND_METHOD_COMBINATION_TYPE;
  clSetSymbolSetfFunctionValue(clFIND_METHOD_COMBINATION_TYPE,
                               clMakeClosure(0,
                                             cl_SETF_FindMethodCombinationType,
                                             clNULL_HOOK));
  (void) CONS_16;
  clSetSymbolFunctionValue(clEXTRACT_SPECIALIZER_NAMES,
                           clMakeClosure(0,
                                         clExtractSpecializerNames,
                                         clNULL_HOOK));
  (void) clEXTRACT_SPECIALIZER_NAMES;
  clSetSymbolFunctionValue(clEXTRACT_LAMBDA_LIST,
                           clMakeClosure(0,
                                         clExtractLambdaList,
                                         clNULL_HOOK));
  (void) clEXTRACT_LAMBDA_LIST;
  clSetSymbolFunctionValue(clEXTRACT_GENERIC_FUNCTION_LAMBDA_LIST,
                           clMakeClosure(0,
                                         clExtractGenericFunctionLambdaList,
                                         clNULL_HOOK));
  (void) clEXTRACT_GENERIC_FUNCTION_LAMBDA_LIST;
  clSetSymbolFunctionValue(clBINDINGFORM_KEYWORD,
                           clMakeClosure(0,
                                         clBindingformKeyword,
                                         clNULL_HOOK));
  (void) clBINDINGFORM_KEYWORD;
  clSetSymbolFunctionValue(clEXTRACT_KEYWORDS,
                           clMakeClosure(0,
                                         clExtractKeywords,
                                         clNULL_HOOK));
  (void) clEXTRACT_KEYWORDS;
  clSetSymbolFunctionValue(clGET_METHOD,
                           clMakeClosure(0, clGetMethod, clNULL_HOOK));
  (void) clGET_METHOD;
  clSetSymbolFunctionValue(clMAKE_LOAD_FORM_SAVING_SLOTS,
                           clMakeClosure(0,
                                         clMakeLoadFormSavingSlots,
                                         clNULL_HOOK));
  (void) clMAKE_LOAD_FORM_SAVING_SLOTS;
  clSetSymbolFunctionValue(clCANONICALIZE_CLASS,
                           clMakeClosure(0,
                                         clCanonicalizeClass,
                                         clNULL_HOOK));
  (void) clCANONICALIZE_CLASS;
  clSetSymbolFunctionValue(clMAKE_FORWARD_REFERENCED_CLASS,
                           clMakeClosure(0,
                                         clMakeForwardReferencedClass,
                                         clNULL_HOOK));
  (void) clMAKE_FORWARD_REFERENCED_CLASS;
  clSetSymbolFunctionValue(clCANONICALIZE_SPECIALIZER,
                           clMakeClosure(0,
                                         clCanonicalizeSpecializer,
                                         clNULL_HOOK));
  (void) clCANONICALIZE_SPECIALIZER;
  clSetSymbolFunctionValue(clCANONICALIZE_ENSURE_CLASS_ARGS,
                           clMakeClosure(0,
                                         clCanonicalizeEnsureClassArgs,
                                         clNULL_HOOK));
  (void) clCANONICALIZE_ENSURE_CLASS_ARGS;
  clSetSymbolFunctionValue(clCANONICALIZE_ENSURE_GENERIC_FUNCTION_ARGS,
                           clMakeClosure(0,
                                         clCanonicalizeEnsureGenericFunctionArgs,
                                         clNULL_HOOK));
  (void) clCANONICALIZE_ENSURE_GENERIC_FUNCTION_ARGS;
  clSetSymbolFunctionValue(clCOLLECT_SUPERCLASSESstar,
                           clMakeClosure(0,
                                         clCollectSuperclassesSTAR,
                                         clNULL_HOOK));
  (void) clCOLLECT_SUPERCLASSESstar;
  clSetSymbolFunctionValue(clTOPOLOGICAL_SORT,
                           clMakeClosure(0,
                                         clTopologicalSort,
                                         clNULL_HOOK));
  (void) clTOPOLOGICAL_SORT;
  clSetSymbolFunctionValue(clSTD_TIE_BREAKER_RULE,
                           clMakeClosure(0,
                                         clStdTieBreakerRule,
                                         clNULL_HOOK));
  (void) clSTD_TIE_BREAKER_RULE;
  clSetSymbolFunctionValue(clLOCAL_PRECEDENCE_ORDERING,
                           clMakeClosure(0,
                                         clLocalPrecedenceOrdering,
                                         clNULL_HOOK));
  (void) clLOCAL_PRECEDENCE_ORDERING;
  clUnwind(4); }
