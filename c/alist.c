/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Wednesday the eighth of April, 1998, 1:55:29 pm CDT. */
#include <eclipse.h>

clObject clAcons(clProto), clAssoc1(clProto), clCar(clProto),
  clCdr(clProto), clCharpSimpleBaseString __P((clCharp)),
  clCheckKeys(clProto), clConc(clProto), clCons(clProto),
  clConsp(clProto), clEndp(clProto), clError(clProto),
  clExtraArgs(clProto), clKeyArg(clProto), clMakeKeyword(clProto),
  clMissingArgs(clProto), clRassoc1(clProto),
  clSatisfiesTheTest(clProto);

extern clObject clACONS, clASSOC_IF, clASSOC_IF_NOT, clCOPY_ALIST,
  clNONE, clPAIRLIS, clRASSOC, clRASSOC_IF, clRASSOC_IF_NOT, clRASSOC1;

static clObject CONS_0, CONS_1, CONS_2, CONS_3, I_1, I_2, I_3, I_4,
  I_5, keyKEY, keyTEST, keyTEST_NOT, STR_KEY__1, STR_TEST_NOT__3,
  STR_TEST__2, STRn_0;

static clObject clCopyAlist_Lambda clVdecl(_ap)
{ clObject CL_new;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    if (clTrue(clConsp(CL_new, clEOA)))
      { clObject L_0__R1;
        clSetq(L_0__R1, clCar(CL_new, clEOA));
        clSetq(L_0, clCons(L_0__R1, clCdr(CL_new, clEOA), clEOA)); }
    else clSetq(L_0, CL_new);
    return(clCons(L_0, clNIL, clEOA)); } }

clObject clCopyAlist clVdecl(_ap)
{ clObject list;
  { clBeginParse(_ap);
    clSetq(list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clConc(list,
                clMakeClosure(0, clCopyAlist_Lambda, clNULL_HOOK),
                clEOA)); }

clObject clAcons clVdecl(_ap)
{ clObject key, datum, alist;
  { clBeginParse(_ap);
    clSetq(key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(datum,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(alist,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, clCons(key, datum, clEOA));
    return(clCons(L_0, alist, clEOA)); } }

clObject clPairlis clVdecl(_ap)
{ clObject keys, data, alist;
  { clBeginParse(_ap);
    clSetq(keys,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(data,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(alist, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject x, y;
    clSetq(x, keys);
    clSetq(y, data);
    clLabel(l_ITERATE462);
    { clObject L_test;
      { clObject L_g463;
        clSetq(L_g463, clEndp(x, clEOA));
        clSetq(L_test, (clTrue(L_g463) ? L_g463 : clEndp(y, clEOA))); }
      if (clTrue(L_test))
        if (clTrue((clTrue(x) ? x : y)))
          return(clError(STRn_0, clEOA));
        else return(clValues1(alist)); }
    { clObject L_2, L_1, L_0;
      clSetq(L_0, clCar(x, clEOA));
      clSetq(L_1, clCar(y, clEOA));
      clSetq(L_2, alist);
      clSetq(alist, clAcons(L_0, L_1, L_2, clEOA)); }
    { clObject L_value465, L_value466;
      clSetq(L_value465, clCdr(x, clEOA));
      clSetq(L_value466, clCdr(y, clEOA));
      clSetq(x, L_value465);
      clSetq(y, L_value466); }
    goto l_ITERATE462; } }

clObject clRassoc1 clVdecl(_ap)
{ clObject CL_item, CL_a_list, CL_test, CL_test_not, CL_key;
  { clBeginParse(_ap);
    clSetq(CL_item,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(CL_a_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(CL_test,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(CL_test_not,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    clSetq(CL_key,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_5, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_sublist467, CL_pair;
    clSetq(L_sublist467, CL_a_list);
    clSetq(CL_pair, clCar(L_sublist467, clEOA));
    clLabel(l_ITERATE468);
    if (clTrue(clEndp(L_sublist467, clEOA))) return(clValues1(clNIL));
    { clObject L_test;
      { clObject L_1;
        clSetq(L_1, clCdr(CL_pair, clEOA));
        clSetq(L_test,
               clSatisfiesTheTest(CL_item,
                                  L_1,
                                  CL_test,
                                  CL_test_not,
                                  CL_key,
                                  clEOA)); }
      if (clTrue(L_test)) return(clValues1(CL_pair)); }
    { clObject L_0;
      clSetq(L_0, L_sublist467);
      clSetq(L_sublist467, clCdr(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, L_sublist467);
      clSetq(CL_pair, clCar(L_0, clEOA)); }
    goto l_ITERATE468; } }

clObject clAssocIf clVdecl(_ap)
{ clObject L_ap, predicate, a_list, L_keys, key;
  { clBeginParse(_ap);
    clSetq(predicate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(a_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_4;
    clSetq(L_4, key);
    return(clAssoc1(clNONE, a_list, predicate, clNIL, L_4, clEOA)); } }

clObject clAssocIfNot clVdecl(_ap)
{ clObject L_ap, predicate, a_list, L_keys, key;
  { clBeginParse(_ap);
    clSetq(predicate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(a_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_4;
    clSetq(L_4, key);
    return(clAssoc1(clNONE, a_list, clNIL, predicate, L_4, clEOA)); } }

clObject clRassoc clVdecl(_ap)
{ clObject L_ap, item, a_list, L_keys, test, test_not, key;
  { clBeginParse(_ap);
    clSetq(item,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(a_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test, clCar(L_0, clEOA)); }
    else clSetq(test, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEST_NOT, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(test_not, clCar(L_0, clEOA)); }
    else clSetq(test_not, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_1, clEOA);
    clEndParse(_ap); }
  { clObject L_4, L_3, L_2;
    clSetq(L_2, test);
    clSetq(L_3, test_not);
    clSetq(L_4, key);
    return(clRassoc1(item, a_list, L_2, L_3, L_4, clEOA)); } }

clObject clRassocIf clVdecl(_ap)
{ clObject L_ap, predicate, a_list, L_keys, key;
  { clBeginParse(_ap);
    clSetq(predicate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(a_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_4;
    clSetq(L_4, key);
    return(clRassoc1(clNONE, a_list, predicate, clNIL, L_4, clEOA)); } }

clObject clRassocIfNot clVdecl(_ap)
{ clObject L_ap, predicate, a_list, L_keys, key;
  { clBeginParse(_ap);
    clSetq(predicate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(a_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(key, clCar(L_0, clEOA)); }
    else clSetq(key, clNIL);
    clCheckKeys(L_keys, CONS_0, clEOA);
    clEndParse(_ap); }
  { clObject L_4;
    clSetq(L_4, key);
    return(clRassoc1(clNONE, a_list, clNIL, predicate, L_4, clEOA)); } }

void clInitAlist __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(I_3, clIntFixnum(3));
  clSetq(STRn_0,
         clCharpSimpleBaseString("Unmatched keys or data."));
  clSetq(I_4, clIntFixnum(4));
  clSetq(I_5, clIntFixnum(5));
  clSetq(STR_KEY__1,
         clCharpSimpleBaseString("KEY"));
  clSetq(keyKEY, clMakeKeyword(STR_KEY__1, clEOA));
  clSetq(CONS_0, clCons(keyKEY, clNIL, clEOA));
  clSetq(STR_TEST__2,
         clCharpSimpleBaseString("TEST"));
  clSetq(keyTEST, clMakeKeyword(STR_TEST__2, clEOA));
  clSetq(STR_TEST_NOT__3,
         clCharpSimpleBaseString("TEST-NOT"));
  clSetq(keyTEST_NOT, clMakeKeyword(STR_TEST_NOT__3, clEOA));
  clSetq(CONS_3, clCons(keyTEST, clNIL, clEOA));
  clSetq(CONS_2, clCons(keyTEST_NOT, CONS_3, clEOA));
  clSetq(CONS_1, clCons(keyKEY, CONS_2, clEOA));

  clSetSymbolFunctionValue(clCOPY_ALIST,
                           clMakeClosure(0, clCopyAlist, clNULL_HOOK));
  (void) clCOPY_ALIST;
  clSetSymbolFunctionValue(clACONS,
                           clMakeClosure(0, clAcons, clNULL_HOOK));
  (void) clACONS;
  clSetSymbolFunctionValue(clPAIRLIS,
                           clMakeClosure(0, clPairlis, clNULL_HOOK));
  (void) clPAIRLIS;
  clSetSymbolFunctionValue(clRASSOC1,
                           clMakeClosure(0, clRassoc1, clNULL_HOOK));
  (void) clRASSOC1;
  clSetSymbolFunctionValue(clASSOC_IF,
                           clMakeClosure(0, clAssocIf, clNULL_HOOK));
  (void) clASSOC_IF;
  clSetSymbolFunctionValue(clASSOC_IF_NOT,
                           clMakeClosure(0,
                                         clAssocIfNot,
                                         clNULL_HOOK));
  (void) clASSOC_IF_NOT;
  clSetSymbolFunctionValue(clRASSOC,
                           clMakeClosure(0, clRassoc, clNULL_HOOK));
  (void) clRASSOC;
  clSetSymbolFunctionValue(clRASSOC_IF,
                           clMakeClosure(0, clRassocIf, clNULL_HOOK));
  (void) clRASSOC_IF;
  clSetSymbolFunctionValue(clRASSOC_IF_NOT,
                           clMakeClosure(0,
                                         clRassocIfNot,
                                         clNULL_HOOK));
  (void) clRASSOC_IF_NOT;
  clUnwind(4); }
