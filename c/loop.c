/* Generated by Eclipse Common Lisp 1.1-HOSTED for howard on circe.
   Friday the twentieth of March, 1998, 5:44:38 pm CST. */
#include <eclipse.h>

clObject clPLUS_FUNC(clProto), cl1PLUS_FUNC(clProto),
  cl1MINUS_FUNC(clProto), clAddLoopPath(clProto), clAdjoin(clProto),
  clAppend(clProto), clApply(clProto), clAssoc(clProto),
  clAtom(clProto), clBoundp(clProto), clCaadr(clProto),
  clCaar(clProto), clCadar(clProto), clCaddr(clProto), clCadr(clProto),
  clCanonicalizeSpecializer(clProto), clCar(clProto), clCddr(clProto),
  clCdr(clProto), clCharpSimpleBaseString __P((clCharp)),
  clCheckKeys(clProto), clCoerce(clProto), clCons(clProto),
  clConsp(clProto), clConstantp(clProto), clCopyList(clProto),
  clDeclarationInformation(clProto), clDelete(clProto),
  clDestructuringSize(clProto), clEndp(clProto),
  clEnsureGenericFunction(clProto), clEnsureMethod(clProto),
  clEq(clProto), clEql(clProto), clError(clProto),
  clEstimateCodeSize(clProto), clEstimateCodeSize1(clProto),
  clEval(clProto), clExtraArgs(clProto), clFind(clProto),
  clFindClass(clProto), clFirst(clProto), clFixnump(clProto),
  clFourth(clProto), clFuncall(clProto), clGensym(clProto),
  clGentemp(clProto), clGet(clProto),
  cl_SETF_GlobalDeclaration(clProto), clHideVariableReference(clProto),
  clKeyArg(clProto), clLast(clProto), clLength(clProto),
  clLevelStructurePrinter(clProto), clList(clProto),
  clListSTAR(clProto), clListp(clProto), clLoopBindBlock(clProto),
  clLoopCheckDataType(clProto),
  clLoopCodeDuplicationThreshold(clProto),
  clLoopCollectPrepositionalPhrases(clProto),
  clLoopCollectorClass(clProto), cl_SETF_LoopCollectorData(clProto),
  clLoopCollectorData(clProto), clLoopCollectorDtype(clProto),
  cl_SETF_LoopCollectorDtype(clProto),
  cl_SETF_LoopCollectorHistory(clProto),
  clLoopCollectorHistory(clProto), clLoopCollectorName(clProto),
  cl_SETF_LoopCollectorTempvars(clProto),
  clLoopCollectorTempvars(clProto),
  clLoopConstantFoldIfPossible(clProto), clLoopConstantp(clProto),
  clLoopConstructReturn(clProto), clLoopContext(clProto),
  clLoopDeclareVariable(clProto), clLoopDisallowConditional(clProto),
  clLoopEmitBody(clProto), clLoopEmitFinalValue(clProto),
  clLoopError(clProto), clLoopGentemp(clProto),
  clLoopGetCollectionInfo(clProto), clLoopGetForm(clProto),
  clLoopGetProgn(clProto), clLoopHackIteration(clProto),
  clLoopIterationDriver(clProto), clLoopListStep(clProto),
  clLoopLookupKeyword(clProto), clLoopMakeDesetq(clProto),
  clLoopMakeIterationVariable(clProto), clLoopMakePsetq(clProto),
  clLoopMakeVariable(clProto), clLoopMinimaxAnswerVariable(clProto),
  clLoopMinimaxFlagVariable(clProto),
  cl_SETF_LoopMinimaxFlagVariable(clProto),
  clLoopMinimaxInfinityData(clProto), clLoopMinimaxOperations(clProto),
  cl_SETF_LoopMinimaxOperations(clProto),
  clLoopMinimaxTempVariable(clProto), clLoopMinimaxType(clProto),
  clLoopNoteMinimaxOperation(clProto),
  clLoopOptimizationQuantities(clProto), clLoopOptionalType(clProto),
  clLoopPathFunction(clProto), clLoopPathInclusivePermitted(clProto),
  clLoopPathPrepositionGroups(clProto), clLoopPathUserData(clProto),
  clLoopPopSource(clProto), clLoopPseudoBody(clProto),
  clLoopSequencer(clProto), clLoopStandardExpansion(clProto),
  clLoopTassoc(clProto), clLoopTequal(clProto), clLoopTmember(clProto),
  clLoopTranslate(clProto), clLoopTypedInit(clProto),
  clLoopUniverseAnsi(clProto), clLoopUniverseForKeywords(clProto),
  clLoopUniverseImplicitForRequired(clProto),
  clLoopUniverseIterationKeywords(clProto),
  clLoopUniverseKeywords(clProto), clLoopUniversePathKeywords(clProto),
  clLoopUniverseTypeKeywords(clProto),
  clLoopUniverseTypeSymbols(clProto), clLoopWarn(clProto),
  clLoopWhenItVariable(clProto), cl_SETF_MacroFunction(clProto),
  clMacroexpand(clProto), clMacroexpand1(clProto),
  clMakeAnsiLoopUniverse(clProto), clMakeGeneralVector __P((clObject)),
  clMakeHashTable(clProto), clMakeKeyword(clProto),
  clMakeLoopCollector(clProto), clMakeLoopMinimax(clProto),
  clMakeLoopMinimaxInternal(clProto), clMakeLoopPath(clProto),
  clMakeLoopUniverse(clProto), clMakeStandardLoopUniverse(clProto),
  clMakeStructure(clProto), clMakeSymbol(clProto), clMapcan(clProto),
  clMapcar(clProto), clMissingArgs(clProto), clNamedVariable(clProto),
  clNconc(clProto), clNot(clProto), clNreconc(clProto),
  clNull(clProto), clRest(clProto), clRevappend(clProto),
  clSecond(clProto), clSpecialOperatorP(clProto), clString(clProto),
  clStringEQUAL(clProto), clStructref(clProto),
  cl_SETF_Structref(clProto), clSymbolFunction(clProto),
  clSymbolName(clProto), clSymbolp(clProto), clThird(clProto),
  clTypeOf(clProto), clValues(clProto), clWarn(clProto);

extern clObject clBIGNUM, clBIT_VECTOR, clBLOCK, clCOMPILATION_SPEED,
  clCOMPILED_FUNCTION, clCONS, clDEBUG, clDECLARE, clDOUBLE_FLOAT,
  clEQ, clFIXNUM, clGO, clIF, clIGNORE, clINTEGER, clKEYWORD, clLABELS,
  clLAMBDA, clLET, clLETstar, clLOCALLY, clLONG_FLOAT, clMACROLET,
  clNUMBER, clOPTIMIZE, clPROGN, clQUOTE, clRATIO, clREAL,
  clRETURN_FROM, clRPLACD, clSAFETY, clSEQUENCE, clSETQ, clSHORT_FLOAT,
  clSINGLE_FLOAT, clSPACE, clSPECIAL, clSPEED, clSTANDARD_CHAR,
  clSYMBOL, clSYMBOL_MACROLET, clSYMBOL_NAME, clTAGBODY, clTYPE,
  clUNWIND_PROTECT, clstarESTIMATE_CODE_SIZE_PUNTstar,
  clstarLOOP_AFTER_BODYstar, clstarLOOP_AFTER_EPILOGUEstar,
  clstarLOOP_ANSI_UNIVERSEstar, clstarLOOP_BEFORE_LOOPstar,
  clstarLOOP_BIND_STACKstar, clstarLOOP_BODYstar,
  clstarLOOP_COLLECTION_CRUFTstar, clstarLOOP_DECLARATIONSstar,
  clstarLOOP_DESETQ_CROCKSstar, clstarLOOP_DESETQ_TEMPORARYstar,
  clstarLOOP_DESTRUCTURING_HOOKSstar, clstarLOOP_DUPLICATE_CODEstar,
  clstarLOOP_EMITTED_BODYstar, clstarLOOP_EPILOGUEstar,
  clstarLOOP_FINAL_VALUE_CULPRITstar, clstarLOOP_GENTEMPstar,
  clstarLOOP_INSIDE_CONDITIONALstar,
  clstarLOOP_ITERATION_FLAG_VARIABLEstar,
  clstarLOOP_ITERATION_VARIABLESstar, clstarLOOP_MACRO_ENVIRONMENTstar,
  clstarLOOP_MINIMAX_TYPE_INFINITIES_ALISTstar,
  clstarLOOP_NAMED_VARIABLESstar, clstarLOOP_NAMESstar,
  clstarLOOP_NEVER_STEPPED_VARIABLEstar, clstarLOOP_NODECLAREstar,
  clstarLOOP_ORIGINAL_SOURCE_CODEstar, clstarLOOP_PROLOGUEstar,
  clstarLOOP_REAL_DATA_TYPEstar, clstarLOOP_SOURCE_CODEstar,
  clstarLOOP_SOURCE_CONTEXTstar, clstarLOOP_UNIVERSEstar,
  clstarLOOP_VARIABLESstar, clstarLOOP_WHEN_IT_VARIABLEstar,
  clstarLOOP_WRAPPERSstar, clstarSPECIAL_CODE_SIZESstar, clplussymbol,
  cl_symbol, cl1plussymbol, cl1_symbol, cllesssymbol,
  cllessequalsymbol, clequalsymbol, clgreatersymbol,
  clgreaterequalsymbol, clACROSS, clADD, clADD_LOOP_PATH, clALWAYS,
  clAND, clANSI, clANSWER_VARIABLE, clAPPEND, clAPPENDING, clAREF,
  clARRAY, clAS, clATOM, clBEING, clBELOW, clBIT, clCAAAAR, clCAAADR,
  clCAAAR, clCAADAR, clCAADDR, clCAADR, clCAAR, clCADAAR, clCADADR,
  clCADAR, clCADDAR, clCADDDR, clCADDR, clCADR, clCAR, clCDAAAR,
  clCDAADR, clCDAAR, clCDADAR, clCDADDR, clCDADR, clCDAR, clCDDAAR,
  clCDDADR, clCDDAR, clCDDDAR, clCDDDDR, clCDDDR, clCDDR, clCDR,
  clCHARACTER, clCLASS, clCLASS_PROTOTYPE, clCOLLECT, clCOLLECTING,
  clCOMPLEX, clCOND, clCOPY_LIST, clCOUNT, clCOUNTING, clDATA,
  clDESETQ, clDESTRUCTURING_BIND, clDESTRUCTURING_SIZE, clDO, clDOstar,
  clDOING, clDOLIST, clDOWNFROM, clDTYPE, clDUPLICATABLE_CODE_P,
  clELSE, clEND_LOOP, clENDP, clENSURE_STRUCTURE, clEQ_NUMBER, clEQUAL,
  clESTIMATE_CODE_SIZE, clESTIMATE_CODE_SIZE_1, clEXTERNAL_SYMBOL,
  clEXTERNAL_SYMBOLS, clFINALLY, clFLAG_VARIABLE, clFLET, clFLOAT,
  clFOR, clFOR_KEYWORDS, clFORMAT, clFROM, clFUNCALL, clFUNCTION,
  clGETHASH, clGLOBAL_VARIABLE, clGT, clHASH_KEY, clHASH_KEYS,
  clHASH_TABLE, clHASH_VALUE, clHASH_VALUES, clHIDE_VARIABLE_REFERENCE,
  clHIDE_VARIABLE_REFERENCES, clHISTORY, clIMPLICIT_FOR_REQUIRED, clIN,
  clINCLUSIVE_PERMITTED, clINDEX, clINFINITY_DATA, clINITIALLY, clINTO,
  clIT, clITERATION_KEYWORDS, clKEYWORDS, clLAST, clLE, clLENGTH,
  clLIST, clLISTstar, clLOOP, clLOOP_ACCUMULATE_MINIMAX_VALUE,
  clLOOP_ACROSS_INDEX_, clLOOP_ACROSS_LIMIT_, clLOOP_ACROSS_VECTOR_,
  clLOOP_ANSI_FOR_EQUALS, clLOOP_BIND_, clLOOP_BIND_BLOCK, clLOOP_BODY,
  clLOOP_CHECK_DATA_TYPE, clLOOP_CODE_DUPLICATION_THRESHOLD,
  clLOOP_COLLECT_ANSWER, clLOOP_COLLECT_PREPOSITIONAL_PHRASES,
  clLOOP_COLLECT_RPLACD, clLOOP_COLLECTOR, clLOOP_COLLECTOR_CLASS,
  clLOOP_COLLECTOR_DATA, clLOOP_COLLECTOR_DTYPE,
  clLOOP_COLLECTOR_HISTORY, clLOOP_COLLECTOR_NAME,
  clLOOP_COLLECTOR_TEMPVARS, clLOOP_CONSTANT_FOLD_IF_POSSIBLE,
  clLOOP_CONSTANTP, clLOOP_CONSTRUCT_RETURN, clLOOP_CONTEXT,
  clLOOP_COPYLISTstar, clLOOP_DECLARE_VARIABLE, clLOOP_DESTRUCTURE_,
  clLOOP_DISALLOW_CONDITIONAL, clLOOP_DO_ALWAYS, clLOOP_DO_DO,
  clLOOP_DO_FINALLY, clLOOP_DO_FOR, clLOOP_DO_IF, clLOOP_DO_INITIALLY,
  clLOOP_DO_NAMED, clLOOP_DO_REPEAT, clLOOP_DO_RETURN,
  clLOOP_DO_THEREIS, clLOOP_DO_WHILE, clLOOP_DO_WITH, clLOOP_EMIT_BODY,
  clLOOP_EMIT_FINAL_VALUE, clLOOP_ERROR, clLOOP_FINISH, clLOOP_FN_,
  clLOOP_FOR_ACROSS, clLOOP_FOR_ARITHMETIC, clLOOP_FOR_BEING,
  clLOOP_FOR_IN, clLOOP_FOR_ON, clLOOP_GENTEMP,
  clLOOP_GET_COLLECTION_INFO, clLOOP_GET_FORM, clLOOP_GET_PROGN,
  clLOOP_HACK_ITERATION, clLOOP_HASH_KEY_TEMP_,
  clLOOP_HASH_TABLE_ITERATION_PATH, clLOOP_HASH_VAL_TEMP_,
  clLOOP_HASHTAB_, clLOOP_HASHTAB_NEXT_, clLOOP_IGNORE_, clLOOP_IT_,
  clLOOP_ITERATION_DRIVER, clLOOP_LIMIT_, clLOOP_LIST_,
  clLOOP_LIST_COLLECTION, clLOOP_LIST_HEAD_, clLOOP_LIST_STEP,
  clLOOP_LIST_TAIL_, clLOOP_LOOKUP_KEYWORD, clLOOP_MAKE_DESETQ,
  clLOOP_MAKE_ITERATION_VARIABLE, clLOOP_MAKE_PSETQ,
  clLOOP_MAKE_VARIABLE, clLOOP_MAXMIN_, clLOOP_MAXMIN_COLLECTION,
  clLOOP_MAXMIN_FLAG_, clLOOP_MAXMIN_TEMP_, clLOOP_MAYBE_BIND_FORM,
  clLOOP_MINIMAX, clLOOP_MINIMAX_ANSWER_VARIABLE,
  clLOOP_MINIMAX_FLAG_VARIABLE, clLOOP_MINIMAX_INFINITY_DATA,
  clLOOP_MINIMAX_OPERATIONS, clLOOP_MINIMAX_TEMP_VARIABLE,
  clLOOP_MINIMAX_TYPE, clLOOP_NOTE_MINIMAX_OPERATION,
  clLOOP_OPTIMIZATION_QUANTITIES, clLOOP_OPTIONAL_TYPE,
  clLOOP_PACKAGE_SYMBOLS_ITERATION_PATH, clLOOP_PATH,
  clLOOP_PATH_FUNCTION, clLOOP_PATH_INCLUSIVE_PERMITTED,
  clLOOP_PATH_NAMES, clLOOP_PATH_PREPOSITION_GROUPS,
  clLOOP_PATH_USER_DATA, clLOOP_PKGSYM_, clLOOP_PKGSYM_NEXT_,
  clLOOP_POP_SOURCE, clLOOP_PSEUDO_BODY, clLOOP_REALLY_DESETQ,
  clLOOP_REPEAT_, clLOOP_SEQ_LIMIT_, clLOOP_SEQUENCE_ELEMENTS_PATH,
  clLOOP_SEQUENCER, clLOOP_STANDARD_EXPANSION, clLOOP_STEP_BY_,
  clLOOP_STORE_TABLE_DATA, clLOOP_SUM_, clLOOP_SUM_COLLECTION,
  clLOOP_TASSOC, clLOOP_TEQUAL, clLOOP_TMEMBER, clLOOP_TRANSLATE,
  clLOOP_TYPED_INIT, clLOOP_UNIVERSE, clLOOP_UNIVERSE_ANSI,
  clLOOP_UNIVERSE_FOR_KEYWORDS, clLOOP_UNIVERSE_IMPLICIT_FOR_REQUIRED,
  clLOOP_UNIVERSE_ITERATION_KEYWORDS, clLOOP_UNIVERSE_KEYWORDS,
  clLOOP_UNIVERSE_PATH_KEYWORDS, clLOOP_UNIVERSE_TYPE_KEYWORDS,
  clLOOP_UNIVERSE_TYPE_SYMBOLS, clLOOP_WARN, clLOOP_WHEN_IT_VARIABLE,
  clLOOPVAR_, clLT, clMAKE_ANSI_LOOP_UNIVERSE, clMAKE_LOOP_COLLECTOR,
  clMAKE_LOOP_MINIMAX, clMAKE_LOOP_MINIMAX_INTERNAL, clMAKE_LOOP_PATH,
  clMAKE_LOOP_UNIVERSE, clMAKE_STANDARD_LOOP_UNIVERSE, clMAX,
  clMAXIMIZE, clMAXIMIZING, clMAXMIN, clMEMBER, clMETHOD_FUNCTION,
  clMIN, clMINIMIZE, clMINIMIZING, clMINUSP, clMOST_NEGATIVE_FIXNUM,
  clMOST_POSITIVE_FIXNUM, clMULT, clMULTIPLE_VALUE_BIND,
  clMULTIPLE_VALUE_SETQ, clNAME, clNAMED, clNAMED_VARIABLE, clNAMES,
  clNCONC, clNCONCING, clNEVER, clNEXT_LOOP, clNO_NEXT_METHOD, clNOT,
  clNREVERSE, clNULL, clOF_TYPE, clON, clOPERATIONS, clOR, clPACKAGE,
  clPATH_KEYWORDS, clPATHNAME, clPLUSP, clPREPOSITION_GROUPS,
  clPRESENT_SYMBOL, clPRESENT_SYMBOLS, clPRINT_LOOP_UNIVERSE,
  clPRINT_OBJECT, clPROG, clPROGstar, clPROG1, clPSETQ, clRANDOM_STATE,
  clRATIONAL, clREADTABLE, clREPEAT, clRETURN, clREVERSE, clSETF,
  clSIMPLE_ARRAY, clSIMPLE_BIT_VECTOR, clSIMPLE_STRING,
  clSIMPLE_VECTOR, clSTANDARD_METHOD, clSTREAM, clSTRING,
  clSTRING_CHAR, clSTRINGequal, clSUBT, clSUBTYPEP, clSUM, clSUMMING,
  clSYMBOLS, clTEMP_VARIABLE, clTEMPVARS, clTHE, clTHEREIS, clTO,
  clTYPE_ERROR, clTYPE_KEYWORDS, clTYPE_SYMBOLS, clTYPEP, clUNLESS,
  clUNTIL, clUPFROM, clUPTO, clUSER_DATA, clUSING, clVECTOR, clWHEN,
  clWHILE, clWITH, clWITH_HASH_TABLE_ITERATOR,
  clWITH_LOOP_LIST_COLLECTION_HEAD, clWITH_MINIMAX_VALUE,
  clWITH_OPEN_FILE, clWITH_PACKAGE_ITERATOR;

static clObject A_49, C_Null, CONS_0, CONS_1, CONS_10, CONS_100,
  CONS_101, CONS_102, CONS_103, CONS_104, CONS_105, CONS_106, CONS_107,
  CONS_108, CONS_109, CONS_11, CONS_110, CONS_111, CONS_112, CONS_113,
  CONS_114, CONS_115, CONS_116, CONS_117, CONS_118, CONS_119, CONS_12,
  CONS_120, CONS_121, CONS_122, CONS_123, CONS_124, CONS_125, CONS_126,
  CONS_127, CONS_128, CONS_129, CONS_13, CONS_130, CONS_131, CONS_132,
  CONS_133, CONS_134, CONS_135, CONS_136, CONS_137, CONS_138, CONS_139,
  CONS_14, CONS_140, CONS_141, CONS_142, CONS_143, CONS_144, CONS_145,
  CONS_146, CONS_147, CONS_148, CONS_149, CONS_15, CONS_150, CONS_151,
  CONS_152, CONS_153, CONS_154, CONS_155, CONS_156, CONS_157, CONS_158,
  CONS_159, CONS_16, CONS_160, CONS_161, CONS_162, CONS_163, CONS_164,
  CONS_165, CONS_166, CONS_167, CONS_168, CONS_169, CONS_17, CONS_170,
  CONS_171, CONS_172, CONS_173, CONS_174, CONS_175, CONS_176, CONS_177,
  CONS_178, CONS_179, CONS_18, CONS_180, CONS_181, CONS_182, CONS_183,
  CONS_184, CONS_185, CONS_186, CONS_187, CONS_188, CONS_189, CONS_19,
  CONS_190, CONS_191, CONS_192, CONS_193, CONS_194, CONS_195, CONS_196,
  CONS_197, CONS_198, CONS_199, CONS_2, CONS_20, CONS_200, CONS_201,
  CONS_202, CONS_203, CONS_204, CONS_205, CONS_206, CONS_207, CONS_208,
  CONS_209, CONS_21, CONS_210, CONS_211, CONS_212, CONS_213, CONS_214,
  CONS_215, CONS_216, CONS_217, CONS_218, CONS_219, CONS_22, CONS_220,
  CONS_221, CONS_222, CONS_223, CONS_224, CONS_225, CONS_226, CONS_227,
  CONS_228, CONS_229, CONS_23, CONS_230, CONS_231, CONS_232, CONS_233,
  CONS_234, CONS_235, CONS_236, CONS_237, CONS_238, CONS_239, CONS_24,
  CONS_240, CONS_241, CONS_242, CONS_243, CONS_244, CONS_245, CONS_246,
  CONS_247, CONS_248, CONS_249, CONS_25, CONS_250, CONS_251, CONS_252,
  CONS_253, CONS_254, CONS_255, CONS_256, CONS_257, CONS_258, CONS_259,
  CONS_26, CONS_260, CONS_261, CONS_262, CONS_263, CONS_264, CONS_265,
  CONS_266, CONS_267, CONS_268, CONS_269, CONS_27, CONS_270, CONS_271,
  CONS_272, CONS_273, CONS_274, CONS_275, CONS_276, CONS_277, CONS_278,
  CONS_279, CONS_28, CONS_280, CONS_281, CONS_282, CONS_283, CONS_284,
  CONS_285, CONS_286, CONS_287, CONS_288, CONS_289, CONS_29, CONS_290,
  CONS_291, CONS_292, CONS_293, CONS_294, CONS_295, CONS_296, CONS_297,
  CONS_298, CONS_299, CONS_3, CONS_30, CONS_300, CONS_301, CONS_302,
  CONS_303, CONS_304, CONS_305, CONS_306, CONS_307, CONS_308, CONS_309,
  CONS_31, CONS_310, CONS_311, CONS_312, CONS_313, CONS_314, CONS_315,
  CONS_316, CONS_317, CONS_318, CONS_319, CONS_32, CONS_320, CONS_321,
  CONS_322, CONS_323, CONS_324, CONS_325, CONS_326, CONS_327, CONS_328,
  CONS_329, CONS_33, CONS_330, CONS_331, CONS_332, CONS_333, CONS_334,
  CONS_335, CONS_336, CONS_337, CONS_338, CONS_339, CONS_34, CONS_340,
  CONS_341, CONS_342, CONS_343, CONS_344, CONS_345, CONS_346, CONS_347,
  CONS_348, CONS_349, CONS_35, CONS_350, CONS_351, CONS_352, CONS_353,
  CONS_354, CONS_355, CONS_356, CONS_357, CONS_358, CONS_359, CONS_36,
  CONS_360, CONS_361, CONS_362, CONS_363, CONS_364, CONS_365, CONS_366,
  CONS_367, CONS_368, CONS_369, CONS_37, CONS_370, CONS_371, CONS_372,
  CONS_373, CONS_374, CONS_375, CONS_376, CONS_377, CONS_378, CONS_379,
  CONS_38, CONS_380, CONS_381, CONS_382, CONS_383, CONS_384, CONS_385,
  CONS_386, CONS_387, CONS_388, CONS_389, CONS_39, CONS_390, CONS_391,
  CONS_392, CONS_393, CONS_394, CONS_395, CONS_396, CONS_397, CONS_398,
  CONS_399, CONS_4, CONS_40, CONS_400, CONS_401, CONS_402, CONS_403,
  CONS_404, CONS_405, CONS_406, CONS_407, CONS_408, CONS_409, CONS_41,
  CONS_410, CONS_411, CONS_412, CONS_413, CONS_414, CONS_415, CONS_416,
  CONS_417, CONS_418, CONS_419, CONS_42, CONS_420, CONS_421, CONS_422,
  CONS_423, CONS_424, CONS_425, CONS_426, CONS_427, CONS_428, CONS_429,
  CONS_43, CONS_430, CONS_431, CONS_432, CONS_433, CONS_434, CONS_435,
  CONS_436, CONS_437, CONS_438, CONS_439, CONS_44, CONS_440, CONS_441,
  CONS_442, CONS_443, CONS_444, CONS_445, CONS_446, CONS_447, CONS_448,
  CONS_449, CONS_45, CONS_450, CONS_451, CONS_452, CONS_453, CONS_454,
  CONS_455, CONS_456, CONS_457, CONS_458, CONS_459, CONS_46, CONS_460,
  CONS_461, CONS_462, CONS_463, CONS_464, CONS_465, CONS_466, CONS_467,
  CONS_468, CONS_469, CONS_47, CONS_470, CONS_471, CONS_472, CONS_473,
  CONS_474, CONS_475, CONS_476, CONS_477, CONS_478, CONS_479, CONS_48,
  CONS_480, CONS_481, CONS_482, CONS_483, CONS_484, CONS_485, CONS_486,
  CONS_487, CONS_488, CONS_489, CONS_49, CONS_490, CONS_491, CONS_492,
  CONS_493, CONS_494, CONS_495, CONS_496, CONS_497, CONS_498, CONS_499,
  CONS_5, CONS_50, CONS_500, CONS_501, CONS_502, CONS_503, CONS_504,
  CONS_505, CONS_506, CONS_507, CONS_508, CONS_509, CONS_51, CONS_510,
  CONS_511, CONS_512, CONS_513, CONS_514, CONS_515, CONS_516, CONS_517,
  CONS_518, CONS_519, CONS_52, CONS_520, CONS_521, CONS_522, CONS_523,
  CONS_524, CONS_525, CONS_526, CONS_527, CONS_528, CONS_529, CONS_53,
  CONS_530, CONS_531, CONS_532, CONS_533, CONS_534, CONS_535, CONS_536,
  CONS_537, CONS_538, CONS_539, CONS_54, CONS_540, CONS_541, CONS_542,
  CONS_543, CONS_544, CONS_545, CONS_546, CONS_547, CONS_548, CONS_549,
  CONS_55, CONS_550, CONS_551, CONS_552, CONS_553, CONS_554, CONS_555,
  CONS_556, CONS_557, CONS_558, CONS_559, CONS_56, CONS_560, CONS_561,
  CONS_562, CONS_563, CONS_564, CONS_565, CONS_566, CONS_567, CONS_568,
  CONS_569, CONS_57, CONS_570, CONS_571, CONS_572, CONS_573, CONS_574,
  CONS_575, CONS_576, CONS_577, CONS_578, CONS_579, CONS_58, CONS_580,
  CONS_581, CONS_582, CONS_583, CONS_584, CONS_585, CONS_586, CONS_587,
  CONS_588, CONS_589, CONS_59, CONS_590, CONS_591, CONS_592, CONS_593,
  CONS_594, CONS_595, CONS_596, CONS_597, CONS_598, CONS_599, CONS_6,
  CONS_60, CONS_600, CONS_601, CONS_602, CONS_603, CONS_604, CONS_605,
  CONS_606, CONS_607, CONS_608, CONS_61, CONS_62, CONS_63, CONS_64,
  CONS_65, CONS_66, CONS_67, CONS_68, CONS_69, CONS_7, CONS_70,
  CONS_71, CONS_72, CONS_73, CONS_74, CONS_75, CONS_76, CONS_77,
  CONS_78, CONS_79, CONS_8, CONS_80, CONS_81, CONS_82, CONS_83,
  CONS_84, CONS_85, CONS_86, CONS_87, CONS_88, CONS_89, CONS_9,
  CONS_90, CONS_91, CONS_92, CONS_93, CONS_94, CONS_95, CONS_96,
  CONS_97, CONS_98, CONS_99, I_0, I_1, I_10, I_2, I_3, I_4, I_40, I_5,
  I_6, I_7, I_8, I_9, keyequalsymbol, keyABOVE, keyAND, keyANSI,
  keyANSWER_VARIABLE, keyBELOW, keyBY, keyCLASS, keyCONSTRUCTORS,
  keyCOPIER, keyDATA, keyDATUM, keyDECLARATIONS, keyDIRECT_SLOTS,
  keyDOCUMENTATION, keyDOWN, keyDOWNFROM, keyDOWNTO, keyDTYPE, keyEACH,
  keyELEMENT_TYPE, keyELSE, keyEND, keyEXPECTED_TYPE, keyEXTENDED,
  keyEXTERNAL, keyFETCH_FUNCTION, keyFINALLY, keyFLAG_VARIABLE,
  keyFOR_KEYWORDS, keyFROM, keyFUNCTION, keyHER, keyHIS, keyHISTORY,
  keyIMPLICIT_FOR_REQUIRED, keyIN, keyINCLUSIVE,
  keyINCLUSIVE_PERMITTED, keyINFINITY_DATA, keyINHERITED, keyINITFORM,
  keyINITIALLY, keyINTERNAL, keyITERATION_KEYWORDS, keyITS, keyKEY,
  keyKEYWORDS, keyLAMBDA_LIST, keyNAME, keyNAMES, keyOF, keyOPERATIONS,
  keyPATH_KEYWORDS, keyPREDICATE, keyPREPOSITION_GROUPS, keyQUALIFIERS,
  keyREAD_ONLY, keySEQUENCE_TYPE, keySIZE, keySIZE_FUNCTION,
  keySPECIALIZERS, keySYMBOL_TYPES, keyTEMP_VARIABLE, keyTEMPVARS,
  keyTEST, keyTHE, keyTHEN, keyTO, keyTYPE, keyTYPE_KEYWORDS,
  keyTYPE_SYMBOLS, keyUNTIL, keyUP, keyUPFROM, keyUPTO, keyUSER_DATA,
  keyWHICH, keyWHILE, keyWITH, STR_hashlesstildeS_tildeAgreater__33,
  STR_equal__79, STR_ABOVE__116, STR_AND__59, STR_ANSI__28,
  STR_ANSWER_VARIABLE__5, STR_BELOW__117, STR_BY__83, STR_CLASS__69,
  STR_CONSTRUCTORS__0, STR_COPIER__1, STR_DATA__73, STR_DATUM__12,
  STR_DECLARATIONS__20, STR_DIRECT_SLOTS__3, STR_DOCUMENTATION__21,
  STR_DOWNFROM__109, STR_DOWNTO__115, STR_DOWN__111, STR_DTYPE__72,
  STR_EACH__89, STR_ELEMENT_TYPE__125, STR_ELSE__60, STR_END__61,
  STR_EXPECTED_TYPE__13, STR_EXTENDED__31, STR_EXTERNAL__134,
  STR_Extended_ANSI__32, STR_FETCH_FUNCTION__122, STR_FINALLY__63,
  STR_FLAG_VARIABLE__8, STR_FOR_KEYWORDS__24, STR_FROM__108,
  STR_FUNCTION__19, STR_HER__93, STR_HISTORY__70, STR_HIS__92,
  STR_INCLUSIVE_PERMITTED__87, STR_INCLUSIVE__100,
  STR_INFINITY_DATA__10, STR_INHERITED__135, STR_INITFORM__67,
  STR_INITIALLY__62, STR_INTERNAL__133, STR_IN__95,
  STR_ITERATION_KEYWORDS__23, STR_ITS__91, STR_KEYWORDS__22,
  STR_KEY__75, STR_LAMBDA_LIST__15, STR_LOOP_DESETQ_TEMP__35,
  STR_LOOP_NOT_FIRST_TIME__37, STR_LOOP__136, STR_NAMES__85,
  STR_NAME__4, STR_Non_ANSI__30, STR_OBJECT2__16, STR_OF__107,
  STR_OPERATIONS__9, STR_PATH_KEYWORDS__25, STR_PREDICATE__2,
  STR_PREPOSITION_GROUPS__86, STR_QUALIFIERS__14, STR_READ_ONLY__68,
  STR_SEQUENCE_TYPE__124, STR_SIZE_FUNCTION__123, STR_SIZE__34,
  STR_SPECIALIZERS__18, STR_STREAM3__17, STR_SYMBOL_TYPES__129,
  STR_TEMP_VARIABLE__7, STR_TEMPVARS__71, STR_TEST__11, STR_THEN__82,
  STR_THE__90, STR_TO__114, STR_TYPE_KEYWORDS__27,
  STR_TYPE_SYMBOLS__26, STR_TYPE__6, STR_UNTIL__132, STR_UPFROM__110,
  STR_UPTO__113, STR_UP__112, STR_USER_DATA__88, STR_WHICH__126,
  STR_WHILE__131, STR_WITH__78, STRn_101, STRn_102, STRn_103, STRn_104,
  STRn_105, STRn_106, STRn_118, STRn_119, STRn_120, STRn_121, STRn_127,
  STRn_128, STRn_130, STRn_29, STRn_36, STRn_38, STRn_39, STRn_40,
  STRn_41, STRn_42, STRn_43, STRn_44, STRn_45, STRn_46, STRn_47,
  STRn_48, STRn_49, STRn_50, STRn_51, STRn_52, STRn_53, STRn_54,
  STRn_55, STRn_56, STRn_57, STRn_58, STRn_64, STRn_65, STRn_66,
  STRn_74, STRn_76, STRn_77, STRn_80, STRn_81, STRn_84, STRn_94,
  STRn_96, STRn_97, STRn_98, STRn_99, SYM_0_OBJECT2, SYM_0_STREAM3;

clObject clLoopCopylistSTAR clVdecl(_ap)
{ clObject L_form, L_ignored, l;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top59;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top59, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(l, L_top59); }
    else clSetq(l, clMissingArgs(I_1, clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  return(clList(clCOPY_LIST, l, clEOA)); }

clObject clLoopGentemp clVdecl(_ap)
{ clObject pref;
  { clBeginParse(_ap);
    clSetq(pref, (_clVp(_ap) ? clVpop(_ap) : clLOOPVAR_));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolValue(clstarLOOP_GENTEMPstar, clEOA)))
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, pref);
        clSetq(L_0, clString(L_0__R1, clEOA)); }
      return(clGentemp(L_0, clEOA)); }
  else return(clGensym(clEOA)); }

clObject clLoopOptimizationQuantities clVdecl(_ap)
{ clObject env;
  { clBeginParse(_ap);
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject stuff;
    clSetq(stuff, clDeclarationInformation(clOPTIMIZE, env, clEOA));
    { clObject L_4, L_3, L_2, L_1, L_0;
      { clObject L_g68;
        clSetq(L_g68, clCdr(clAssoc(clSPEED, stuff, clEOA), clEOA));
        clSetq(L_0, (clTrue(L_g68) ? L_g68 : I_1)); }
      { clObject L_g69;
        clSetq(L_g69, clCdr(clAssoc(clSPACE, stuff, clEOA), clEOA));
        clSetq(L_1, (clTrue(L_g69) ? L_g69 : I_1)); }
      { clObject L_g70;
        clSetq(L_g70, clCdr(clAssoc(clSAFETY, stuff, clEOA), clEOA));
        clSetq(L_2, (clTrue(L_g70) ? L_g70 : I_1)); }
      { clObject L_g71;
        clSetq(L_g71,
               clCdr(clAssoc(clCOMPILATION_SPEED, stuff, clEOA),
                     clEOA));
        clSetq(L_3, (clTrue(L_g71) ? L_g71 : I_1)); }
      { clObject L_g72;
        clSetq(L_g72, clCdr(clAssoc(clDEBUG, stuff, clEOA), clEOA));
        clSetq(L_4, (clTrue(L_g72) ? L_g72 : I_1)); }
      clValues(L_0, L_1, L_2, L_3, L_4, clEOA); } }
  return(clValues(I_1, I_1, I_1, I_1, I_1, clEOA)); }

clObject clHideVariableReferences clVdecl(_ap)
{ clObject variable_list, form;
  { clBeginParse(_ap);
    clSetq(variable_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(form)); }

clObject clHideVariableReference clVdecl(_ap)
{ clObject really_hide, variable, form;
  { clBeginParse(_ap);
    clSetq(really_hide,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(form)); }

clObject clWithLoopListCollectionHead clVdecl(_ap)
{ clObject L_form, L_ignored, L_g73, head_var, tail_var, user_head_var,
  body;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top76;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top76, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(L_g73, L_top76); }
    else clSetq(L_g73, clMissingArgs(I_1, clEOA));
    if (clTrue(L_g73))
      { clObject L_top77;
        clSetq(L_top77, clCar(L_g73, clEOA));
        { clObject L_0;
          clSetq(L_0, L_g73);
          clSetq(L_g73, clCdr(L_0, clEOA)); }
        clSetq(head_var, L_top77); }
    else clSetq(head_var, clMissingArgs(I_2, clEOA));
    if (clTrue(L_g73))
      { clObject L_top78;
        { clObject L_0;
          clSetq(L_0, L_g73);
          clSetq(L_top78, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_g73);
          clSetq(L_g73, clCdr(L_0, clEOA)); }
        clSetq(tail_var, L_top78); }
    else clSetq(tail_var, clMissingArgs(I_3, clEOA));
    if (clTrue(L_g73))
      { clObject L_top79;
        { clObject L_0;
          clSetq(L_0, L_g73);
          clSetq(L_top79, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_g73);
          clSetq(L_g73, clCdr(L_0, clEOA)); }
        clSetq(user_head_var, L_top79); }
    else clSetq(user_head_var, clNIL);
    clSetq(body, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_g73))
    { clObject L_0; clSetq(L_0, L_g73); clExtraArgs(L_0, clEOA); }
  { clObject l;
    if (clTrue(user_head_var))
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, user_head_var);
          clSetq(L_0, clList(L_0__R1, clNIL, clEOA)); }
        clSetq(l, clList(L_0, clEOA)); }
    else clSetq(l, clNIL);
    { clObject L_1;
      { clObject L_2__R1, L_1__R1, L_0__R1;
        clSetq(L_0__R1, clListSTAR(head_var, CONS_0, clEOA));
        clSetq(L_1__R1, clList(tail_var, head_var, clEOA));
        clSetq(L_2__R1, l);
        clSetq(L_1, clListSTAR(L_0__R1, L_1__R1, L_2__R1, clEOA)); }
      return(clListSTAR(clLETstar, L_1, body, clEOA)); } } }

static clObject clLoopCollectRplacd_CdrWrap clVdecl(_ap)
{ clObject form, n;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(n, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clLabel(l_ITERATE88);
    if (clTrue(clFuncallFunction(clSymbolFunctionValue(clLE),
                                 n,
                                 I_4,
                                 clEOA)))
      { clObject L_1, L_0;
        clSetq(L_0,
               (_clEq(n, I_1) ? clCDR :
                (_clEq(n, I_2) ? clCDDR :
                 (_clEq(n, I_3) ? clCDDDR :
                  (_clEq(n, I_4) ? clCDDDDR : clNIL)))));
        clSetq(L_1, form);
        return(clValues1(clSetq(form, clList(L_0, L_1, clEOA)))); }
    { clObject L_1;
      clSetq(L_1, form);
      clSetq(form, clList(clCDDDDR, L_1, clEOA)); }
    { clObject L_0;
      clSetq(L_0, n);
      clSetq(n,
             clFuncallFunction(clSymbolFunctionValue(clSUBT),
                               L_0,
                               I_4,
                               clEOA)); }
    goto l_ITERATE88; } }

clObject clLoopCollectRplacd clVdecl(_ap)
{ clObject L_form, env, L_g80, head_var, tail_var, user_head_var, form;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top83;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top83, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(L_g80, L_top83); }
    else clSetq(L_g80, clMissingArgs(I_1, clEOA));
    if (clTrue(L_g80))
      { clObject L_top84;
        clSetq(L_top84, clCar(L_g80, clEOA));
        { clObject L_0;
          clSetq(L_0, L_g80);
          clSetq(L_g80, clCdr(L_0, clEOA)); }
        clSetq(head_var, L_top84); }
    else clSetq(head_var, clMissingArgs(I_2, clEOA));
    if (clTrue(L_g80))
      { clObject L_top85;
        { clObject L_0;
          clSetq(L_0, L_g80);
          clSetq(L_top85, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_g80);
          clSetq(L_g80, clCdr(L_0, clEOA)); }
        clSetq(tail_var, L_top85); }
    else clSetq(tail_var, clMissingArgs(I_3, clEOA));
    if (clTrue(L_g80))
      { clObject L_top86;
        { clObject L_0;
          clSetq(L_0, L_g80);
          clSetq(L_top86, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_g80);
          clSetq(L_g80, clCdr(L_0, clEOA)); }
        clSetq(user_head_var, L_top86); }
    else clSetq(user_head_var, clNIL);
    if (clTrue(L_form))
      { clObject L_top87;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top87, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(form, L_top87); }
    else clSetq(form, clMissingArgs(I_5, clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_g80))
    { clObject L_0; clSetq(L_0, L_g80); clExtraArgs(L_0, clEOA); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  { clObject L_0;
    clSetq(L_0, form);
    clSetq(form, clMacroexpand(L_0, env, clEOA)); }
  { clObject _CdrWrap_;
    clSetq(_CdrWrap_,
           clMakeClosure(0, clLoopCollectRplacd_CdrWrap, clNULL_HOOK));
    { clObject tail_form, ncdrs;
      clSetq(tail_form, form);
      clSetq(ncdrs, clNIL);
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, form);
          clSetq(L_test, clConsp(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_test__R1;
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, form);
                clSetq(L_0, clCar(L_0__R1, clEOA)); }
              clSetq(L_test__R1, clEq(L_0, clLIST, clEOA)); }
            if (clTrue(L_test__R1))
              { clObject L_0;
                { clObject L_0__R1;
                  { clObject L_0__R2;
                    clSetq(L_0__R2, form);
                    clSetq(L_0__R1, clCdr(L_0__R2, clEOA)); }
                  clSetq(L_0, clLength(L_0__R1, clEOA)); }
                clSetq(ncdrs, cl1MINUS_FUNC(L_0, clEOA)); }
            else
              { clObject L_test__R2;
                { clObject L_item90;
                  { clObject L_0;
                    clSetq(L_0, form);
                    clSetq(L_item90, clCar(L_0, clEOA)); }
                  clSetq(L_test__R2,
                         (_clEq(L_item90, clLISTstar) ?
                          CONS_3 :
                          (_clEq(L_item90, clCONS) ?
                           CONS_4 :
                           clNIL))); }
                if (clTrue(L_test__R2))
                  { clObject L_test__R3;
                    { clObject L_test__R4;
                      { clObject L_0;
                        clSetq(L_0, form);
                        clSetq(L_test__R4, clCddr(L_0, clEOA)); }
                      if (clTrue(L_test__R4))
                      { clObject L_item91;
                        { clObject L_0;
                          { clObject L_0__R1;
                            clSetq(L_0__R1, form);
                            clSetq(L_0, clLast(L_0__R1, clEOA)); }
                          clSetq(L_item91, clCar(L_0, clEOA)); }
                        clSetq(L_test__R3,
                               (_clEq(L_item91, clNIL) ?
                                CONS_5 :
                                (_clEq(L_item91, CONS_7) ?
                                 CONS_6 :
                                 clNIL))); }
                      else
                      clSetq(L_test__R3, clNIL); }
                    if (clTrue(L_test__R3))
                      { clObject L_0;
                        { clObject L_0__R1;
                          { clObject L_0__R2;
                            clSetq(L_0__R2, form);
                            clSetq(L_0__R1, clCdr(L_0__R2, clEOA)); }
                          clSetq(L_0, clLength(L_0__R1, clEOA)); }
                        clSetq(ncdrs,
                               clFuncallFunction(clSymbolFunctionValue(clSUBT),
                                                 L_0,
                                                 I_2,
                                                 clEOA)); } } } } }
      { clObject answer;
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, ncdrs);
            clSetq(L_test, clNull(L_0, clEOA)); }
          if (clTrue(L_test))
            { clObject L_1;
              { clObject L_1__R1;
                clSetq(L_1__R1, clList(clCDR, tail_var, clEOA));
                clSetq(L_1,
                       clList(clSETF, L_1__R1, tail_form, clEOA)); }
              clSetq(answer,
                     clList(clWHEN,
                            L_1,
                            clList(clSETQ,
                                   tail_var,
                                   clList(clLAST,
                                          clList(clCDR,
                                                 tail_var,
                                                 clEOA),
                                          clEOA),
                                   clEOA),
                            clEOA)); }
          else
            { clObject L_test__R1;
              { clObject L_0;
                clSetq(L_0, ncdrs);
                clSetq(L_test__R1,
                       clFuncallFunction(clSymbolFunctionValue(clLT),
                                         L_0,
                                         I_0,
                                         clEOA)); }
              if (clTrue(L_test__R1))
                return(clValues1(clNIL));
              else
                { clObject L_test__R2;
                  { clObject L_0;
                    clSetq(L_0, ncdrs);
                    clSetq(L_test__R2,
                           clFuncallFunction(clSymbolFunctionValue(clEQ_NUMBER),
                                             L_0,
                                             I_0,
                                             clEOA)); }
                  if (clTrue(L_test__R2))
                    clSetq(answer,
                           clList(clRPLACD,
                                  tail_var,
                                  clList(clSETQ,
                                         tail_var,
                                         tail_form,
                                         clEOA),
                                  clEOA));
                  else
                    { clObject L_2;
                      { clObject L_1__R1, L_0__R1;
                        { clObject L_1__R2;
                          clSetq(L_1__R2,
                                 clList(clCDR, tail_var, clEOA));
                          clSetq(L_0__R1,
                                 clList(clSETF,
                                        L_1__R2,
                                        tail_form,
                                        clEOA)); }
                        clSetq(L_1__R1, ncdrs);
                        clSetq(L_2,
                               clFuncallFunction(_CdrWrap_,
                                                 L_0__R1,
                                                 L_1__R1,
                                                 clEOA)); }
                      clSetq(answer,
                             clList(clSETQ,
                                    tail_var,
                                    L_2,
                                    clEOA)); } } } }
        if (clTrue(user_head_var))
          { clObject L_2, L_1;
            clSetq(L_1, answer);
            { clObject L_1__R1;
              clSetq(L_1__R1, user_head_var);
              clSetq(L_2,
                     clList(clSETQ,
                            L_1__R1,
                            clList(clCDR, head_var, clEOA),
                            clEOA)); }
            clSetq(answer, clList(clPROGN, L_1, L_2, clEOA)); }
        return(clValues1(answer)); } } } }

clObject clLoopCollectAnswer clVdecl(_ap)
{ clObject L_form, L_ignored, head_var, user_head_var;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top94;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top94, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(head_var, L_top94); }
    else clSetq(head_var, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form))
      { clObject L_top95;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top95, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(user_head_var, L_top95); }
    else clSetq(user_head_var, clNIL);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  { clObject L_g96;
    clSetq(L_g96, user_head_var);
    if (clTrue(L_g96))
      return(clValues1(L_g96));
    else return(clList(clCDR, head_var, clEOA)); } }

clObject clMakeLoopMinimaxInternal clVdecl(_ap)
{ clObject L_ap, L_keys, L_answer_variable, L_type, L_temp_variable,
  L_flag_variable, L_operations, L_infinity_data;
  { clBeginParse(_ap);
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyANSWER_VARIABLE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_answer_variable, clCar(L_0, clEOA)); }
    else clSetq(L_answer_variable, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTYPE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_type, clCar(L_0, clEOA)); }
    else clSetq(L_type, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyTEMP_VARIABLE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_temp_variable, clCar(L_0, clEOA)); }
    else clSetq(L_temp_variable, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyFLAG_VARIABLE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_flag_variable, clCar(L_0, clEOA)); }
    else clSetq(L_flag_variable, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyOPERATIONS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_operations, clCar(L_0, clEOA)); }
    else clSetq(L_operations, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyINFINITY_DATA, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_infinity_data, clCar(L_0, clEOA)); }
    else clSetq(L_infinity_data, clNIL);
    clCheckKeys(L_keys, CONS_36, clEOA);
    clEndParse(_ap); }
  { clObject L_6, L_5, L_4, L_3, L_2, L_1;
    clSetq(L_1, L_answer_variable);
    clSetq(L_2, L_type);
    clSetq(L_3, L_temp_variable);
    clSetq(L_4, L_flag_variable);
    clSetq(L_5, L_operations);
    clSetq(L_6, L_infinity_data);
    return(clMakeStructure(clLOOP_MINIMAX,
                           L_1,
                           L_2,
                           L_3,
                           L_4,
                           L_5,
                           L_6,
                           clEOA)); } }

clObject clLoopMinimaxAnswerVariable clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_0, clEOA)); }

clObject cl_SETF_LoopMinimaxAnswerVariable clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_0, clEOA)); }

clObject clLoopMinimaxType clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_1, clEOA)); }

clObject cl_SETF_LoopMinimaxType clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_1, clEOA)); }

clObject clLoopMinimaxTempVariable clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_2, clEOA)); }

clObject cl_SETF_LoopMinimaxTempVariable clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_2, clEOA)); }

clObject clLoopMinimaxFlagVariable clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_3, clEOA)); }

clObject cl_SETF_LoopMinimaxFlagVariable clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_3, clEOA)); }

clObject clLoopMinimaxOperations clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_4, clEOA)); }

clObject cl_SETF_LoopMinimaxOperations clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_4, clEOA)); }

clObject clLoopMinimaxInfinityData clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_5, clEOA)); }

clObject cl_SETF_LoopMinimaxInfinityData clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_5, clEOA)); }

clObject clMakeLoopMinimax clVdecl(_ap)
{ clObject answer_variable, type;
  { clBeginParse(_ap);
    clSetq(answer_variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject infinity_data;
    { clObject L_0;
      { clObject L_1;
        clSetq(L_1,
               clSymbolValue(clstarLOOP_MINIMAX_TYPE_INFINITIES_ALISTstar,
                             clEOA));
        clSetq(L_0,
               clAssoc(type,
                       L_1,
                       keyTEST,
                       clSymbolFunctionValue(clSUBTYPEP),
                       clEOA)); }
      clSetq(infinity_data, clCdr(L_0, clEOA)); }
    { clObject L_7, L_5;
      clSetq(L_5, clLoopGentemp(clLOOP_MAXMIN_TEMP_, clEOA));
      clSetq(L_7,
             (clTrue(clNot(infinity_data, clEOA)) ?
              clLoopGentemp(clLOOP_MAXMIN_FLAG_, clEOA) : clNIL));
      return(clMakeLoopMinimaxInternal(keyANSWER_VARIABLE,
                                       answer_variable,
                                       keyTYPE,
                                       type,
                                       keyTEMP_VARIABLE,
                                       L_5,
                                       keyFLAG_VARIABLE,
                                       L_7,
                                       keyOPERATIONS,
                                       clNIL,
                                       keyINFINITY_DATA,
                                       infinity_data,
                                       clEOA)); } } }

clObject clLoopNoteMinimaxOperation clVdecl(_ap)
{ clObject operation, minimax;
  { clBeginParse(_ap);
    clSetq(operation,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(minimax,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_value119;
    clSetq(L_value119,
           clAdjoin(operation, clLoopMinimaxOperations(minimax, clEOA),
                    clEOA));
    cl_SETF_LoopMinimaxOperations(L_value119, minimax, clEOA); }
  if (clTrue((clTrue(clCdr(clLoopMinimaxOperations(minimax, clEOA),
                           clEOA)) ?
              clNot(clLoopMinimaxFlagVariable(minimax, clEOA), clEOA) :
              clNIL)))
    { clObject L_value121;
      clSetq(L_value121, clLoopGentemp(clLOOP_MAXMIN_FLAG_, clEOA));
      cl_SETF_LoopMinimaxFlagVariable(L_value121, minimax, clEOA); }
  return(clValues1(operation)); }

clObject clWithMinimaxValue clVdecl(_ap)
{ clObject L_form, L_ignored, lm, body;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top125;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top125, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(lm, L_top125); }
    else clSetq(lm, clMissingArgs(I_1, clEOA));
    clSetq(body, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject init, which, infinity_data, answer_var, temp_var,
    flag_var, type;
    clSetq(init, clLoopTypedInit(clLoopMinimaxType(lm, clEOA), clEOA));
    clSetq(which, clCar(clLoopMinimaxOperations(lm, clEOA), clEOA));
    clSetq(infinity_data, clLoopMinimaxInfinityData(lm, clEOA));
    clSetq(answer_var, clLoopMinimaxAnswerVariable(lm, clEOA));
    clSetq(temp_var, clLoopMinimaxTempVariable(lm, clEOA));
    clSetq(flag_var, clLoopMinimaxFlagVariable(lm, clEOA));
    clSetq(type, clLoopMinimaxType(lm, clEOA));
    if (clTrue(flag_var))
      { clObject L_2, L_1;
        { clObject L_1__R1, L_0__R1;
          clSetq(L_0__R1, clList(answer_var, init, clEOA));
          clSetq(L_1__R1, clList(temp_var, init, clEOA));
          clSetq(L_1,
                 clList(L_0__R1,
                        L_1__R1,
                        clListSTAR(flag_var, CONS_2, clEOA),
                        clEOA)); }
        clSetq(L_2,
               clList(clDECLARE,
                      clList(clTYPE,
                             type,
                             answer_var,
                             temp_var,
                             clEOA),
                      clEOA));
        return(clListSTAR(clLET, L_1, L_2, body, clEOA)); }
    else
      { clObject L_2, L_1;
        { clObject L_0__R1;
          { clObject L_1__R2;
            clSetq(L_1__R2,
                   (_clEq(which, clMIN) ?
                    clFirst(infinity_data, clEOA) :
                    clSecond(infinity_data, clEOA)));
            clSetq(L_0__R1, clList(answer_var, L_1__R2, clEOA)); }
          clSetq(L_1,
                 clList(L_0__R1,
                        clList(temp_var, init, clEOA),
                        clEOA)); }
        clSetq(L_2,
               clList(clDECLARE,
                      clList(clTYPE,
                             type,
                             answer_var,
                             temp_var,
                             clEOA),
                      clEOA));
        return(clListSTAR(clLET, L_1, L_2, body, clEOA)); } } }

clObject clLoopAccumulateMinimaxValue clVdecl(_ap)
{ clObject L_form, L_ignored, lm, operation, form;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top128;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top128, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(lm, L_top128); }
    else clSetq(lm, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form))
      { clObject L_top129;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top129, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(operation, L_top129); }
    else clSetq(operation, clMissingArgs(I_2, clEOA));
    if (clTrue(L_form))
      { clObject L_top130;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top130, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(form, L_top130); }
    else clSetq(form, clMissingArgs(I_3, clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  { clObject answer_var, temp_var, flag_var, test;
    clSetq(answer_var, clLoopMinimaxAnswerVariable(lm, clEOA));
    clSetq(temp_var, clLoopMinimaxTempVariable(lm, clEOA));
    clSetq(flag_var, clLoopMinimaxFlagVariable(lm, clEOA));
    { clObject L_2, L_1;
      clSetq(L_1, clLoopMinimaxAnswerVariable(lm, clEOA));
      { clObject L_0__R1;
        clSetq(L_0__R1,
               (_clEq(operation, clMIN) ? cllesssymbol :
                (_clEq(operation, clMAX) ? clgreatersymbol :
                 clError(clTYPE_ERROR,
                         keyDATUM,
                         operation,
                         keyEXPECTED_TYPE,
                         CONS_58,
                         clEOA))));
        clSetq(L_2, clList(L_0__R1, temp_var, answer_var, clEOA)); }
      clSetq(test, clHideVariableReference(clT, L_1, L_2, clEOA)); }
    { clObject L_2, L_1;
      clSetq(L_1, clList(clSETQ, temp_var, form, clEOA));
      { clObject L_2__R1, L_1__R1;
        if (clTrue(flag_var))
          { clObject L_1__R2;
            clSetq(L_1__R2, clList(clNOT, flag_var, clEOA));
            clSetq(L_1__R1, clList(clOR, L_1__R2, test, clEOA)); }
        else clSetq(L_1__R1, test);
        { clObject L_1__R2;
          { clObject L_0__R3;
            clSetq(L_0__R3,
                   (clTrue(flag_var) ?
                    clListSTAR(flag_var, CONS_61, clEOA) : clNIL));
            clSetq(L_1__R2,
                   clAppend(L_0__R3,
                            clList(answer_var, temp_var, clEOA),
                            clEOA)); }
          clSetq(L_2__R1, clListSTAR(clSETQ, L_1__R2, clEOA)); }
        clSetq(L_2, clList(clWHEN, L_1__R1, L_2__R1, clEOA)); }
      return(clList(clPROGN, L_1, L_2, clEOA)); } } }

clObject clLoopTequal clVdecl(_ap)
{ clObject x1, x2;
  { clBeginParse(_ap);
    clSetq(x1, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(x2, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolp(x1, clEOA)))
    return(clStringEQUAL(x1, x2, clEOA));
  else return(clValues1(clNIL)); }

clObject clLoopTassoc clVdecl(_ap)
{ clObject kwd, alist;
  { clBeginParse(_ap);
    clSetq(kwd,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(alist,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolp(kwd, clEOA)))
    return(clAssoc(kwd, alist, keyTEST,
                   clSymbolFunctionValue(clSTRINGequal), clEOA));
  else return(clValues1(clNIL)); }

clObject clLoopTmember clVdecl(_ap)
{ clObject kwd, list;
  { clBeginParse(_ap);
    clSetq(kwd,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolp(kwd, clEOA)))
    { clObject L_sub133;
      clSetq(L_sub133, list);
      clLabel(l_ITERATE136);
      if (clTrue(clEndp(L_sub133, clEOA))) return(clValues1(clNIL));
      if (clTrue(clStringEQUAL(kwd, clCar(L_sub133, clEOA), clEOA)))
        return(clValues1(L_sub133));
      { clObject L_value137;
        clSetq(L_value137, clCdr(L_sub133, clEOA));
        clSetq(L_sub133, L_value137); }
      goto l_ITERATE136; }
  else return(clValues1(clNIL)); }

clObject clLoopLookupKeyword clVdecl(_ap)
{ clObject loop_token, table;
  { clBeginParse(_ap);
    clSetq(loop_token,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(table,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolp(loop_token, clEOA)))
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clSymbolName(loop_token, clEOA));
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                                 L_0__R1,
                                 table,
                                 clEOA)); }
      return(clValues(L_0, clEOA)); }
  else return(clValues1(clNIL)); }

clObject clLoopStoreTableData clVdecl(_ap)
{ clObject L_form, L_ignored, symbol, table, datum;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top140;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top140, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(symbol, L_top140); }
    else clSetq(symbol, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form))
      { clObject L_top141;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top141, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(table, L_top141); }
    else clSetq(table, clMissingArgs(I_2, clEOA));
    if (clTrue(L_form))
      { clObject L_top142;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top142, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(datum, L_top142); }
    else clSetq(datum, clMissingArgs(I_3, clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  { clObject L_1;
    { clObject L_1__R1;
      clSetq(L_1__R1, clList(clSYMBOL_NAME, symbol, clEOA));
      clSetq(L_1, clList(clGETHASH, L_1__R1, table, clEOA)); }
    return(clList(clSETF, L_1, datum, clEOA)); } }

clObject clPrintObject_clLOOP_UNIVERSE_clT clVdecl(_ap)
{ clObject *L_args143 = clMakeBinding(),
  *L_methods144 = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(*L_args143,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(*L_methods144,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_form146, L_object2, L_stream3;
    clSetq(L_form146, *L_args143);
    if (clTrue(L_form146))
      { clObject L_top147;
        clSetq(L_top147, clCar(L_form146, clEOA));
        { clObject L_0;
          clSetq(L_0, L_form146);
          clSetq(L_form146, clCdr(L_0, clEOA)); }
        clSetq(L_object2, L_top147); }
    else clSetq(L_object2, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form146))
      { clObject L_top148;
        { clObject L_0;
          clSetq(L_0, L_form146);
          clSetq(L_top148, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form146);
          clSetq(L_form146, clCdr(L_0, clEOA)); }
        clSetq(L_stream3, L_top148); }
    else clSetq(L_stream3, clMissingArgs(I_2, clEOA));
    if (clTrue(L_form146))
      { clObject L_0;
        clSetq(L_0, L_form146);
        clExtraArgs(L_0, clEOA); }
    { clObject L_0;
      clSetq(L_0,
             clLevelStructurePrinter(clSymbolFunctionValue(clPRINT_LOOP_UNIVERSE),
                                     clEOA));
      return(clFuncall(L_0, L_object2, L_stream3, clEOA)); } } }

clObject clMakeLoopUniverse clVdecl(_ap)
{ clObject L_ap, L_keys, L_keywords, L_iteration_keywords,
  L_for_keywords, L_path_keywords, L_type_symbols, L_type_keywords,
  L_ansi, L_implicit_for_required;
  { clBeginParse(_ap);
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_keywords, clCar(L_0, clEOA)); }
    else clSetq(L_keywords, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyITERATION_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_iteration_keywords, clCar(L_0, clEOA)); }
    else clSetq(L_iteration_keywords, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyFOR_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_for_keywords, clCar(L_0, clEOA)); }
    else clSetq(L_for_keywords, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyPATH_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_path_keywords, clCar(L_0, clEOA)); }
    else clSetq(L_path_keywords, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTYPE_SYMBOLS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_type_symbols, clCar(L_0, clEOA)); }
    else clSetq(L_type_symbols, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyTYPE_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_type_keywords, clCar(L_0, clEOA)); }
    else clSetq(L_type_keywords, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyANSI, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_ansi, clCar(L_0, clEOA)); }
    else clSetq(L_ansi, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyIMPLICIT_FOR_REQUIRED,
                               L_keys,
                               clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_implicit_for_required, clCar(L_0, clEOA)); }
    else clSetq(L_implicit_for_required, clNIL);
    clCheckKeys(L_keys, CONS_98, clEOA);
    clEndParse(_ap); }
  { clObject L_8, L_7, L_6, L_5, L_4, L_3, L_2, L_1;
    clSetq(L_1, L_keywords);
    clSetq(L_2, L_iteration_keywords);
    clSetq(L_3, L_for_keywords);
    clSetq(L_4, L_path_keywords);
    clSetq(L_5, L_type_symbols);
    clSetq(L_6, L_type_keywords);
    clSetq(L_7, L_ansi);
    clSetq(L_8, L_implicit_for_required);
    return(clMakeStructure(clLOOP_UNIVERSE,
                           L_1,
                           L_2,
                           L_3,
                           L_4,
                           L_5,
                           L_6,
                           L_7,
                           L_8,
                           clEOA)); } }

clObject clLoopUniverseKeywords clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_0, clEOA)); }

clObject cl_SETF_LoopUniverseKeywords clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_0, clEOA)); }

clObject clLoopUniverseIterationKeywords clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_1, clEOA)); }

clObject cl_SETF_LoopUniverseIterationKeywords clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_1, clEOA)); }

clObject clLoopUniverseForKeywords clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_2, clEOA)); }

clObject cl_SETF_LoopUniverseForKeywords clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_2, clEOA)); }

clObject clLoopUniversePathKeywords clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_3, clEOA)); }

clObject cl_SETF_LoopUniversePathKeywords clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_3, clEOA)); }

clObject clLoopUniverseTypeSymbols clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_4, clEOA)); }

clObject cl_SETF_LoopUniverseTypeSymbols clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_4, clEOA)); }

clObject clLoopUniverseTypeKeywords clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_5, clEOA)); }

clObject cl_SETF_LoopUniverseTypeKeywords clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_5, clEOA)); }

clObject clLoopUniverseAnsi clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_6, clEOA)); }

clObject cl_SETF_LoopUniverseAnsi clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_6, clEOA)); }

clObject clLoopUniverseImplicitForRequired clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_7, clEOA)); }

clObject cl_SETF_LoopUniverseImplicitForRequired clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_7, clEOA)); }

clObject clPrintLoopUniverse clVdecl(_ap)
{ clObject u, stream, level;
  { clBeginParse(_ap);
    clSetq(u, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(stream,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(level,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject str;
    { clObject L_key173;
      clSetq(L_key173, clLoopUniverseAnsi(u, clEOA));
      clSetq(str,
             (_clEq(L_key173, clNIL) ? STR_Non_ANSI__30 :
              (clTrue((_clEq(L_key173, clT) ? CONS_61 : clNIL)) ?
               STR_ANSI__28 :
               (_clEq(L_key173, keyEXTENDED) ? STR_Extended_ANSI__32 :
                clLoopUniverseAnsi(u, clEOA))))); }
    { clObject L_3, L_2;
      clSetq(L_2, clTypeOf(u, clEOA));
      clSetq(L_3, str);
      return(clFuncallFunction(clSymbolFunctionValue(clFORMAT),
                               stream,
                               STR_hashlesstildeS_tildeAgreater__33,
                               L_2,
                               L_3,
                               clEOA)); } } }

static clObject clMakeStandardLoopUniverse_Maketable clVdecl(_ap)
{ clObject entries;
  { clBeginParse(_ap);
    clSetq(entries,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject size, ht;
    clSetq(size, clLength(entries, clEOA));
    { clObject L_1;
      clSetq(L_1,
             (clTrue(clFuncallFunction(clSymbolFunctionValue(clLT),
                                       size,
                                       I_10,
                                       clEOA)) ?
              I_10 : size));
      clSetq(ht,
             clMakeHashTable(keySIZE,
                             L_1,
                             keyTEST,
                             clSymbolFunctionValue(clEQUAL),
                             clEOA)); }
    { clObject L_sublist178, x;
      clSetq(L_sublist178, entries);
      clSetq(x, clCar(L_sublist178, clEOA));
      clLabel(l_ITERATE179);
      if (clTrue(clEndp(L_sublist178, clEOA))) clLocalReturn(NIL);
      { clObject L_arg181, L_value180;
        clSetq(L_arg181, clSymbolName(clCar(x, clEOA), clEOA));
        clSetq(L_value180, clCadr(x, clEOA));
        clFuncallFunction(clFdefinition(CONS_128, clEOA),
                          L_value180,
                          L_arg181,
                          ht,
                          clEOA); }
      { clObject L_0;
        clSetq(L_0, L_sublist178);
        clSetq(L_sublist178, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist178);
        clSetq(x, clCar(L_0, clEOA)); }
      goto l_ITERATE179; }
    clBlockEnd(NIL);
    return(clValues1(ht)); } }

clObject clMakeStandardLoopUniverse clVdecl(_ap)
{ clObject L_ap, L_keys, keywords, for_keywords, iteration_keywords,
  path_keywords, type_keywords, type_symbols, ansi;
  { clBeginParse(_ap);
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyKEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(keywords, clCar(L_0, clEOA)); }
    else clSetq(keywords, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyFOR_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(for_keywords, clCar(L_0, clEOA)); }
    else clSetq(for_keywords, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyITERATION_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(iteration_keywords, clCar(L_0, clEOA)); }
    else clSetq(iteration_keywords, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyPATH_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(path_keywords, clCar(L_0, clEOA)); }
    else clSetq(path_keywords, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyTYPE_KEYWORDS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(type_keywords, clCar(L_0, clEOA)); }
    else clSetq(type_keywords, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTYPE_SYMBOLS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(type_symbols, clCar(L_0, clEOA)); }
    else clSetq(type_symbols, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyANSI, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(ansi, clCar(L_0, clEOA)); }
    else clSetq(ansi, clNIL);
    clCheckKeys(L_keys, CONS_122, clEOA);
    clEndParse(_ap); }
  { clObject _Maketable_;
    clSetq(_Maketable_,
           clMakeClosure(0,
                         clMakeStandardLoopUniverse_Maketable,
                         clNULL_HOOK));
    { clObject L_15, L_13, L_11, L_9, L_7, L_5, L_3, L_1;
      { clObject L_0__R1;
        clSetq(L_0__R1, keywords);
        clSetq(L_1, clFuncallFunction(_Maketable_, L_0__R1, clEOA)); }
      { clObject L_0__R1;
        clSetq(L_0__R1, for_keywords);
        clSetq(L_3, clFuncallFunction(_Maketable_, L_0__R1, clEOA)); }
      { clObject L_0__R1;
        clSetq(L_0__R1, iteration_keywords);
        clSetq(L_5, clFuncallFunction(_Maketable_, L_0__R1, clEOA)); }
      { clObject L_0__R1;
        clSetq(L_0__R1, path_keywords);
        clSetq(L_7, clFuncallFunction(_Maketable_, L_0__R1, clEOA)); }
      clSetq(L_9, ansi);
      { clObject L_0__R1;
        { clObject L_0__R2;
          clSetq(L_0__R2, ansi);
          clSetq(L_0__R1, clNull(L_0__R2, clEOA)); }
        clSetq(L_11, clNot(L_0__R1, clEOA)); }
      { clObject L_0__R1;
        clSetq(L_0__R1, type_keywords);
        clSetq(L_13, clFuncallFunction(_Maketable_, L_0__R1, clEOA)); }
      { clObject size, ht;
        { clObject L_0__R1;
          clSetq(L_0__R1, type_symbols);
          clSetq(size, clLength(L_0__R1, clEOA)); }
        { clObject L_1__R1;
          clSetq(L_1__R1,
                 (clTrue(clFuncallFunction(clSymbolFunctionValue(clLT),
                                           size,
                                           I_10,
                                           clEOA)) ?
                  I_10 : size));
          clSetq(ht,
                 clMakeHashTable(keySIZE,
                                 L_1__R1,
                                 keyTEST,
                                 clSymbolFunctionValue(clEQ),
                                 clEOA)); }
        { clObject L_sublist183, x;
          clSetq(L_sublist183, type_symbols);
          clSetq(x, clCar(L_sublist183, clEOA));
          clLabel(l_ITERATE184);
          if (clTrue(clEndp(L_sublist183, clEOA))) clLocalReturn(NIL);
          if (clTrue(clAtom(x, clEOA)))
            clFuncallFunction(clFdefinition(CONS_128, clEOA),
                              x,
                              x,
                              ht,
                              clEOA);
          else
            { clObject L_arg189, L_value188;
              clSetq(L_arg189, clCar(x, clEOA));
              clSetq(L_value188, clCadr(x, clEOA));
              clFuncallFunction(clFdefinition(CONS_128, clEOA),
                                L_value188,
                                L_arg189,
                                ht,
                                clEOA); }
          { clObject L_0__R1;
            clSetq(L_0__R1, L_sublist183);
            clSetq(L_sublist183, clCdr(L_0__R1, clEOA)); }
          { clObject L_0__R1;
            clSetq(L_0__R1, L_sublist183);
            clSetq(x, clCar(L_0__R1, clEOA)); }
          goto l_ITERATE184; }
        clBlockEnd(NIL);
        clSetq(L_15, ht); }
      return(clMakeLoopUniverse(keyKEYWORDS,
                                L_1,
                                keyFOR_KEYWORDS,
                                L_3,
                                keyITERATION_KEYWORDS,
                                L_5,
                                keyPATH_KEYWORDS,
                                L_7,
                                keyANSI,
                                L_9,
                                keyIMPLICIT_FOR_REQUIRED,
                                L_11,
                                keyTYPE_KEYWORDS,
                                L_13,
                                keyTYPE_SYMBOLS,
                                L_15,
                                clEOA)); } } }

clObject clLoopMakePsetq clVdecl(_ap)
{ clObject frobs;
  { clBeginParse(_ap);
    clSetq(frobs,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(frobs))
    { clObject L_0;
      { clObject L_1, L_0__R1;
        clSetq(L_0__R1, clCar(frobs, clEOA));
        if (clTrue(clNull(clCddr(frobs, clEOA), clEOA)))
          clSetq(L_1, clCadr(frobs, clEOA));
        else
          { clObject L_1__R1;
            clSetq(L_1__R1, clCadr(frobs, clEOA));
            clSetq(L_1,
                   clList(clPROG1,
                          L_1__R1,
                          clLoopMakePsetq(clCddr(frobs, clEOA), clEOA),
                          clEOA)); }
        clSetq(L_0, clList(L_0__R1, L_1, clEOA)); }
      return(clLoopMakeDesetq(L_0, clEOA)); }
  else return(clValues1(clNIL)); }

clObject clLoopMakeDesetq clVdecl(_ap)
{ clObject var_val_pairs;
  { clBeginParse(_ap);
    clSetq(var_val_pairs,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clNull(var_val_pairs, clEOA)))
    return(clValues1(clNIL));
  else
    { clObject L_0;
      clSetq(L_0,
             (clTrue(clSymbolValue(clstarLOOP_DESTRUCTURING_HOOKSstar,
                                   clEOA)) ?
              clCadr(clSymbolValue(clstarLOOP_DESTRUCTURING_HOOKSstar,
                                   clEOA),
                     clEOA) :
              clLOOP_REALLY_DESETQ));
      return(clCons(L_0, var_val_pairs, clEOA)); } }

clDeclareEnv(clLoopReallyDesetq_LoopDesetqInternal_Lambda);
static clObject clLoopReallyDesetq_LoopDesetqInternal_Lambda clVdecl(_ap)
{ clUseEnv(clLoopReallyDesetq_LoopDesetqInternal_Lambda);
  { clObject x;
    { clBeginParse(_ap);
      clSetq(x,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clConsp(x, clEOA)))
      { clObject L_test__R1;
        { clObject L_g207;
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, clCar(x, clEOA));
              clSetq(L_0, clEq(L_0__R1, clCAR, clEOA)); }
            clSetq(L_g207, clNot(L_0, clEOA)); }
          if (clTrue(L_g207))
            clSetq(L_test__R1, L_g207);
          else
            { clObject L_g208;
              clSetq(L_g208,
                     clNot(clSymbolp(clCadr(x, clEOA), clEOA), clEOA));
              if (clTrue(L_g208))
                clSetq(L_test__R1, L_g208);
              else
                { clObject L_0;
                  { clObject L_0__R1;
                    { clObject L_0__R2;
                      clSetq(L_0__R2, x);
                      clSetq(L_0__R1,
                             clSetq(x,
                                    clMacroexpand(L_0__R2,
                                                  clEnv(0, clEnv(0, *env)),
                                                  clEOA))); }
                    clSetq(L_0, clSymbolp(L_0__R1, clEOA)); }
                  clSetq(L_test__R1, clNot(L_0, clEOA)); } } }
        if (clTrue(L_test__R1))
          { clObject L_0;
            clSetq(L_0, x);
            return(clCons(L_0, clNIL, clEOA)); }
        else return(clValues1(clNIL)); }
    else return(clValues1(clNIL)); } }

clDeclareEnv(clLoopReallyDesetq_FindNonNull);
static clObject clLoopReallyDesetq_FindNonNull clVdecl(_ap)
{ clUseEnv(clLoopReallyDesetq_FindNonNull);
  { clObject var;
    { clBeginParse(_ap);
      clSetq(var,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject tail;
      clSetq(tail, var);
      clLabel(l_ITERATE201);
      if (clTrue(clNot(clConsp(tail, clEOA), clEOA)))
        return(clValues1(tail));
      { clObject L_test;
        { clObject L_0;
          { clObject L_top202;
            clSetq(L_top202, clCar(tail, clEOA));
            { clObject L_0__R1;
              clSetq(L_0__R1, tail);
              clSetq(tail, clCdr(L_0__R1, clEOA)); }
            clSetq(L_0, L_top202); }
          clSetq(L_test,
                 clFuncallFunction(clEnv(0, *_FindNonNull_),
                                   L_0,
                                   clEOA)); }
        if (clTrue(L_test)) return(clValues1(clT)); }
      goto l_ITERATE201; } } }

clDeclareEnv(clLoopReallyDesetq_LoopDesetqInternal);
static clObject clLoopReallyDesetq_LoopDesetqInternal clVdecl(_ap)
{ clUseEnv(clLoopReallyDesetq_LoopDesetqInternal);
  { clObject var, val, temp;
    { clBeginParse(_ap);
      clSetq(var,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(val,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      clSetq(temp, (_clVp(_ap) ? clVpop(_ap) : clNIL));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject L_class_name204;
      clSetq(L_class_name204, clInstanceTag(var));
      if (_clEq(L_class_name204, clNULL))
        if (clTrue(clConsp(val, clEOA)))
          { clObject L_test__R2;
            { clObject L_0;
              clSetq(L_0, clCar(val, clEOA));
              clSetq(L_test__R2, clEq(L_0, clPROG1, clEOA)); }
            if (clTrue(L_test__R2))
              { clObject L_0;
                clSetq(L_0,
                       clMakeClosure(1,
                                     clLoopReallyDesetq_LoopDesetqInternal_Lambda,
                                     &clEnvHook(clLoopReallyDesetq_LoopDesetqInternal_Lambda),
                                     &clEnv(0, *env)));
                return(clMapcan(L_0, clCdr(val, clEOA), clEOA)); }
            else return(clList(val, clEOA)); }
        else return(clValues1(clNIL));
      else if (_clEq(L_class_name204, clCONS))
        { clObject car, cdr, car_non_null, cdr_non_null;
          clSetq(car, clCar(var, clEOA));
          clSetq(cdr, clCdr(var, clEOA));
          clSetq(car_non_null,
                 clFuncallFunction(clEnv(1, *_FindNonNull_),
                                   car,
                                   clEOA));
          clSetq(cdr_non_null,
                 clFuncallFunction(clEnv(1, *_FindNonNull_),
                                   cdr,
                                   clEOA));
          if (clTrue((clTrue(car_non_null) ?
                      car_non_null :
                      cdr_non_null)))
            if (clTrue(cdr_non_null))
              { clObject temp_p, temp__R1, body;
                clSetq(temp_p, temp);
                { clObject L_g210;
                  clSetq(L_g210, temp);
                  clSetq(temp__R1,
                         (clTrue(L_g210) ?
                          L_g210 :
                          clSymbolValue(clstarLOOP_DESETQ_TEMPORARYstar,
                                        clEOA))); }
                { clObject L_1, L_0;
                  { clObject L_1__R1;
                    { clObject L_1__R2;
                      clSetq(L_1__R2, temp__R1);
                      clSetq(L_1__R1, clList(clCAR, L_1__R2, clEOA)); }
                    clSetq(L_0,
                           clFuncallFunction(clEnv(2, *_LoopDesetqInternal_),
                                             car,
                                             L_1__R1,
                                             clEOA)); }
                  { clObject L_1__R1, L_0__R1;
                    { clObject L_2, L_1__R2;
                      clSetq(L_1__R2, temp__R1);
                      { clObject L_1__R3;
                        clSetq(L_1__R3, temp__R1);
                        clSetq(L_2, clList(clCDR, L_1__R3, clEOA)); }
                      clSetq(L_0__R1,
                             clList(clSETQ, L_1__R2, L_2, clEOA)); }
                    { clObject L_2, L_1__R2;
                      clSetq(L_1__R2, temp__R1);
                      clSetq(L_2, temp__R1);
                      clSetq(L_1__R1,
                             clFuncallFunction(clEnv(2, *_LoopDesetqInternal_),
                                               cdr,
                                               L_1__R2,
                                               L_2,
                                               clEOA)); }
                    clSetq(L_1, clListSTAR(L_0__R1, L_1__R1, clEOA)); }
                  clSetq(body, clAppend(L_0, L_1, clEOA)); }
                if (clTrue(temp_p))
                  { clObject L_0;
                    { clObject L_test__R5;
                      { clObject L_0__R1;
                        { clObject L_0__R2;
                          clSetq(L_0__R2, temp__R1);
                          clSetq(L_0__R1, clEq(L_0__R2, val, clEOA)); }
                        clSetq(L_test__R5, clNot(L_0__R1, clEOA)); }
                      if (clTrue(L_test__R5))
                      { clObject L_0__R1;
                        { clObject L_1__R1;
                          clSetq(L_1__R1, temp__R1);
                          clSetq(L_0__R1,
                                 clList(clSETQ,
                                        L_1__R1,
                                        val,
                                        clEOA)); }
                        clSetq(L_0, clList(L_0__R1, clEOA)); }
                      else
                      clSetq(L_0, clNIL); }
                    return(clAppend(L_0, body, clEOA)); }
                else
                  { clObject L_0;
                    { clObject L_1;
                      { clObject L_0__R2;
                        { clObject L_0__R3;
                          clSetq(L_0__R3, temp__R1);
                          clSetq(L_0__R2,
                                 clList(L_0__R3, val, clEOA)); }
                        clSetq(L_1, clList(L_0__R2, clEOA)); }
                      clSetq(L_0,
                             clListSTAR(clLET, L_1, body, clEOA)); }
                    return(clList(L_0, clEOA)); } }
            else
              { clObject L_2, L_1;
                clSetq(L_1, clList(clCAR, val, clEOA));
                clSetq(L_2, temp);
                return(clFuncallFunction(clEnv(2, *_LoopDesetqInternal_),
                                         car,
                                         L_1,
                                         L_2,
                                         clEOA)); }
          else return(clValues1(clNIL)); }
      else if (clTrue(clNot(clEq(var, val, clEOA), clEOA)))
        return(clList(clList(clSETQ, var, val, clEOA), clEOA));
      else return(clValues1(clNIL)); } } }

clObject clLoopReallyDesetq clVdecl(_ap)
{ clObject L_form, *env = clMakeBinding(), var_val_pairs;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(*env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    clSetq(var_val_pairs, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject *_LoopDesetqInternal_ = clMakeBinding(),
    *_FindNonNull_ = clMakeBinding();
    clSetq(*_FindNonNull_,
           clMakeClosure(1,
                         clLoopReallyDesetq_FindNonNull,
                         &clEnvHook(clLoopReallyDesetq_FindNonNull),
                         &*_FindNonNull_));
    clSetq(*_LoopDesetqInternal_,
           clMakeClosure(3,
                         clLoopReallyDesetq_LoopDesetqInternal,
                         &clEnvHook(clLoopReallyDesetq_LoopDesetqInternal),
                         &*env,
                         &*_FindNonNull_,
                         &*_LoopDesetqInternal_));
    { clObject actions;
      clSetq(actions, clNIL);
      clLabel(l_ITERATE211);
      if (clTrue(clNull(var_val_pairs, clEOA)))
        if (clTrue(clNull(clCdr(actions, clEOA), clEOA)))
          return(clCar(actions, clEOA));
        else
          return(clListSTAR(clPROGN,
                            clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                              actions,
                                              clEOA),
                            clEOA));
      { clObject L_1, L_0;
        { clObject L_1__R1, L_0__R1;
          { clObject L_top212;
            clSetq(L_top212, clCar(var_val_pairs, clEOA));
            { clObject L_0__R2;
              clSetq(L_0__R2, var_val_pairs);
              clSetq(var_val_pairs, clCdr(L_0__R2, clEOA)); }
            clSetq(L_0__R1, L_top212); }
          { clObject L_top213;
            { clObject L_0__R2;
              clSetq(L_0__R2, var_val_pairs);
              clSetq(L_top213, clCar(L_0__R2, clEOA)); }
            { clObject L_0__R2;
              clSetq(L_0__R2, var_val_pairs);
              clSetq(var_val_pairs, clCdr(L_0__R2, clEOA)); }
            clSetq(L_1__R1, L_top213); }
          clSetq(L_0,
                 clFuncallFunction(*_LoopDesetqInternal_,
                                   L_0__R1,
                                   L_1__R1,
                                   clEOA)); }
        clSetq(L_1, actions);
        clSetq(actions, clRevappend(L_0, L_1, clEOA)); }
      goto l_ITERATE211; } } }

clObject clLoopConstantFoldIfPossible clVdecl(_ap)
{ clObject form, expected_type;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(expected_type, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject new_form, constantp, constant_value;
    clSetq(new_form, form);
    clSetq(constantp, clNIL);
    clSetq(constant_value, clNIL);
    if (clTrue(clSetq(constantp, clConstantp(new_form, clEOA))))
      clSetq(constant_value, clEval(new_form, clEOA));
    if (clTrue((clTrue(constantp) ? expected_type : clNIL)))
      { clObject L_test__R1;
        { clObject L_0;
          { clObject L_1, L_0__R1;
            clSetq(L_0__R1, constant_value);
            clSetq(L_1, expected_type);
            clSetq(L_0,
                   clFuncallFunction(clSymbolFunctionValue(clTYPEP),
                                     L_0__R1,
                                     L_1,
                                     clEOA)); }
          clSetq(L_test__R1, clNot(L_0, clEOA)); }
        if (clTrue(L_test__R1))
          { { clObject L_3, L_2;
              clSetq(L_2, constant_value);
              clSetq(L_3, expected_type);
              clLoopWarn(STRn_36, form, L_2, L_3, clEOA); }
            clSetq(constantp, clNIL);
            clSetq(constant_value, clNIL); } }
    { clObject L_2, L_1;
      clSetq(L_1, constantp);
      clSetq(L_2, constant_value);
      return(clValues(new_form, L_1, L_2, clEOA)); } } }

clObject clLoopConstantp clVdecl(_ap)
{ clObject form;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clConstantp(form, clEOA)); }

clObject clLoopCodeDuplicationThreshold clVdecl(_ap)
{ clObject env;
  { clBeginParse(_ap);
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values322, speed, space;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clLoopOptimizationQuantities(env, clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values322, clMultipleValueFuncall(MVC)); }
    clSetq(speed, clCar(L_values322, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values322);
        clSetq(L_0, clSetq(L_values322, clCdr(L_0__R1, clEOA))); }
      clSetq(space, clCar(L_0, clEOA)); }
    { clObject L_1;
      { clObject L_0__R1;
        clSetq(L_0__R1,
               clFuncallFunction(clSymbolFunctionValue(clSUBT),
                                 speed,
                                 space,
                                 clEOA));
        clSetq(L_1,
               clFuncallFunction(clSymbolFunctionValue(clMULT),
                                 L_0__R1,
                                 I_10,
                                 clEOA)); }
      return(clFuncallFunction(clSymbolFunctionValue(clADD),
                               I_40,
                               L_1,
                               clEOA)); } } }

static clObject clLoopBody_Psimp clVdecl(_ap)
{ clObject l;
  { clBeginParse(_ap);
    clSetq(l, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject ans;
    clSetq(ans, clNIL);
    { clObject L_sublist330, x;
      clSetq(L_sublist330, l);
      clSetq(x, clCar(L_sublist330, clEOA));
      clLabel(l_ITERATE331);
      if (clTrue(clEndp(L_sublist330, clEOA))) clLocalReturn(NIL);
      if (clTrue(x))
        { { clObject L_1;
            clSetq(L_1, ans);
            clSetq(ans, clCons(x, L_1, clEOA)); }
          { clObject L_test__R1;
            if (clTrue(clConsp(x, clEOA)))
              { clObject L_item332;
                clSetq(L_item332, clCar(x, clEOA));
                clSetq(L_test__R1,
                       (_clEq(L_item332, clGO) ?
                        CONS_130 :
                        (_clEq(L_item332, clRETURN) ?
                         CONS_131 :
                         (_clEq(L_item332, clRETURN_FROM) ?
                          CONS_132 :
                          clNIL)))); }
            else clSetq(L_test__R1, clNIL);
            if (clTrue(L_test__R1)) clLocalReturn(NIL); } }
      { clObject L_0;
        clSetq(L_0, L_sublist330);
        clSetq(L_sublist330, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist330);
        clSetq(x, clCar(L_0, clEOA)); }
      goto l_ITERATE331; }
    clBlockEnd(NIL);
    { clObject L_0;
      clSetq(L_0, ans);
      return(clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                               L_0,
                               clEOA)); } } }

static clObject clLoopBody_Pify clVdecl(_ap)
{ clObject l;
  { clBeginParse(_ap);
    clSetq(l, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clNull(clCdr(l, clEOA), clEOA)))
    return(clCar(l, clEOA));
  else return(clListSTAR(clPROGN, l, clEOA)); }

clDeclareEnv(clLoopBody_Makebody);
static clObject clLoopBody_Makebody clVdecl(_ap)
{ clUseEnv(clLoopBody_Makebody);
  { { clBeginParse(_ap);
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject form;
      { clObject L_1;
        { clObject L_1__R1, L_0__R1;
          { clObject L_0__R2;
            { clObject L_1__R2;
              { clObject L_0__R4;
                clSetq(L_0__R4, clEnv(2, *rbefore));
                clSetq(L_1__R2,
                       clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                         L_0__R4,
                                         clEOA)); }
              clSetq(L_0__R2,
                     clAppend(clEnv(1, *prologue), L_1__R2, clEOA)); }
            clSetq(L_0__R1,
                   clFuncallFunction(clEnv(0, *_Psimp_),
                                     L_0__R2,
                                     clEOA)); }
          { clObject L_1__R2;
            { clObject L_0__R3;
              { clObject L_0__R4;
                { clObject L_1__R4;
                  { clObject L_0__R6;
                    clSetq(L_0__R6, clEnv(4, *rafter));
                    clSetq(L_1__R4,
                           clNreconc(L_0__R6, CONS_133, clEOA)); }
                  clSetq(L_0__R4,
                         clAppend(clEnv(3, *main_body),
                                  L_1__R4,
                                  clEOA)); }
                clSetq(L_0__R3,
                       clFuncallFunction(clEnv(0, *_Psimp_),
                                         L_0__R4,
                                         clEOA)); }
              clSetq(L_1__R2,
                     clAppend(L_0__R3,
                              clListSTAR(clEND_LOOP,
                                         clFuncallFunction(clEnv(0, *_Psimp_),
                                                           clEnv(5, *epilogue),
                                                           clEOA),
                                         clEOA),
                              clEOA)); }
            clSetq(L_1__R1, clListSTAR(clNEXT_LOOP, L_1__R2, clEOA)); }
          clSetq(L_1, clAppend(L_0__R1, L_1__R1, clEOA)); }
        clSetq(form, clListSTAR(clTAGBODY, L_1, clEOA)); }
      if (clTrue(clEnv(6, *flagvar)))
        { clObject L_1;
          clSetq(L_1,
                 clList(clListSTAR(clEnv(6, *flagvar), CONS_2, clEOA),
                        clEOA));
          return(clList(clLET, L_1, form, clEOA)); }
      else return(clValues1(form)); } } }

clObject clLoopBody clVdecl(_ap)
{ clObject L_form, env, *prologue = clMakeBinding(), before_loop,
  *main_body = clMakeBinding(), after_loop,
  *epilogue = clMakeBinding(), *rbefore = clMakeBinding(),
  *rafter = clMakeBinding(), *flagvar = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top325;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top325, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(*prologue, L_top325); }
    else clSetq(*prologue, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form))
      { clObject L_top326;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top326, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(before_loop, L_top326); }
    else clSetq(before_loop, clMissingArgs(I_2, clEOA));
    if (clTrue(L_form))
      { clObject L_top327;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top327, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(*main_body, L_top327); }
    else clSetq(*main_body, clMissingArgs(I_3, clEOA));
    if (clTrue(L_form))
      { clObject L_top328;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top328, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(after_loop, L_top328); }
    else clSetq(after_loop, clMissingArgs(I_4, clEOA));
    if (clTrue(L_form))
      { clObject L_top329;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top329, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(*epilogue, L_top329); }
    else clSetq(*epilogue, clMissingArgs(I_5, clEOA));
    clSetq(*rbefore, clNIL);
    clSetq(*rafter, clNIL);
    clSetq(*flagvar, clNIL);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  { clObject L_test;
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clLength(before_loop, clEOA));
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clEQ_NUMBER),
                                 L_0__R1,
                                 clLength(after_loop, clEOA),
                                 clEOA)); }
      clSetq(L_test, clNot(L_0, clEOA)); }
    if (clTrue(L_test)) clError(STRn_38, clEOA); }
  clSetq(*rbefore,
         clFuncallFunction(clSymbolFunctionValue(clREVERSE),
                           before_loop,
                           clEOA));
  clSetq(*rafter,
         clFuncallFunction(clSymbolFunctionValue(clREVERSE),
                           after_loop,
                           clEOA));
  { clObject _Makebody_, _Pify_, *_Psimp_ = clMakeBinding();
    clSetq(*_Psimp_, clMakeClosure(0, clLoopBody_Psimp, clNULL_HOOK));
    clSetq(_Pify_, clMakeClosure(0, clLoopBody_Pify, clNULL_HOOK));
    clSetq(_Makebody_,
           clMakeClosure(7,
                         clLoopBody_Makebody,
                         &clEnvHook(clLoopBody_Makebody),
                         &*_Psimp_,
                         &*prologue,
                         &*rbefore,
                         &*main_body,
                         &*rafter,
                         &*epilogue,
                         &*flagvar));
    { clObject L_test;
      { clObject L_g333;
        clSetq(L_g333,
               clSymbolValue(clstarLOOP_DUPLICATE_CODEstar, clEOA));
        if (clTrue(L_g333))
          clSetq(L_test, L_g333);
        else
          { clObject L_0;
            clSetq(L_0, *rbefore);
            clSetq(L_test, clNot(L_0, clEOA)); } }
      if (clTrue(L_test))
        return(clFuncallFunction(_Makebody_, clEOA)); }
    { clObject threshold;
      clSetq(threshold, clLoopCodeDuplicationThreshold(env, clEOA));
      clLabel(l_ITERATE334);
      if (clTrue(clNIL)) return(clValues1(clNIL));
      { clLabel(l_ITERATE335);
        { clObject L_test;
          { clObject L_g336;
            { clObject L_0;
              clSetq(L_0, *rbefore);
              clSetq(L_g336, clNull(L_0, clEOA)); }
            if (clTrue(L_g336))
              clSetq(L_test, L_g336);
            else
              { clObject L_0;
                { clObject L_1, L_0__R1;
                  { clObject L_0__R2;
                    clSetq(L_0__R2, *rbefore);
                    clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
                  { clObject L_0__R2;
                    clSetq(L_0__R2, *rafter);
                    clSetq(L_1, clCar(L_0__R2, clEOA)); }
                  clSetq(L_0,
                         clFuncallFunction(clSymbolFunctionValue(clEQUAL),
                                           L_0__R1,
                                           L_1,
                                           clEOA)); }
                clSetq(L_test, clNot(L_0, clEOA)); } }
          if (clTrue(L_test)) clLocalReturn(NIL); }
        { clObject L_1, L_0;
          { clObject L_top337;
            { clObject L_0__R1;
              clSetq(L_0__R1, *rbefore);
              clSetq(L_top337, clCar(L_0__R1, clEOA)); }
            { clObject L_0__R1;
              clSetq(L_0__R1, *rbefore);
              clSetq(*rbefore, clCdr(L_0__R1, clEOA)); }
            clSetq(L_0, L_top337); }
          clSetq(L_1, *main_body);
          clSetq(*main_body, clCons(L_0, L_1, clEOA)); }
        { clObject L_top338;
          { clObject L_0;
            clSetq(L_0, *rafter);
            clSetq(L_top338, clCar(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, *rafter);
            clSetq(*rafter, clCdr(L_0, clEOA)); }
          (void) L_top338; }
        goto l_ITERATE335; }
      clBlockEnd(NIL);
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, *rbefore);
          clSetq(L_test, clNot(L_0, clEOA)); }
        if (clTrue(L_test))
          return(clFuncallFunction(_Makebody_, clEOA)); }
      { clObject bb, aa, lastdiff, count, inc;
        clSetq(bb, *rbefore);
        clSetq(aa, *rafter);
        clSetq(lastdiff, clNIL);
        clSetq(count, I_0);
        clSetq(inc, clNIL);
        clLabel(l_ITERATE339);
        if (clTrue(clNull(bb, clEOA)))
          { return(clFuncallFunction(_Makebody_, clEOA));
            clLocalReturn(NIL__r3); }
        { clObject L_test;
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, clCar(bb, clEOA));
              clSetq(L_0,
                     clFuncallFunction(clSymbolFunctionValue(clEQUAL),
                                       L_0__R1,
                                       clCar(aa, clEOA),
                                       clEOA)); }
            clSetq(L_test, clNot(L_0, clEOA)); }
          if (clTrue(L_test))
            { clSetq(lastdiff, bb); clSetq(count, I_0); }
          else
            { clObject L_test__R1;
              { clObject L_g340;
                { clObject L_0;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, clCar(bb, clEOA));
                    clSetq(L_0,
                           clSetq(inc,
                                  clEstimateCodeSize(L_0__R1,
                                                     env,
                                                     clEOA))); }
                  clSetq(L_g340, clNot(L_0, clEOA)); }
                if (clTrue(L_g340))
                  clSetq(L_test__R1, L_g340);
                else
                  { clObject L_0;
                    { clObject L_1__R1, L_0__R1;
                      clSetq(L_0__R1, count);
                      clSetq(L_1__R1, inc);
                      clSetq(L_0,
                             clSetq(count,
                                    clFuncallFunction(clSymbolFunctionValue(clADD),
                                                      L_0__R1,
                                                      L_1__R1,
                                                      clEOA))); }
                    clSetq(L_test__R1,
                           clFuncallFunction(clSymbolFunctionValue(clGT),
                                             L_0,
                                             threshold,
                                             clEOA)); } }
              if (clTrue(L_test__R1))
                { { clObject then, CL_else;
                    clSetq(then, clNIL);
                    clSetq(CL_else, clNIL);
                    { clLabel(l_ITERATE341);
                      if (clTrue(clNIL)) clLocalReturn(NIL__r1);
                      { clObject L_1, L_0;
                        { clObject L_top342;
                          { clObject L_0__R1;
                            clSetq(L_0__R1, *rbefore);
                            clSetq(L_top342, clCar(L_0__R1, clEOA)); }
                          { clObject L_0__R1;
                            clSetq(L_0__R1, *rbefore);
                            clSetq(*rbefore, clCdr(L_0__R1, clEOA)); }
                          clSetq(L_0, L_top342); }
                        clSetq(L_1, CL_else);
                        clSetq(CL_else, clCons(L_0, L_1, clEOA)); }
                      { clObject L_1, L_0;
                        { clObject L_top343;
                          { clObject L_0__R1;
                            clSetq(L_0__R1, *rafter);
                            clSetq(L_top343, clCar(L_0__R1, clEOA)); }
                          { clObject L_0__R1;
                            clSetq(L_0__R1, *rafter);
                            clSetq(*rafter, clCdr(L_0__R1, clEOA)); }
                          clSetq(L_0, L_top343); }
                        clSetq(L_1, then);
                        clSetq(then, clCons(L_0, L_1, clEOA)); }
                      { clObject L_test__R2;
                        { clObject L_1, L_0;
                          clSetq(L_0, *rbefore);
                          { clObject L_0__R1;
                            clSetq(L_0__R1, lastdiff);
                            clSetq(L_1, clCdr(L_0__R1, clEOA)); }
                          clSetq(L_test__R2, clEq(L_0, L_1, clEOA)); }
                        if (clTrue(L_test__R2))
                        clLocalReturn(NIL__r1); }
                      goto l_ITERATE341; }
                    clBlockEnd(NIL__r1);
                    { clObject L_test__R2;
                      { clObject L_0;
                        clSetq(L_0, *flagvar);
                        clSetq(L_test__R2, clNot(L_0, clEOA)); }
                      if (clTrue(L_test__R2))
                      { clObject L_1, L_0;
                        { clObject L_1__R1;
                          clSetq(L_1__R1,
                                 clSetq(*flagvar,
                                        clSymbolValue(clstarLOOP_ITERATION_FLAG_VARIABLEstar,
                                                      clEOA)));
                          clSetq(L_0,
                                 clListSTAR(clSETQ,
                                            L_1__R1,
                                            CONS_61,
                                            clEOA)); }
                        clSetq(L_1, CL_else);
                        clSetq(CL_else, clCons(L_0, L_1, clEOA)); } }
                    { clObject L_1, L_0;
                      { clObject L_3, L_2, L_1__R1;
                        clSetq(L_1__R1, *flagvar);
                        { clObject L_0__R2;
                          { clObject L_0__R3;
                            clSetq(L_0__R3, then);
                            clSetq(L_0__R2,
                                   clFuncallFunction(*_Psimp_,
                                                     L_0__R3,
                                                     clEOA)); }
                          clSetq(L_2,
                                 clFuncallFunction(_Pify_,
                                                   L_0__R2,
                                                   clEOA)); }
                        { clObject L_0__R2;
                          { clObject L_0__R3;
                            clSetq(L_0__R3, CL_else);
                            clSetq(L_0__R2,
                                   clFuncallFunction(*_Psimp_,
                                                     L_0__R3,
                                                     clEOA)); }
                          clSetq(L_3,
                                 clFuncallFunction(_Pify_,
                                                   L_0__R2,
                                                   clEOA)); }
                        clSetq(L_0,
                               clList(clIF,
                                      L_1__R1,
                                      L_2,
                                      L_3,
                                      clEOA)); }
                      clSetq(L_1, *main_body);
                      clSetq(*main_body, clCons(L_0, L_1, clEOA)); } }
                  { clLabel(l_ITERATE344);
                    if (clTrue(clNIL)) clLocalReturn(NIL__r2);
                    { clObject L_top345;
                      { clObject L_0;
                        clSetq(L_0, *rafter);
                        clSetq(L_top345, clCar(L_0, clEOA)); }
                      { clObject L_0;
                        clSetq(L_0, *rafter);
                        clSetq(*rafter, clCdr(L_0, clEOA)); }
                      (void) L_top345; }
                    { clObject L_1, L_0;
                      { clObject L_top346;
                        { clObject L_0__R1;
                          clSetq(L_0__R1, *rbefore);
                          clSetq(L_top346, clCar(L_0__R1, clEOA)); }
                        { clObject L_0__R1;
                          clSetq(L_0__R1, *rbefore);
                          clSetq(*rbefore, clCdr(L_0__R1, clEOA)); }
                        clSetq(L_0, L_top346); }
                      clSetq(L_1, *main_body);
                      clSetq(*main_body, clCons(L_0, L_1, clEOA)); }
                    { clObject L_test__R2;
                      { clObject L_0;
                        clSetq(L_0, *rbefore);
                        clSetq(L_test__R2,
                               clEq(L_0, clCdr(bb, clEOA), clEOA)); }
                      if (clTrue(L_test__R2)) clLocalReturn(NIL__r2); }
                    goto l_ITERATE344; }
                  clBlockEnd(NIL__r2);
                  clLocalReturn(NIL__r3); } } }
        { clObject L_value347, L_value348;
          clSetq(L_value347, clCdr(bb, clEOA));
          clSetq(L_value348, clCdr(aa, clEOA));
          clSetq(bb, L_value347);
          clSetq(aa, L_value348); }
        goto l_ITERATE339; }
      clBlockEnd(NIL__r3);
      goto l_ITERATE334; } } }

clObject clDuplicatableCodeP clVdecl(_ap)
{ clObject expr, env;
  { clBeginParse(_ap);
    clSetq(expr,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clNull(expr, clEOA)))
    return(clValues1(I_0));
  else
    { clObject ans;
      clSetq(ans, clEstimateCodeSize(expr, env, clEOA));
      return(clValues1(ans)); } }

clObject clDestructuringSize clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject x__R1, n;
    clSetq(x__R1, x);
    clSetq(n, I_0);
    clLabel(l_ITERATE357);
    if (clTrue(clAtom(x__R1, clEOA)))
      { clObject L_1;
        clSetq(L_1, (clTrue(clNull(x__R1, clEOA)) ? I_0 : I_1));
        return(clFuncallFunction(clSymbolFunctionValue(clADD),
                                 n,
                                 L_1,
                                 clEOA)); }
    { clObject L_value358, L_value359;
      clSetq(L_value358, clCdr(x__R1, clEOA));
      { clObject L_0;
        clSetq(L_0, clDestructuringSize(clCar(x__R1, clEOA), clEOA));
        clSetq(L_value359,
               clFuncallFunction(clSymbolFunctionValue(clADD),
                                 L_0,
                                 n,
                                 clEOA)); }
      clSetq(x__R1, L_value358);
      clSetq(n, L_value359); }
    goto l_ITERATE357; } }

clObject clEstimateCodeSize clVdecl(_ap)
{ volatile clObject x, env;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clCatch(CATCH);
    clSetq(CATCH, clESTIMATE_CODE_SIZE);
    if (clTrue(clThrown(CATCH)))
      return(clReturnedValue(CATCH));
    else clUnwindReturn(clEstimateCodeSize1(x, env, clEOA), 1); } }

clDeclareEnv(clEstimateCodeSize1_ListSize);
static clObject clEstimateCodeSize1_ListSize clVdecl(_ap)
{ clUseEnv(clEstimateCodeSize1_ListSize);
  { clObject l;
    { clBeginParse(_ap);
      clSetq(l,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject n;
      clSetq(n, I_0);
      { clObject L_sublist360, x;
        clSetq(L_sublist360, l);
        clSetq(x, clCar(L_sublist360, clEOA));
        clLabel(l_ITERATE361);
        if (clTrue(clEndp(L_sublist360, clEOA))) return(clValues1(n));
        { clObject L_0;
          clSetq(L_0, n);
          clSetq(n,
                 clFuncallFunction(clSymbolFunctionValue(clADD),
                                   L_0,
                                   clEstimateCodeSize1(x,
                                                       clEnv(0, *env),
                                                       clEOA),
                                   clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist360);
          clSetq(L_sublist360, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist360);
          clSetq(x, clCar(L_0, clEOA)); }
        goto l_ITERATE361; } } } }

clObject clEstimateCodeSize1 clVdecl(_ap)
{ clObject x, *env = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(*env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject _ListSize_;
    clSetq(_ListSize_,
           clMakeClosure(1,
                         clEstimateCodeSize1_ListSize,
                         &clEnvHook(clEstimateCodeSize1_ListSize),
                         &*env));
    if (clTrue(clConstantp(x, clEOA)))
      return(clValues1(I_1));
    else if (clTrue(clSymbolp(x, clEOA)))
      { clObject L_values362, new_form, expanded_p;
        { clMultipleValueCall(MVC);
          clSetq(MVC, clSymbolFunctionValue(clLIST));
          { clObject L_1;
            clSetq(L_1, *env);
            clMacroexpand1(x, L_1, clEOA); }
          clAccumulateValues(MVC);
          clSetq(L_values362, clMultipleValueFuncall(MVC)); }
        clSetq(new_form, clCar(L_values362, clEOA));
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, L_values362);
            clSetq(L_0, clSetq(L_values362, clCdr(L_0__R1, clEOA))); }
          clSetq(expanded_p, clCar(L_0, clEOA)); }
        if (clTrue(expanded_p))
          { clObject L_1;
            clSetq(L_1, *env);
            return(clEstimateCodeSize1(new_form, L_1, clEOA)); }
        else return(clValues1(I_1)); }
    else if (clTrue(clAtom(x, clEOA)))
      return(clValues1(I_1));
    else if (clTrue(clSymbolp(clCar(x, clEOA), clEOA)))
      { clObject fn, tem, n;
        clSetq(fn, clCar(x, clEOA));
        clSetq(tem, clNIL);
        clSetq(n, I_0);
        if (clTrue(clSetq(tem,
                          clGet(fn, clESTIMATE_CODE_SIZE, clEOA))))
          { clObject L_object363;
            clSetq(L_object363, tem);
            if (clTrue(clFixnump(L_object363, clEOA)))
              { clObject L_0;
                clSetq(L_0, tem);
                return(clFuncallFunction(clSymbolFunctionValue(clADD),
                                         L_0,
                                         clFuncallFunction(_ListSize_,
                                                           clCdr(x,
                                                                 clEOA),
                                                           clEOA),
                                         clEOA)); }
            else
              { clObject L_2, L_0;
                clSetq(L_0, tem);
                clSetq(L_2, *env);
                return(clFuncall(L_0, x, L_2, clEOA)); } }
        else if (clTrue(clSetq(tem,
                               clAssoc(fn,
                                       clSymbolValue(clstarSPECIAL_CODE_SIZESstar,
                                                     clEOA),
                                       clEOA))))
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, tem);
              clSetq(L_0, clSecond(L_0__R1, clEOA)); }
            return(clFuncallFunction(clSymbolFunctionValue(clADD),
                                     L_0,
                                     clFuncallFunction(_ListSize_,
                                                       clCdr(x, clEOA),
                                                       clEOA),
                                     clEOA)); }
        else if (_clEq(fn, clCOND))
          { clObject L_sublist372, clause;
            clSetq(L_sublist372, clCdr(x, clEOA));
            clSetq(clause, clCar(L_sublist372, clEOA));
            clLabel(l_ITERATE373);
            if (clTrue(clEndp(L_sublist372, clEOA)))
              return(clValues1(n));
            { clObject L_0;
              clSetq(L_0, n);
              clSetq(n,
                     clFuncallFunction(clSymbolFunctionValue(clADD),
                                       L_0,
                                       clFuncallFunction(_ListSize_,
                                                         clause,
                                                         clEOA),
                                       clEOA)); }
            { clObject L_0;
              clSetq(L_0, n);
              clSetq(n,
                     clFuncallFunction(clSymbolFunctionValue(clADD),
                                       L_0,
                                       I_1,
                                       clEOA)); }
            { clObject L_0;
              clSetq(L_0, L_sublist372);
              clSetq(L_sublist372, clCdr(L_0, clEOA)); }
            { clObject L_0;
              clSetq(L_0, L_sublist372);
              clSetq(clause, clCar(L_0, clEOA)); }
            goto l_ITERATE373; }
        else if (_clEq(fn, clDESETQ))
          { clObject l;
            clSetq(l, clCdr(x, clEOA));
            clLabel(l_ITERATE374);
            if (clTrue(clNull(l, clEOA))) return(clValues1(n));
            { clObject L_2, L_1, L_0;
              clSetq(L_0, n);
              clSetq(L_1, clDestructuringSize(clCar(l, clEOA), clEOA));
              { clObject L_1__R1, L_0__R1;
                clSetq(L_0__R1, clCadr(l, clEOA));
                clSetq(L_1__R1, *env);
                clSetq(L_2,
                       clEstimateCodeSize1(L_0__R1, L_1__R1, clEOA)); }
              clSetq(n, clPLUS_FUNC(L_0, L_1, L_2, clEOA)); }
            { clObject L_value375;
              clSetq(L_value375, clCdr(l, clEOA));
              clSetq(l, L_value375); }
            goto l_ITERATE374; }
        else if (clTrue((_clEq(fn, clSETQ) ?
                         CONS_235 :
                         (_clEq(fn, clPSETQ) ? CONS_236 : clNIL))))
          { clObject l;
            clSetq(l, clCdr(x, clEOA));
            clLabel(l_ITERATE377);
            if (clTrue(clNull(l, clEOA))) return(clValues1(n));
            { clObject L_1, L_0;
              clSetq(L_0, n);
              { clObject L_1__R1, L_0__R1;
                clSetq(L_0__R1, clCadr(l, clEOA));
                clSetq(L_1__R1, *env);
                clSetq(L_1,
                       clEstimateCodeSize1(L_0__R1, L_1__R1, clEOA)); }
              clSetq(n, clPLUS_FUNC(L_0, L_1, I_1, clEOA)); }
            { clObject L_value378;
              clSetq(L_value378, clCdr(l, clEOA));
              clSetq(l, L_value378); }
            goto l_ITERATE377; }
        else if (_clEq(fn, clGO))
          return(clValues1(I_1));
        else if (_clEq(fn, clFUNCTION))
          { clObject L_test__R11;
            { clObject L_g379;
              clSetq(L_g379, clSymbolp(clCadr(x, clEOA), clEOA));
              if (clTrue(L_g379))
                clSetq(L_test__R11, L_g379);
              else if (clTrue(clConsp(clCadr(x, clEOA), clEOA)))
                { clObject L_0;
                  clSetq(L_0, clCaadr(x, clEOA));
                  clSetq(L_test__R11, clEq(L_0, clSETF, clEOA)); }
              else clSetq(L_test__R11, clNIL); }
            if (clTrue(L_test__R11))
              return(clValues1(I_1));
            else
              { clThrow(THROW);
                clSetq(THROW, clDUPLICATABLE_CODE_P);
                clFindCatcher(THROW);
                clExitThrow(THROW, clValues1(clNIL));
                return(clValues1(clNIL)); } }
        else if (_clEq(fn, clMULTIPLE_VALUE_SETQ))
          { clObject L_0;
            clSetq(L_0, clLength(clSecond(x, clEOA), clEOA));
            return(clFuncallFunction(clSymbolFunctionValue(clADD),
                                     L_0,
                                     clFuncallFunction(_ListSize_,
                                                       clCddr(x,
                                                              clEOA),
                                                       clEOA),
                                     clEOA)); }
        else if (_clEq(fn, clRETURN_FROM))
          { clObject L_0;
            { clObject L_1, L_0__R1;
              clSetq(L_0__R1, clThird(x, clEOA));
              clSetq(L_1, *env);
              clSetq(L_0, clEstimateCodeSize1(L_0__R1, L_1, clEOA)); }
            return(cl1PLUS_FUNC(L_0, clEOA)); }
        else
          { clObject L_test__R13;
            { clObject L_g384;
              clSetq(L_g384, clSpecialOperatorP(fn, clEOA));
              if (clTrue(L_g384))
                clSetq(L_test__R13, L_g384);
              else
                { { clObject L_sub385;
                    clSetq(L_sub385,
                           clSymbolValue(clstarESTIMATE_CODE_SIZE_PUNTstar,
                                         clEOA));
                    clLabel(l_ITERATE388);
                    if (clTrue(clEndp(L_sub385, clEOA)))
                      { clSetq(L_test__R13, clNIL);
                        clLocalReturn(NIL__r13); }
                    if (clTrue(clEql(fn,
                                     clCar(L_sub385, clEOA),
                                     clEOA)))
                      { clSetq(L_test__R13, L_sub385);
                        clLocalReturn(l_MEMBER387__r13); }
                    { clObject L_value389;
                      clSetq(L_value389, clCdr(L_sub385, clEOA));
                      clSetq(L_sub385, L_value389); }
                    goto l_ITERATE388; }
                  clBlockEnd(NIL__r13);
                  clBlockEnd(l_MEMBER387__r13); } }
            if (clTrue(L_test__R13))
              { clThrow(THROW__r1);
                clSetq(THROW__r1, clESTIMATE_CODE_SIZE);
                clFindCatcher(THROW__r1);
                clExitThrow(THROW__r1, clValues1(clNIL));
                return(clValues1(clNIL)); }
            else
              { clObject L_values390, new_form, expanded_p;
                { clMultipleValueCall(MVC__r1);
                  clSetq(MVC__r1, clSymbolFunctionValue(clLIST));
                  { clObject L_1;
                    clSetq(L_1, *env);
                    clMacroexpand1(x, L_1, clEOA); }
                  clAccumulateValues(MVC__r1);
                  clSetq(L_values390,
                         clMultipleValueFuncall(MVC__r1)); }
                clSetq(new_form, clCar(L_values390, clEOA));
                { clObject L_0;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, L_values390);
                    clSetq(L_0,
                           clSetq(L_values390,
                                  clCdr(L_0__R1, clEOA))); }
                  clSetq(expanded_p, clCar(L_0, clEOA)); }
                if (clTrue(expanded_p))
                  { clObject L_1;
                    clSetq(L_1, *env);
                    return(clEstimateCodeSize1(new_form,
                                               L_1,
                                               clEOA)); }
                else
                  return(clFuncallFunction(clSymbolFunctionValue(clADD),
                                           I_3,
                                           clFuncallFunction(_ListSize_,
                                                             clCdr(x,
                                                                   clEOA),
                                                             clEOA),
                                           clEOA)); } } }
    else
      { clThrow(THROW__r2);
        clSetq(THROW__r2, clESTIMATE_CODE_SIZE);
        clFindCatcher(THROW__r2);
        clExitThrow(THROW__r2, clValues1(clNIL));
        return(clValues1(clNIL)); } } }

clObject clLoopContext clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject l, CL_new;
    clSetq(l, clSymbolValue(clstarLOOP_SOURCE_CONTEXTstar, clEOA));
    clSetq(CL_new, clNIL);
    clLabel(l_ITERATE394);
    if (_clEq(l, clCdr(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                     clEOA),
                       clEOA)))
      return(clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                               CL_new,
                               clEOA));
    { clObject L_value395, L_value396;
      clSetq(L_value395, clCdr(l, clEOA));
      { clObject L_0;
        clSetq(L_0, clCar(l, clEOA));
        clSetq(L_value396, clCons(L_0, CL_new, clEOA)); }
      clSetq(l, L_value395);
      clSetq(CL_new, L_value396); }
    goto l_ITERATE394; } }

clObject clLoopError clVdecl(_ap)
{ clObject format_string, format_args;
  { clBeginParse(_ap);
    clSetq(format_string,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(format_args, clVargs(_ap));
    clEndParse(_ap); }
  return(clError(STRn_39, format_string, format_args,
                 clLoopContext(clEOA), clEOA)); }

clObject clLoopWarn clVdecl(_ap)
{ clObject format_string, format_args;
  { clBeginParse(_ap);
    clSetq(format_string,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(format_args, clVargs(_ap));
    clEndParse(_ap); }
  return(clWarn(STRn_39, format_string, format_args,
                clLoopContext(clEOA), clEOA)); }

clObject clLoopCheckDataType clVdecl(_ap)
{ clObject specified_type, required_type, default_type;
  { clBeginParse(_ap);
    clSetq(specified_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(required_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(default_type, (_clVp(_ap) ? clVpop(_ap) : required_type));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clNull(specified_type, clEOA)))
    return(clValues1(default_type));
  else
    { clObject L_values397, a, b;
      { clMultipleValueCall(MVC);
        clSetq(MVC, clSymbolFunctionValue(clLIST));
        clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                          specified_type,
                          required_type,
                          clEOA);
        clAccumulateValues(MVC);
        clSetq(L_values397, clMultipleValueFuncall(MVC)); }
      clSetq(a, clCar(L_values397, clEOA));
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values397);
          clSetq(L_0, clSetq(L_values397, clCdr(L_0__R1, clEOA))); }
        clSetq(b, clCar(L_0, clEOA)); }
      if (clTrue(clNot(b, clEOA)))
        clLoopWarn(STRn_40, specified_type, required_type, clEOA);
      else if (clTrue(clNot(a, clEOA)))
        clLoopError(STRn_41, specified_type, required_type, clEOA);
      return(clValues1(specified_type)); } }

clObject clLoopFinish clVdecl(_ap)
{ clObject L_form, L_ignored;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, L_form);
    clSetq(L_form, clCdr(L_0, clEOA)); }
  if (clTrue(L_form))
    { clObject L_0; clSetq(L_0, L_form); clExtraArgs(L_0, clEOA); }
  return(clValues1(CONS_237)); }

clObject clLoopTranslate clVdecl(_ap)
{ { clBeginParse(_ap);
    clDbind(clstarLOOP_SOURCE_CODEstar);
    (_clVp(_ap) ?
     clSetSymbolValueValue(clstarLOOP_SOURCE_CODEstar, clVpop(_ap)) :
     clSetSymbolValueValue(clstarLOOP_SOURCE_CODEstar,
                           clMissingArgs(I_1, clEOA)));
    clDbind(clstarLOOP_MACRO_ENVIRONMENTstar);
    (_clVp(_ap) ?
     clSetSymbolValueValue(clstarLOOP_MACRO_ENVIRONMENTstar,
                           clVpop(_ap)) :
     clSetSymbolValueValue(clstarLOOP_MACRO_ENVIRONMENTstar,
                           clMissingArgs(I_2, clEOA)));
    clDbind(clstarLOOP_UNIVERSEstar);
    (_clVp(_ap) ?
     clSetSymbolValueValue(clstarLOOP_UNIVERSEstar, clVpop(_ap)) :
     clSetSymbolValueValue(clstarLOOP_UNIVERSEstar,
                           clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject STARloop_original_source_codeSTAR,
    STARloop_source_contextSTAR, STARloop_iteration_variablesSTAR,
    STARloop_variablesSTAR, STARloop_nodeclareSTAR,
    STARloop_named_variablesSTAR, STARloop_declarationsSTAR,
    STARloop_desetq_crocksSTAR, STARloop_bind_stackSTAR,
    STARloop_prologueSTAR, STARloop_wrappersSTAR,
    STARloop_before_loopSTAR, STARloop_bodySTAR,
    STARloop_emitted_bodySTAR, STARloop_after_bodySTAR,
    STARloop_epilogueSTAR, STARloop_after_epilogueSTAR,
    STARloop_final_value_culpritSTAR, STARloop_inside_conditionalSTAR,
    STARloop_when_it_variableSTAR, STARloop_never_stepped_variableSTAR,
    STARloop_namesSTAR, STARloop_collection_cruftSTAR;
    clSetq(STARloop_original_source_codeSTAR,
           clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA));
    clSetq(STARloop_source_contextSTAR, clNIL);
    clSetq(STARloop_iteration_variablesSTAR, clNIL);
    clSetq(STARloop_variablesSTAR, clNIL);
    clSetq(STARloop_nodeclareSTAR, clNIL);
    clSetq(STARloop_named_variablesSTAR, clNIL);
    clSetq(STARloop_declarationsSTAR, clNIL);
    clSetq(STARloop_desetq_crocksSTAR, clNIL);
    clSetq(STARloop_bind_stackSTAR, clNIL);
    clSetq(STARloop_prologueSTAR, clNIL);
    clSetq(STARloop_wrappersSTAR, clNIL);
    clSetq(STARloop_before_loopSTAR, clNIL);
    clSetq(STARloop_bodySTAR, clNIL);
    clSetq(STARloop_emitted_bodySTAR, clNIL);
    clSetq(STARloop_after_bodySTAR, clNIL);
    clSetq(STARloop_epilogueSTAR, clNIL);
    clSetq(STARloop_after_epilogueSTAR, clNIL);
    clSetq(STARloop_final_value_culpritSTAR, clNIL);
    clSetq(STARloop_inside_conditionalSTAR, clNIL);
    clSetq(STARloop_when_it_variableSTAR, clNIL);
    clSetq(STARloop_never_stepped_variableSTAR, clNIL);
    clSetq(STARloop_namesSTAR, clNIL);
    clSetq(STARloop_collection_cruftSTAR, clNIL);
    clDbind(clstarLOOP_COLLECTION_CRUFTstar);
    clSetSymbolValueValue(clstarLOOP_COLLECTION_CRUFTstar,
                          STARloop_collection_cruftSTAR);
    clDbind(clstarLOOP_NAMESstar);
    clSetSymbolValueValue(clstarLOOP_NAMESstar, STARloop_namesSTAR);
    clDbind(clstarLOOP_NEVER_STEPPED_VARIABLEstar);
    clSetSymbolValueValue(clstarLOOP_NEVER_STEPPED_VARIABLEstar,
                          STARloop_never_stepped_variableSTAR);
    clDbind(clstarLOOP_WHEN_IT_VARIABLEstar);
    clSetSymbolValueValue(clstarLOOP_WHEN_IT_VARIABLEstar,
                          STARloop_when_it_variableSTAR);
    clDbind(clstarLOOP_INSIDE_CONDITIONALstar);
    clSetSymbolValueValue(clstarLOOP_INSIDE_CONDITIONALstar,
                          STARloop_inside_conditionalSTAR);
    clDbind(clstarLOOP_FINAL_VALUE_CULPRITstar);
    clSetSymbolValueValue(clstarLOOP_FINAL_VALUE_CULPRITstar,
                          STARloop_final_value_culpritSTAR);
    clDbind(clstarLOOP_AFTER_EPILOGUEstar);
    clSetSymbolValueValue(clstarLOOP_AFTER_EPILOGUEstar,
                          STARloop_after_epilogueSTAR);
    clDbind(clstarLOOP_EPILOGUEstar);
    clSetSymbolValueValue(clstarLOOP_EPILOGUEstar,
                          STARloop_epilogueSTAR);
    clDbind(clstarLOOP_AFTER_BODYstar);
    clSetSymbolValueValue(clstarLOOP_AFTER_BODYstar,
                          STARloop_after_bodySTAR);
    clDbind(clstarLOOP_EMITTED_BODYstar);
    clSetSymbolValueValue(clstarLOOP_EMITTED_BODYstar,
                          STARloop_emitted_bodySTAR);
    clDbind(clstarLOOP_BODYstar);
    clSetSymbolValueValue(clstarLOOP_BODYstar, STARloop_bodySTAR);
    clDbind(clstarLOOP_BEFORE_LOOPstar);
    clSetSymbolValueValue(clstarLOOP_BEFORE_LOOPstar,
                          STARloop_before_loopSTAR);
    clDbind(clstarLOOP_WRAPPERSstar);
    clSetSymbolValueValue(clstarLOOP_WRAPPERSstar,
                          STARloop_wrappersSTAR);
    clDbind(clstarLOOP_PROLOGUEstar);
    clSetSymbolValueValue(clstarLOOP_PROLOGUEstar,
                          STARloop_prologueSTAR);
    clDbind(clstarLOOP_BIND_STACKstar);
    clSetSymbolValueValue(clstarLOOP_BIND_STACKstar,
                          STARloop_bind_stackSTAR);
    clDbind(clstarLOOP_DESETQ_CROCKSstar);
    clSetSymbolValueValue(clstarLOOP_DESETQ_CROCKSstar,
                          STARloop_desetq_crocksSTAR);
    clDbind(clstarLOOP_DECLARATIONSstar);
    clSetSymbolValueValue(clstarLOOP_DECLARATIONSstar,
                          STARloop_declarationsSTAR);
    clDbind(clstarLOOP_NAMED_VARIABLESstar);
    clSetSymbolValueValue(clstarLOOP_NAMED_VARIABLESstar,
                          STARloop_named_variablesSTAR);
    clDbind(clstarLOOP_NODECLAREstar);
    clSetSymbolValueValue(clstarLOOP_NODECLAREstar,
                          STARloop_nodeclareSTAR);
    clDbind(clstarLOOP_VARIABLESstar);
    clSetSymbolValueValue(clstarLOOP_VARIABLESstar,
                          STARloop_variablesSTAR);
    clDbind(clstarLOOP_ITERATION_VARIABLESstar);
    clSetSymbolValueValue(clstarLOOP_ITERATION_VARIABLESstar,
                          STARloop_iteration_variablesSTAR);
    clDbind(clstarLOOP_SOURCE_CONTEXTstar);
    clSetSymbolValueValue(clstarLOOP_SOURCE_CONTEXTstar,
                          STARloop_source_contextSTAR);
    clDbind(clstarLOOP_ORIGINAL_SOURCE_CODEstar);
    clSetSymbolValueValue(clstarLOOP_ORIGINAL_SOURCE_CODEstar,
                          STARloop_original_source_codeSTAR);
    clLoopIterationDriver(clEOA);
    clLoopBindBlock(clEOA);
    { clObject answer;
      { clObject L_5, L_4, L_3, L_2, L_1;
        clSetq(L_1,
               clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                 clSymbolValue(clstarLOOP_PROLOGUEstar,
                                               clEOA),
                                 clEOA));
        clSetq(L_2,
               clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                 clSymbolValue(clstarLOOP_BEFORE_LOOPstar,
                                               clEOA),
                                 clEOA));
        clSetq(L_3,
               clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                 clSymbolValue(clstarLOOP_BODYstar,
                                               clEOA),
                                 clEOA));
        clSetq(L_4,
               clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                 clSymbolValue(clstarLOOP_AFTER_BODYstar,
                                               clEOA),
                                 clEOA));
        { clObject L_0__R1;
          clSetq(L_0__R1,
                 clSymbolValue(clstarLOOP_EPILOGUEstar, clEOA));
          clSetq(L_5,
                 clNreconc(L_0__R1,
                           clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                             clSymbolValue(clstarLOOP_AFTER_EPILOGUEstar,
                                                           clEOA),
                                             clEOA),
                           clEOA)); }
        clSetq(answer,
               clList(clLOOP_BODY, L_1, L_2, L_3, L_4, L_5, clEOA)); }
      { clLabel(l_ITERATE400);
        if (clTrue(clNIL)) clLocalReturn(NIL);
        { clObject L_2, L_1;
          { clObject L_top401;
            clSetq(L_top401,
                   clCar(clSymbolValue(clstarLOOP_NAMESstar, clEOA),
                         clEOA));
            clSetSymbolValueValue(clstarLOOP_NAMESstar,
                                  clCdr(clSymbolValue(clstarLOOP_NAMESstar,
                                                      clEOA),
                                        clEOA));
            clSetq(L_1, L_top401); }
          clSetq(L_2, answer);
          clSetq(answer, clList(clBLOCK, L_1, L_2, clEOA)); }
        if (clTrue(clNot(clSymbolValue(clstarLOOP_NAMESstar, clEOA),
                         clEOA)))
          clLocalReturn(NIL);
        goto l_ITERATE400; }
      clBlockEnd(NIL);
      { clObject L_sublist402, CL_entry;
        clSetq(L_sublist402,
               clSymbolValue(clstarLOOP_BIND_STACKstar, clEOA));
        clSetq(CL_entry, clCar(L_sublist402, clEOA));
        clLabel(l_ITERATE403);
        if (clTrue(clEndp(L_sublist402, clEOA)))
          clLocalReturn(NIL__r2);
        { clObject vars, dcls, crocks, wrappers;
          clSetq(vars, clFirst(CL_entry, clEOA));
          clSetq(dcls, clSecond(CL_entry, clEOA));
          clSetq(crocks, clThird(CL_entry, clEOA));
          clSetq(wrappers, clFourth(CL_entry, clEOA));
          { clObject L_sublist404, w;
            clSetq(L_sublist404, wrappers);
            clSetq(w, clCar(L_sublist404, clEOA));
            clLabel(l_ITERATE405);
            if (clTrue(clEndp(L_sublist404, clEOA)))
              clLocalReturn(NIL__r1);
            { clObject L_1;
              { clObject L_0__R1;
                clSetq(L_0__R1, answer);
                clSetq(L_1, clList(L_0__R1, clEOA)); }
              clSetq(answer, clAppend(w, L_1, clEOA)); }
            { clObject L_0;
              clSetq(L_0, L_sublist404);
              clSetq(L_sublist404, clCdr(L_0, clEOA)); }
            { clObject L_0;
              clSetq(L_0, L_sublist404);
              clSetq(w, clCar(L_0, clEOA)); }
            goto l_ITERATE405; }
          clBlockEnd(NIL__r1);
          if (clTrue((clTrue(vars) ?
                      vars :
                      (clTrue(dcls) ? dcls : crocks))))
            { clObject forms;
              { clObject L_0;
                clSetq(L_0, answer);
                clSetq(forms, clList(L_0, clEOA)); }
              if (clTrue(dcls))
                { clObject L_1, L_0;
                  clSetq(L_0, clListSTAR(clDECLARE, dcls, clEOA));
                  clSetq(L_1, forms);
                  clSetq(forms, clCons(L_0, L_1, clEOA)); }
              { clObject L_2, L_0;
                clSetq(L_0,
                       (clTrue(clNot(vars, clEOA)) ?
                        clLOCALLY :
                        (clTrue(clSymbolValue(clstarLOOP_DESTRUCTURING_HOOKSstar,
                                              clEOA)) ?
                         clFirst(clSymbolValue(clstarLOOP_DESTRUCTURING_HOOKSstar,
                                               clEOA),
                                 clEOA) :
                         clLET)));
                if (clTrue(crocks))
                  { clObject L_0__R1;
                    { clObject L_1__R1;
                      { clObject L_1__R2;
                        clSetq(L_1__R2, forms);
                        clSetq(L_1__R1,
                               clAppend(crocks, L_1__R2, clEOA)); }
                      clSetq(L_0__R1,
                             clListSTAR(clDESTRUCTURING_BIND,
                                        L_1__R1,
                                        clEOA)); }
                    clSetq(L_2, clList(L_0__R1, clEOA)); }
                else clSetq(L_2, forms);
                clSetq(answer,
                       clListSTAR(L_0, vars, L_2, clEOA)); } } }
        { clObject L_0;
          clSetq(L_0, L_sublist402);
          clSetq(L_sublist402, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist402);
          clSetq(CL_entry, clCar(L_0, clEOA)); }
        goto l_ITERATE403; }
      clBlockEnd(NIL__r2);
      clUnwindReturn(clValues1(answer), 26); } } }

clObject clLoopIterationDriver clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clLabel(l_ITERATE408);
    if (clTrue(clNull(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                      clEOA)))
      return(clValues1(clNIL));
    { clObject keyword, tem;
      clSetq(keyword,
             clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                   clEOA));
      clSetq(tem, clNIL);
      if (clTrue(clNot(clSymbolp(keyword, clEOA), clEOA)))
        clLoopError(STRn_42, keyword, clEOA);
      else
        { clSetSymbolValueValue(clstarLOOP_SOURCE_CONTEXTstar,
                                clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                              clEOA));
          clLoopPopSource(clEOA);
          if (clTrue(clSetq(tem,
                            clLoopLookupKeyword(keyword,
                                                clLoopUniverseKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                     clEOA),
                                                                       clEOA),
                                                clEOA))))
            { clObject L_1, L_0;
              { clObject L_0__R1;
                { clObject L_0__R2;
                  clSetq(L_0__R2, tem);
                  clSetq(L_0__R1, clFirst(L_0__R2, clEOA)); }
                clSetq(L_0, clSymbolFunction(L_0__R1, clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, tem);
                clSetq(L_1, clRest(L_0__R1, clEOA)); }
              clApply(L_0, L_1, clEOA); }
          else if (clTrue(clSetq(tem,
                                 clLoopLookupKeyword(keyword,
                                                     clLoopUniverseIterationKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                                   clEOA),
                                                                                     clEOA),
                                                     clEOA))))
            { clObject L_0;
              clSetq(L_0, tem);
              clLoopHackIteration(L_0, clEOA); }
          else if (clTrue(clLoopTmember(keyword, CONS_239, clEOA)))
            { clObject L_2;
              clSetq(L_2,
                     clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                         clEOA),
                           clEOA));
              clLoopError(STRn_43,
                          keyword,
                          L_2,
                          clCadr(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                               clEOA),
                                 clEOA),
                          clEOA); }
          else clLoopError(STRn_44, keyword, clEOA); } }
    goto l_ITERATE408; } }

clObject clLoopPopSource clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA)))
    { clObject L_top409;
      clSetq(L_top409,
             clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                   clEOA));
      clSetSymbolValueValue(clstarLOOP_SOURCE_CODEstar,
                            clCdr(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                                clEOA),
                                  clEOA));
      return(clValues1(L_top409)); }
  else return(clLoopError(STRn_45, clEOA)); }

clObject clLoopGetProgn clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject forms, nextform;
    clSetq(forms, clList(clLoopPopSource(clEOA), clEOA));
    clSetq(nextform,
           clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                 clEOA));
    clLabel(l_ITERATE410);
    if (clTrue(clAtom(nextform, clEOA)))
      if (clTrue(clNull(clCdr(forms, clEOA), clEOA)))
        return(clCar(forms, clEOA));
      else
        return(clCons(clPROGN,
                      clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                        forms,
                                        clEOA),
                      clEOA));
    { clObject L_value411, L_value412;
      { clObject L_0;
        clSetq(L_0, clLoopPopSource(clEOA));
        clSetq(L_value411, clCons(L_0, forms, clEOA)); }
      clSetq(L_value412,
             clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                   clEOA));
      clSetq(forms, L_value411);
      clSetq(nextform, L_value412); }
    goto l_ITERATE410; } }

clObject clLoopGetForm clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA)))
    return(clLoopPopSource(clEOA));
  else return(clLoopError(STRn_46, clEOA)); }

clObject clLoopConstructReturn clVdecl(_ap)
{ clObject form;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1;
    clSetq(L_1,
           clCar(clSymbolValue(clstarLOOP_NAMESstar, clEOA), clEOA));
    return(clList(clRETURN_FROM, L_1, form, clEOA)); } }

clObject clLoopPseudoBody clVdecl(_ap)
{ clObject form;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_g413;
      clSetq(L_g413,
             clSymbolValue(clstarLOOP_EMITTED_BODYstar, clEOA));
      clSetq(L_test,
             (clTrue(L_g413) ? L_g413 :
              clSymbolValue(clstarLOOP_INSIDE_CONDITIONALstar,
                            clEOA))); }
    if (clTrue(L_test))
      return(clValues1(clSetSymbolValueValue(clstarLOOP_BODYstar,
                                             clCons(form,
                                                    clSymbolValue(clstarLOOP_BODYstar,
                                                                  clEOA),
                                                    clEOA))));
    else
      { clSetSymbolValueValue(clstarLOOP_BEFORE_LOOPstar,
                              clCons(form,
                                     clSymbolValue(clstarLOOP_BEFORE_LOOPstar,
                                                   clEOA),
                                     clEOA));
        return(clValues1(clSetSymbolValueValue(clstarLOOP_AFTER_BODYstar,
                                               clCons(form,
                                                      clSymbolValue(clstarLOOP_AFTER_BODYstar,
                                                                    clEOA),
                                                      clEOA)))); } } }

clObject clLoopEmitBody clVdecl(_ap)
{ clObject form;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clSetSymbolValueValue(clstarLOOP_EMITTED_BODYstar, clT);
  return(clLoopPseudoBody(form, clEOA)); }

clObject clLoopEmitFinalValue clVdecl(_ap)
{ clObject form;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, clLoopConstructReturn(form, clEOA));
    clSetSymbolValueValue(clstarLOOP_AFTER_EPILOGUEstar,
                          clCons(L_0,
                                 clSymbolValue(clstarLOOP_AFTER_EPILOGUEstar,
                                               clEOA),
                                 clEOA)); }
  if (clTrue(clSymbolValue(clstarLOOP_FINAL_VALUE_CULPRITstar, clEOA)))
    clLoopWarn(STRn_47,
               clSymbolValue(clstarLOOP_FINAL_VALUE_CULPRITstar,
                             clEOA),
               clEOA);
  return(clValues1(clSetSymbolValueValue(clstarLOOP_FINAL_VALUE_CULPRITstar,
                                         clCar(clSymbolValue(clstarLOOP_SOURCE_CONTEXTstar,
                                                             clEOA),
                                               clEOA)))); }

clObject clLoopDisallowConditional clVdecl(_ap)
{ clObject kwd;
  { clBeginParse(_ap);
    clSetq(kwd, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolValue(clstarLOOP_INSIDE_CONDITIONALstar, clEOA)))
    { clObject L_1;
      clSetq(L_1, kwd);
      return(clLoopError(STRn_48, L_1, clEOA)); }
  else return(clValues1(clNIL)); }

clObject clLoopTypedInit clVdecl(_ap)
{ clObject data_type;
  { clBeginParse(_ap);
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(data_type))
    if (clTrue(clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                 data_type,
                                 clNUMBER,
                                 clEOA)))
      { clObject L_test__R2;
        { clObject L_g414;
          clSetq(L_g414,
                 clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                   data_type,
                                   clFLOAT,
                                   clEOA));
          clSetq(L_test__R2,
                 (clTrue(L_g414) ? L_g414 :
                  clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                    data_type,
                                    CONS_241,
                                    clEOA))); }
        if (clTrue(L_test__R2))
          return(clCoerce(I_0, data_type, clEOA));
        else return(clValues1(I_0)); }
    else if (clTrue(clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                      data_type,
                                      clCHARACTER,
                                      clEOA)))
      return(clValues1(C_Null));
    else if (clTrue(clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                      data_type,
                                      clVECTOR,
                                      clEOA)))
      return(clCoerce(clNIL, data_type, clEOA));
    else if (clTrue(clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                      data_type,
                                      clARRAY,
                                      clEOA)))
      return(clValues1(A_49));
    else if (clTrue(clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                      data_type,
                                      clCONS,
                                      clEOA)))
      return(clValues1(CONS_2));
    else return(clValues1(clNIL));
  else return(clValues1(clNIL)); }

clDeclareEnv(clLoopOptionalType_Translate);
static clObject clLoopOptionalType_Translate clVdecl(_ap)
{ clUseEnv(clLoopOptionalType_Translate);
  { clObject k, v;
    { clBeginParse(_ap);
      clSetq(k,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(v,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clNull(k, clEOA)))
      return(clValues1(clNIL));
    else if (clTrue(clAtom(k, clEOA)))
      { clObject L_0;
        { clObject L_g417;
          clSetq(L_g417,
                 clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                                   k,
                                   clLoopUniverseTypeSymbols(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                           clEOA),
                                                             clEOA),
                                   clEOA));
          if (clTrue(L_g417))
            clSetq(L_0, L_g417);
          else
            { clObject L_g418;
              { clObject L_0__R1;
                clSetq(L_0__R1, clSymbolName(k, clEOA));
                clSetq(L_g418,
                       clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                                         L_0__R1,
                                         clLoopUniverseTypeKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                  clEOA),
                                                                    clEOA),
                                         clEOA)); }
              clSetq(L_0,
                     (clTrue(L_g418) ?
                      L_g418 :
                      clLoopError(STRn_51,
                                  clEnv(1, *z),
                                  k,
                                  clEOA))); } }
        return(clFuncallFunction(clEnv(0, *_Replicate_),
                                 L_0,
                                 v,
                                 clEOA)); }
    else if (clTrue(clAtom(v, clEOA)))
      { clObject L_2;
        clSetq(L_2, clEnv(2, *variable));
        return(clLoopError(STRn_52, clEnv(1, *z), L_2, clEOA)); }
    else
      { clObject L_1, L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, clCar(k, clEOA));
          clSetq(L_0,
                 clFuncallFunction(clEnv(3, *_Translate_),
                                   L_0__R1,
                                   clCar(v, clEOA),
                                   clEOA)); }
        { clObject L_0__R1;
          clSetq(L_0__R1, clCdr(k, clEOA));
          clSetq(L_1,
                 clFuncallFunction(clEnv(3, *_Translate_),
                                   L_0__R1,
                                   clCdr(v, clEOA),
                                   clEOA)); }
        return(clCons(L_0, L_1, clEOA)); } } }

clDeclareEnv(clLoopOptionalType_Replicate);
static clObject clLoopOptionalType_Replicate clVdecl(_ap)
{ clUseEnv(clLoopOptionalType_Replicate);
  { clObject typ, v;
    { clBeginParse(_ap);
      clSetq(typ,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(v,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    if (clTrue(clAtom(v, clEOA)))
      return(clValues1(typ));
    else
      { clObject L_1, L_0;
        clSetq(L_0,
               clFuncallFunction(clEnv(0, *_Replicate_),
                                 typ,
                                 clCar(v, clEOA),
                                 clEOA));
        clSetq(L_1,
               clFuncallFunction(clEnv(0, *_Replicate_),
                                 typ,
                                 clCdr(v, clEOA),
                                 clEOA));
        return(clCons(L_0, L_1, clEOA)); } } }

clObject clLoopOptionalType clVdecl(_ap)
{ clObject *variable = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(*variable, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA)))
    { clObject *z = clMakeBinding();
      clSetq(*z,
             clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                   clEOA));
      if (clTrue(clLoopTequal(*z, clOF_TYPE, clEOA)))
        { clLoopPopSource(clEOA); return(clLoopPopSource(clEOA)); }
      else if (clTrue(clSymbolp(*z, clEOA)))
        { clObject type_spec;
          { clObject L_g416;
            clSetq(L_g416,
                   clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                                     *z,
                                     clLoopUniverseTypeSymbols(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                             clEOA),
                                                               clEOA),
                                     clEOA));
            if (clTrue(L_g416))
              clSetq(type_spec, L_g416);
            else
              { clObject L_0;
                clSetq(L_0, clSymbolName(*z, clEOA));
                clSetq(type_spec,
                       clFuncallFunction(clSymbolFunctionValue(clGETHASH),
                                         L_0,
                                         clLoopUniverseTypeKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                  clEOA),
                                                                    clEOA),
                                         clEOA)); } }
          if (clTrue(type_spec))
            { clLoopPopSource(clEOA); return(clValues1(type_spec)); }
          else return(clValues1(clNIL)); }
      else
        { { clObject L_test__R3;
            { clObject L_0;
              clSetq(L_0, *variable);
              clSetq(L_test__R3, clConsp(L_0, clEOA)); }
            if (clTrue(L_test__R3))
              { if (clTrue(clNot(clConsp(*z, clEOA), clEOA)))
                  clLoopError(STRn_49, *z, clEOA); }
            else clLoopError(STRn_50, *z, clEOA); }
          clLoopPopSource(clEOA);
          { clObject *_Replicate_ = clMakeBinding(),
            *_Translate_ = clMakeBinding();
            clSetq(*_Translate_,
                   clMakeClosure(4,
                                 clLoopOptionalType_Translate,
                                 &clEnvHook(clLoopOptionalType_Translate),
                                 &*_Replicate_,
                                 &*z,
                                 &*variable,
                                 &*_Translate_));
            clSetq(*_Replicate_,
                   clMakeClosure(1,
                                 clLoopOptionalType_Replicate,
                                 &clEnvHook(clLoopOptionalType_Replicate),
                                 &*_Replicate_));
            { clObject L_1, L_0;
              clSetq(L_0, *z);
              clSetq(L_1, *variable);
              return(clFuncallFunction(*_Translate_,
                                       L_0,
                                       L_1,
                                       clEOA)); } } } }
  else return(clValues1(clNIL)); }

clObject clLoopBindBlock clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_g419;
      clSetq(L_g419, clSymbolValue(clstarLOOP_VARIABLESstar, clEOA));
      if (clTrue(L_g419))
        clSetq(L_test, L_g419);
      else
        { clObject L_g420;
          clSetq(L_g420,
                 clSymbolValue(clstarLOOP_DECLARATIONSstar, clEOA));
          clSetq(L_test,
                 (clTrue(L_g420) ? L_g420 :
                  clSymbolValue(clstarLOOP_WRAPPERSstar, clEOA))); } }
    if (clTrue(L_test))
      { { clObject L_0;
          { clObject L_2, L_1__R1, L_0__R1;
            clSetq(L_0__R1,
                   clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                     clSymbolValue(clstarLOOP_VARIABLESstar,
                                                   clEOA),
                                     clEOA));
            clSetq(L_1__R1,
                   clSymbolValue(clstarLOOP_DECLARATIONSstar, clEOA));
            clSetq(L_2,
                   clSymbolValue(clstarLOOP_DESETQ_CROCKSstar, clEOA));
            clSetq(L_0,
                   clList(L_0__R1,
                          L_1__R1,
                          L_2,
                          clSymbolValue(clstarLOOP_WRAPPERSstar,
                                        clEOA),
                          clEOA)); }
          clSetSymbolValueValue(clstarLOOP_BIND_STACKstar,
                                clCons(L_0,
                                       clSymbolValue(clstarLOOP_BIND_STACKstar,
                                                     clEOA),
                                       clEOA)); }
        clSetSymbolValueValue(clstarLOOP_VARIABLESstar, clNIL);
        clSetSymbolValueValue(clstarLOOP_DECLARATIONSstar, clNIL);
        clSetSymbolValueValue(clstarLOOP_DESETQ_CROCKSstar, clNIL);
        return(clValues1(clSetSymbolValueValue(clstarLOOP_WRAPPERSstar,
                                               clNIL))); }
    else return(clValues1(clNIL)); } }

clObject clLoopMakeVariable clVdecl(_ap)
{ clObject name, initialization, dtype, iteration_variable_p;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(initialization,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(dtype,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(iteration_variable_p, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clNull(name, clEOA)))
    { if (clTrue(clNot(clNull(initialization, clEOA), clEOA)))
        { { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1,
                     clSetq(name,
                            clLoopGentemp(clLOOP_IGNORE_, clEOA)));
              clSetq(L_0, clList(L_0__R1, initialization, clEOA)); }
            clSetSymbolValueValue(clstarLOOP_VARIABLESstar,
                                  clCons(L_0,
                                         clSymbolValue(clstarLOOP_VARIABLESstar,
                                                       clEOA),
                                         clEOA)); }
          { clObject L_0;
            { clObject L_1__R1;
              clSetq(L_1__R1, name);
              clSetq(L_0, clList(clIGNORE, L_1__R1, clEOA)); }
            clSetSymbolValueValue(clstarLOOP_DECLARATIONSstar,
                                  clCons(L_0,
                                         clSymbolValue(clstarLOOP_DECLARATIONSstar,
                                                       clEOA),
                                         clEOA)); } } }
  else
    { clObject L_test__R1;
      { clObject L_0;
        clSetq(L_0, name);
        clSetq(L_test__R1, clAtom(L_0, clEOA)); }
      if (clTrue(L_test__R1))
        { if (clTrue(iteration_variable_p))
            { clObject L_test__R3;
              { clObject L_item422, L_sub421;
                clSetq(L_item422, name);
                clSetq(L_sub421,
                       clSymbolValue(clstarLOOP_ITERATION_VARIABLESstar,
                                     clEOA));
                clLabel(l_ITERATE424);
                if (clTrue(clEndp(L_sub421, clEOA)))
                  { clSetq(L_test__R3, clNIL);
                    clLocalReturn(NIL__r3); }
                if (clTrue(clEql(L_item422,
                                 clCar(L_sub421, clEOA),
                                 clEOA)))
                  { clSetq(L_test__R3, L_sub421);
                    clLocalReturn(l_MEMBER423__r3); }
                { clObject L_value425;
                  clSetq(L_value425, clCdr(L_sub421, clEOA));
                  clSetq(L_sub421, L_value425); }
                goto l_ITERATE424; }
              clBlockEnd(NIL__r3);
              clBlockEnd(l_MEMBER423__r3);
              if (clTrue(L_test__R3))
                { clObject L_1;
                  clSetq(L_1, name);
                  clLoopError(STRn_53, L_1, clEOA); }
              else
                { clObject L_0;
                  clSetq(L_0, name);
                  clSetSymbolValueValue(clstarLOOP_ITERATION_VARIABLESstar,
                                        clCons(L_0,
                                               clSymbolValue(clstarLOOP_ITERATION_VARIABLESstar,
                                                             clEOA),
                                               clEOA)); } }
          else
            { clObject L_test__R3;
              { clObject L_0;
                clSetq(L_0, name);
                clSetq(L_test__R3,
                       clAssoc(L_0,
                               clSymbolValue(clstarLOOP_VARIABLESstar,
                                             clEOA),
                               clEOA)); }
              if (clTrue(L_test__R3))
                { clObject L_1;
                  clSetq(L_1, name);
                  clLoopError(STRn_54, L_1, clEOA); } }
          { clObject L_test__R2;
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, name);
                clSetq(L_0, clSymbolp(L_0__R1, clEOA)); }
              clSetq(L_test__R2, clNot(L_0, clEOA)); }
            if (clTrue(L_test__R2))
              { clObject L_1;
                clSetq(L_1, name);
                clLoopError(STRn_55, L_1, clEOA); } }
          { clObject L_0;
            clSetq(L_0, name);
            clLoopDeclareVariable(L_0, dtype, clEOA); }
          { clObject L_0;
            { clObject L_1__R1, L_0__R1;
              clSetq(L_0__R1, name);
              clSetq(L_1__R1,
                     (clTrue(initialization) ?
                      initialization :
                      clLoopTypedInit(dtype, clEOA)));
              clSetq(L_0, clList(L_0__R1, L_1__R1, clEOA)); }
            clSetSymbolValueValue(clstarLOOP_VARIABLESstar,
                                  clCons(L_0,
                                         clSymbolValue(clstarLOOP_VARIABLESstar,
                                                       clEOA),
                                         clEOA)); } }
      else if (clTrue(initialization))
        if (clTrue(clSymbolValue(clstarLOOP_DESTRUCTURING_HOOKSstar,
                                 clEOA)))
          { { clObject L_0;
              clSetq(L_0, name);
              clLoopDeclareVariable(L_0, dtype, clEOA); }
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, name);
                clSetq(L_0, clList(L_0__R1, initialization, clEOA)); }
              clSetSymbolValueValue(clstarLOOP_VARIABLESstar,
                                    clCons(L_0,
                                           clSymbolValue(clstarLOOP_VARIABLESstar,
                                                         clEOA),
                                           clEOA)); } }
        else
          { clObject newvar;
            clSetq(newvar, clLoopGentemp(clLOOP_DESTRUCTURE_, clEOA));
            { clObject L_0;
              clSetq(L_0, clList(newvar, initialization, clEOA));
              clSetSymbolValueValue(clstarLOOP_VARIABLESstar,
                                    clCons(L_0,
                                           clSymbolValue(clstarLOOP_VARIABLESstar,
                                                         clEOA),
                                           clEOA)); }
            { clObject L_0;
              clSetq(L_0, name);
              clSetSymbolValueValue(clstarLOOP_DESETQ_CROCKSstar,
                                    clListSTAR(L_0,
                                               newvar,
                                               clSymbolValue(clstarLOOP_DESETQ_CROCKSstar,
                                                             clEOA),
                                               clEOA)); } }
      else
        { clObject tcar, tcdr;
          clSetq(tcar, clNIL);
          clSetq(tcdr, clNIL);
          if (clTrue(clAtom(dtype, clEOA)))
            clSetq(tcar, clSetq(tcdr, dtype));
          else
            { clSetq(tcar, clCar(dtype, clEOA));
              clSetq(tcdr, clCdr(dtype, clEOA)); }
          { clObject L_3, L_2, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, name);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_2, tcar);
            clSetq(L_3, iteration_variable_p);
            clLoopMakeVariable(L_0, clNIL, L_2, L_3, clEOA); }
          { clObject L_3, L_2, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, name);
              clSetq(L_0, clCdr(L_0__R1, clEOA)); }
            clSetq(L_2, tcdr);
            clSetq(L_3, iteration_variable_p);
            clLoopMakeVariable(L_0, clNIL, L_2, L_3, clEOA); } } }
  return(clValues1(name)); }

clObject clLoopMakeIterationVariable clVdecl(_ap)
{ clObject name, initialization, dtype;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(initialization,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(dtype,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clLoopMakeVariable(name, initialization, dtype, clT, clEOA)); }

clObject clLoopDeclareVariable clVdecl(_ap)
{ clObject name, dtype;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(dtype,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_g427;
      clSetq(L_g427, clNull(name, clEOA));
      if (clTrue(L_g427))
        clSetq(L_test, L_g427);
      else
        { clObject L_g428;
          clSetq(L_g428, clNull(dtype, clEOA));
          clSetq(L_test,
                 (clTrue(L_g428) ? L_g428 :
                  clEq(dtype, clT, clEOA))); } }
    if (clTrue(L_test))
      return(clValues1(clNIL));
    else if (clTrue(clSymbolp(name, clEOA)))
      { clObject L_test__R2;
        { clObject L_0;
          { clObject L_g429;
            clSetq(L_g429, clEq(dtype, clT, clEOA));
            if (clTrue(L_g429))
              clSetq(L_0, L_g429);
            else
              { { clObject L_sub430;
                  clSetq(L_sub430,
                         clSymbolValue(clstarLOOP_NODECLAREstar,
                                       clEOA));
                  clLabel(l_ITERATE433);
                  if (clTrue(clEndp(L_sub430, clEOA)))
                    { clSetq(L_0, clNIL); clLocalReturn(NIL); }
                  if (clTrue(clEql(name,
                                   clCar(L_sub430, clEOA),
                                   clEOA)))
                    { clSetq(L_0, L_sub430);
                      clLocalReturn(l_MEMBER432); }
                  { clObject L_value434;
                    clSetq(L_value434, clCdr(L_sub430, clEOA));
                    clSetq(L_sub430, L_value434); }
                  goto l_ITERATE433; }
                clBlockEnd(NIL);
                clBlockEnd(l_MEMBER432); } }
          clSetq(L_test__R2, clNot(L_0, clEOA)); }
        if (clTrue(L_test__R2))
          { clObject L_0;
            clSetq(L_0, clList(clTYPE, dtype, name, clEOA));
            return(clValues1(clSetSymbolValueValue(clstarLOOP_DECLARATIONSstar,
                                                   clCons(L_0,
                                                          clSymbolValue(clstarLOOP_DECLARATIONSstar,
                                                                        clEOA),
                                                          clEOA)))); }
        else return(clValues1(clNIL)); }
    else if (clTrue(clConsp(name, clEOA)))
      if (clTrue(clConsp(dtype, clEOA)))
        { { clObject L_0;
            clSetq(L_0, clCar(name, clEOA));
            clLoopDeclareVariable(L_0, clCar(dtype, clEOA), clEOA); }
          { clObject L_0;
            clSetq(L_0, clCdr(name, clEOA));
            return(clLoopDeclareVariable(L_0,
                                         clCdr(dtype, clEOA),
                                         clEOA)); } }
      else
        { { clObject L_0;
            clSetq(L_0, clCar(name, clEOA));
            clLoopDeclareVariable(L_0, dtype, clEOA); }
          { clObject L_0;
            clSetq(L_0, clCdr(name, clEOA));
            return(clLoopDeclareVariable(L_0, dtype, clEOA)); } }
    else return(clError(STRn_56, name, clEOA)); } }

clObject clLoopMaybeBindForm clVdecl(_ap)
{ clObject form, data_type;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clLoopConstantp(form, clEOA)))
    return(clValues1(form));
  else
    { clObject L_0;
      clSetq(L_0, clLoopGentemp(clLOOP_BIND_, clEOA));
      return(clLoopMakeVariable(L_0, form, data_type, clEOA)); } }

clDeclareEnv(clLoopDoIf_GetClause);
static clObject clLoopDoIf_GetClause clVdecl(_ap)
{ clUseEnv(clLoopDoIf_GetClause);
  { clObject CL_for;
    { clBeginParse(_ap);
      clSetq(CL_for,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject body;
      clSetq(body, clNIL);
      clLabel(l_ITERATE435);
      if (clTrue(clNIL)) return(clValues1(clNIL));
      { clObject key, STARloop_bodySTAR, data;
        clSetq(key,
               clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                     clEOA));
        clSetq(STARloop_bodySTAR, clNIL);
        clSetq(data, clNIL);
        clDbind(clstarLOOP_BODYstar);
        clSetSymbolValueValue(clstarLOOP_BODYstar, STARloop_bodySTAR);
        if (clTrue(clNot(clSymbolp(key, clEOA), clEOA)))
          clLoopError(STRn_57, key, CL_for, clEOA);
        else
          { clSetSymbolValueValue(clstarLOOP_SOURCE_CONTEXTstar,
                                  clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                                clEOA));
            clLoopPopSource(clEOA);
            { clObject L_test__R1;
              { clObject L_0;
                clSetq(L_0,
                       clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                           clEOA),
                             clEOA));
                clSetq(L_test__R1, clLoopTequal(L_0, clIT, clEOA)); }
              if (clTrue(L_test__R1))
                { clObject L_0;
                  clSetq(L_0,
                         (clTrue(clEnv(0, *it_p)) ?
                          clEnv(0, *it_p) :
                          clSetq(clEnv(0, *it_p),
                                 clLoopWhenItVariable(clEOA))));
                  clSetSymbolValueValue(clstarLOOP_SOURCE_CODEstar,
                                        clCons(L_0,
                                               clCdr(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                                                   clEOA),
                                                     clEOA),
                                               clEOA)); } }
            { clObject L_test__R1;
              { clObject L_g437;
                { clObject L_0;
                  clSetq(L_0,
                         clSetq(data,
                                clLoopLookupKeyword(key,
                                                    clLoopUniverseKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                         clEOA),
                                                                           clEOA),
                                                    clEOA)));
                  clSetq(L_g437, clNot(L_0, clEOA)); }
                if (clTrue(L_g437))
                  clSetq(L_test__R1, L_g437);
                else
                  { { clObject L_1, L_0;
                      { clObject L_0__R1;
                        { clObject L_0__R2;
                          clSetq(L_0__R2, data);
                          clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
                        clSetq(L_0,
                               clSymbolFunction(L_0__R1, clEOA)); }
                      { clObject L_0__R1;
                        clSetq(L_0__R1, data);
                        clSetq(L_1, clCdr(L_0__R1, clEOA)); }
                      clApply(L_0, L_1, clEOA); }
                    clSetq(L_test__R1,
                           clNull(clSymbolValue(clstarLOOP_BODYstar,
                                                clEOA),
                                  clEOA)); } }
              if (clTrue(L_test__R1))
                clLoopError(STRn_58, key, CL_for, clEOA);
              else
                { clObject L_1, L_0;
                  clSetq(L_0,
                         clSymbolValue(clstarLOOP_BODYstar, clEOA));
                  clSetq(L_1, body);
                  clSetq(body, clNreconc(L_0, L_1, clEOA)); } } }
        clUnwind(1); }
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0,
                 clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                     clEOA),
                       clEOA));
          clSetq(L_test, clLoopTequal(L_0, keyAND, clEOA)); }
        if (clTrue(L_test))
          clLoopPopSource(clEOA);
        else
          { clObject L_test__R1;
            { clObject L_0;
              clSetq(L_0, body);
              clSetq(L_test__R1, clCdr(L_0, clEOA)); }
            if (clTrue(L_test__R1))
              { clObject L_1;
                { clObject L_0__R1;
                  clSetq(L_0__R1, body);
                  clSetq(L_1,
                         clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                           L_0__R1,
                                           clEOA)); }
                return(clListSTAR(clPROGN, L_1, clEOA)); }
            else
              { clObject L_0;
                clSetq(L_0, body);
                return(clCar(L_0, clEOA)); } } }
      goto l_ITERATE435; } } }

clObject clLoopDoIf clVdecl(_ap)
{ clObject CL_for, negatep;
  { clBeginParse(_ap);
    clSetq(CL_for,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(negatep,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject form, STARloop_inside_conditionalSTAR,
    *it_p = clMakeBinding();
    clSetq(form, clLoopGetForm(clEOA));
    clSetq(STARloop_inside_conditionalSTAR, clT);
    clSetq(*it_p, clNIL);
    clDbind(clstarLOOP_INSIDE_CONDITIONALstar);
    clSetSymbolValueValue(clstarLOOP_INSIDE_CONDITIONALstar,
                          STARloop_inside_conditionalSTAR);
    { clObject _GetClause_;
      clSetq(_GetClause_,
             clMakeClosure(1,
                           clLoopDoIf_GetClause,
                           &clEnvHook(clLoopDoIf_GetClause),
                           &*it_p));
      { clObject then, CL_else;
        clSetq(then, clFuncallFunction(_GetClause_, CL_for, clEOA));
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0,
                   clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                       clEOA),
                         clEOA));
            clSetq(L_test, clLoopTequal(L_0, keyELSE, clEOA)); }
          clSetq(CL_else,
                 (clTrue(L_test) ?
                  (clLoopPopSource(clEOA),
                   clList(clFuncallFunction(_GetClause_,
                                            keyELSE,
                                            clEOA),
                          clEOA)) :
                  clNIL)); }
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0,
                   clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                       clEOA),
                         clEOA));
            clSetq(L_test, clLoopTequal(L_0, keyEND, clEOA)); }
          if (clTrue(L_test)) clLoopPopSource(clEOA); }
        if (clTrue(*it_p))
          { clObject L_2, L_1;
            clSetq(L_1, *it_p);
            clSetq(L_2, form);
            clSetq(form, clList(clSETQ, L_1, L_2, clEOA)); }
        { clObject L_0;
          { clObject L_3, L_1;
            if (clTrue(negatep))
              { clObject L_1__R1;
                clSetq(L_1__R1, form);
                clSetq(L_1, clList(clNOT, L_1__R1, clEOA)); }
            else clSetq(L_1, form);
            clSetq(L_3, CL_else);
            clSetq(L_0, clListSTAR(clIF, L_1, then, L_3, clEOA)); }
          clUnwindReturn(clLoopPseudoBody(L_0, clEOA), 1); } } } } }

clObject clLoopDoInitially clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLoopDisallowConditional(keyINITIALLY, clEOA);
  { clObject L_0;
    clSetq(L_0, clLoopGetProgn(clEOA));
    return(clValues1(clSetSymbolValueValue(clstarLOOP_PROLOGUEstar,
                                           clCons(L_0,
                                                  clSymbolValue(clstarLOOP_PROLOGUEstar,
                                                                clEOA),
                                                  clEOA)))); } }

clObject clLoopDoFinally clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLoopDisallowConditional(keyFINALLY, clEOA);
  { clObject L_0;
    clSetq(L_0, clLoopGetProgn(clEOA));
    return(clValues1(clSetSymbolValueValue(clstarLOOP_EPILOGUEstar,
                                           clCons(L_0,
                                                  clSymbolValue(clstarLOOP_EPILOGUEstar,
                                                                clEOA),
                                                  clEOA)))); } }

clObject clLoopDoDo clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clLoopEmitBody(clLoopGetProgn(clEOA), clEOA)); }

clObject clLoopDoNamed clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject name;
    clSetq(name, clLoopPopSource(clEOA));
    if (clTrue(clNot(clSymbolp(name, clEOA), clEOA)))
      clLoopError(STRn_64, name, clEOA);
    { clObject L_test;
      { clObject L_g438;
        clSetq(L_g438,
               clSymbolValue(clstarLOOP_BEFORE_LOOPstar, clEOA));
        if (clTrue(L_g438))
          clSetq(L_test, L_g438);
        else
          { clObject L_g439;
            clSetq(L_g439, clSymbolValue(clstarLOOP_BODYstar, clEOA));
            if (clTrue(L_g439))
              clSetq(L_test, L_g439);
            else
              { clObject L_g440;
                clSetq(L_g440,
                       clSymbolValue(clstarLOOP_AFTER_EPILOGUEstar,
                                     clEOA));
                clSetq(L_test,
                       (clTrue(L_g440) ?
                        L_g440 :
                        clSymbolValue(clstarLOOP_INSIDE_CONDITIONALstar,
                                      clEOA))); } } }
      if (clTrue(L_test)) clLoopError(STRn_65, name, clEOA); }
    if (clTrue(clSymbolValue(clstarLOOP_NAMESstar, clEOA)))
      { clObject L_1;
        clSetq(L_1,
               clCar(clSymbolValue(clstarLOOP_NAMESstar, clEOA),
                     clEOA));
        clLoopError(STRn_66, L_1, name, clEOA); }
    return(clValues1(clSetSymbolValueValue(clstarLOOP_NAMESstar,
                                           clList(name,
                                                  clNIL,
                                                  clEOA)))); } }

clObject clLoopDoReturn clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clLoopPseudoBody(clLoopConstructReturn(clLoopGetForm(clEOA),
                                                clEOA),
                          clEOA)); }

clObject clMakeLoopCollector clVdecl(_ap)
{ clObject L_ap, L_keys, L_name, L_class, L_history, L_tempvars,
  L_dtype, L_data;
  { clBeginParse(_ap);
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyNAME, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_name, clCar(L_0, clEOA)); }
    else clSetq(L_name, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyCLASS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_class, clCar(L_0, clEOA)); }
    else clSetq(L_class, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyHISTORY, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_history, clCar(L_0, clEOA)); }
    else clSetq(L_history, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyTEMPVARS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_tempvars, clCar(L_0, clEOA)); }
    else clSetq(L_tempvars, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyDTYPE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_dtype, clCar(L_0, clEOA)); }
    else clSetq(L_dtype, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyDATA, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_data, clCar(L_0, clEOA)); }
    else clSetq(L_data, clNIL);
    clCheckKeys(L_keys, CONS_276, clEOA);
    clEndParse(_ap); }
  { clObject L_6, L_5, L_4, L_3, L_2, L_1;
    clSetq(L_1, L_name);
    clSetq(L_2, L_class);
    clSetq(L_3, L_history);
    clSetq(L_4, L_tempvars);
    clSetq(L_5, L_dtype);
    clSetq(L_6, L_data);
    return(clMakeStructure(clLOOP_COLLECTOR,
                           L_1,
                           L_2,
                           L_3,
                           L_4,
                           L_5,
                           L_6,
                           clEOA)); } }

clObject clLoopCollectorName clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_0, clEOA)); }

clObject cl_SETF_LoopCollectorName clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_0, clEOA)); }

clObject clLoopCollectorClass clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_1, clEOA)); }

clObject cl_SETF_LoopCollectorClass clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_1, clEOA)); }

clObject clLoopCollectorHistory clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_2, clEOA)); }

clObject cl_SETF_LoopCollectorHistory clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_2, clEOA)); }

clObject clLoopCollectorTempvars clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_3, clEOA)); }

clObject cl_SETF_LoopCollectorTempvars clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_3, clEOA)); }

clObject clLoopCollectorDtype clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_4, clEOA)); }

clObject cl_SETF_LoopCollectorDtype clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_4, clEOA)); }

clObject clLoopCollectorData clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_5, clEOA)); }

clObject cl_SETF_LoopCollectorData clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_5, clEOA)); }

clObject clLoopGetCollectionInfo clVdecl(_ap)
{ clObject collector, CL_class, default_type;
  { clBeginParse(_ap);
    clSetq(collector,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(default_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject form, dtype, name;
    clSetq(form, clLoopGetForm(clEOA));
    clSetq(dtype,
           (clTrue(clNot(clLoopUniverseAnsi(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                          clEOA),
                                            clEOA),
                         clEOA)) ?
            clLoopOptionalType(clEOA) : clNIL));
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0,
               clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                     clEOA));
        clSetq(L_test, clLoopTequal(L_0, clINTO, clEOA)); }
      clSetq(name,
             (clTrue(L_test) ?
              (clLoopPopSource(clEOA), clLoopPopSource(clEOA)) :
              clNIL)); }
    { clObject L_test;
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, name);
          clSetq(L_0, clSymbolp(L_0__R1, clEOA)); }
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test))
        { clObject L_1;
          clSetq(L_1, name);
          clLoopError(STRn_74, L_1, clEOA); } }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0, dtype);
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test))
        { clObject L_g459;
          clSetq(L_g459, clLoopOptionalType(clEOA));
          clSetq(dtype, (clTrue(L_g459) ? L_g459 : default_type)); } }
    { clObject cruft;
      { clObject L_1, L_0;
        clSetq(L_0, name);
        clSetq(L_1,
               clSymbolValue(clstarLOOP_COLLECTION_CRUFTstar, clEOA));
        clSetq(cruft,
               clFind(L_0,
                      L_1,
                      keyKEY,
                      clSymbolFunctionValue(clLOOP_COLLECTOR_NAME),
                      clEOA)); }
      if (clTrue(clNot(cruft, clEOA)))
        { clObject L_0;
          { clObject L_7, L_5, L_1__R1;
            clSetq(L_1__R1, name);
            clSetq(L_5, clList(collector, clEOA));
            clSetq(L_7, dtype);
            clSetq(L_0,
                   clSetq(cruft,
                          clMakeLoopCollector(keyNAME,
                                              L_1__R1,
                                              keyCLASS,
                                              CL_class,
                                              keyHISTORY,
                                              L_5,
                                              keyDTYPE,
                                              L_7,
                                              clEOA))); }
          clSetSymbolValueValue(clstarLOOP_COLLECTION_CRUFTstar,
                                clCons(L_0,
                                       clSymbolValue(clstarLOOP_COLLECTION_CRUFTstar,
                                                     clEOA),
                                       clEOA)); }
      else
        { { clObject L_test__R1;
            { clObject L_0;
              { clObject L_0__R1;
                { clObject L_0__R2;
                  clSetq(L_0__R2, cruft);
                  clSetq(L_0__R1,
                         clLoopCollectorClass(L_0__R2, clEOA)); }
                clSetq(L_0, clEq(L_0__R1, CL_class, clEOA)); }
              clSetq(L_test__R1, clNot(L_0, clEOA)); }
            if (clTrue(L_test__R1))
              { clObject L_2, L_1;
                clSetq(L_1, name);
                { clObject L_0__R1;
                  { clObject L_0__R2;
                    clSetq(L_0__R2, cruft);
                    clSetq(L_0__R1,
                           clLoopCollectorHistory(L_0__R2, clEOA)); }
                  clSetq(L_2, clCar(L_0__R1, clEOA)); }
                clLoopError(STRn_76, L_1, L_2, collector, clEOA); } }
          { clObject L_test__R1;
            { clObject L_0;
              { clObject L_1, L_0__R1;
                clSetq(L_0__R1, dtype);
                { clObject L_0__R2;
                  clSetq(L_0__R2, cruft);
                  clSetq(L_1, clLoopCollectorDtype(L_0__R2, clEOA)); }
                clSetq(L_0,
                       clFuncallFunction(clSymbolFunctionValue(clEQUAL),
                                         L_0__R1,
                                         L_1,
                                         clEOA)); }
              clSetq(L_test__R1, clNot(L_0, clEOA)); }
            if (clTrue(L_test__R1))
              { { clObject L_3, L_2, L_1;
                  clSetq(L_1, name);
                  clSetq(L_2, dtype);
                  { clObject L_0__R1;
                    clSetq(L_0__R1, cruft);
                    clSetq(L_3,
                           clLoopCollectorDtype(L_0__R1, clEOA)); }
                  clLoopWarn(STRn_77, L_1, L_2, L_3, clEOA); }
                { clObject L_test__R2;
                  { clObject L_0;
                    { clObject L_0__R1;
                      clSetq(L_0__R1, cruft);
                      clSetq(L_0,
                             clLoopCollectorDtype(L_0__R1, clEOA)); }
                    clSetq(L_test__R2, clEq(L_0, clT, clEOA)); }
                  if (clTrue(L_test__R2))
                    { clObject L_arg461, L_value460;
                      clSetq(L_arg461, cruft);
                      clSetq(L_value460, dtype);
                      cl_SETF_LoopCollectorDtype(L_value460,
                                                 L_arg461,
                                                 clEOA); } } } }
          { clObject L_arg463, L_value462;
            clSetq(L_arg463, cruft);
            clSetq(L_value462,
                   clCons(collector,
                          clLoopCollectorHistory(L_arg463, clEOA),
                          clEOA));
            cl_SETF_LoopCollectorHistory(L_value462,
                                         L_arg463,
                                         clEOA); } }
      { clObject L_0;
        clSetq(L_0, cruft);
        return(clValues(L_0, form, clEOA)); } } } }

clObject clLoopListCollection clVdecl(_ap)
{ clObject specifically;
  { clBeginParse(_ap);
    clSetq(specifically,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values464, lc, form;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clLoopGetCollectionInfo(specifically, clLIST, clLIST, clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values464, clMultipleValueFuncall(MVC)); }
    clSetq(lc, clCar(L_values464, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values464);
        clSetq(L_0, clSetq(L_values464, clCdr(L_0__R1, clEOA))); }
      clSetq(form, clCar(L_0, clEOA)); }
    { clObject tempvars;
      clSetq(tempvars, clLoopCollectorTempvars(lc, clEOA));
      if (clTrue(clNot(tempvars, clEOA)))
        { { clObject L_value465;
            { clObject L_2, L_1, L_0;
              clSetq(L_0, clLoopGentemp(clLOOP_LIST_HEAD_, clEOA));
              clSetq(L_1, clLoopGentemp(clLOOP_LIST_TAIL_, clEOA));
              clSetq(L_2,
                     (clTrue(clLoopCollectorName(lc, clEOA)) ?
                      clList(clLoopCollectorName(lc, clEOA), clEOA) :
                      clNIL));
              clSetq(L_value465,
                     clSetq(tempvars,
                            clListSTAR(L_0, L_1, L_2, clEOA))); }
            cl_SETF_LoopCollectorTempvars(L_value465, lc, clEOA); }
          { clObject L_0;
            { clObject L_1__R1;
              clSetq(L_1__R1, tempvars);
              clSetq(L_0,
                     clList(clWITH_LOOP_LIST_COLLECTION_HEAD,
                            L_1__R1,
                            clEOA)); }
            clSetSymbolValueValue(clstarLOOP_WRAPPERSstar,
                                  clCons(L_0,
                                         clSymbolValue(clstarLOOP_WRAPPERSstar,
                                                       clEOA),
                                         clEOA)); }
          if (clTrue(clNot(clLoopCollectorName(lc, clEOA), clEOA)))
            { clObject L_0;
              { clObject L_2, L_1;
                { clObject L_0__R2;
                  clSetq(L_0__R2, tempvars);
                  clSetq(L_1, clCar(L_0__R2, clEOA)); }
                { clObject L_0__R2;
                  clSetq(L_0__R2, tempvars);
                  clSetq(L_2, clCddr(L_0__R2, clEOA)); }
                clSetq(L_0,
                       clListSTAR(clLOOP_COLLECT_ANSWER,
                                  L_1,
                                  L_2,
                                  clEOA)); }
              clLoopEmitFinalValue(L_0, clEOA); } }
      if (_clEq(specifically, clLIST))
        { clObject L_1;
          clSetq(L_1, form);
          clSetq(form, clList(clLIST, L_1, clEOA)); }
      else if (!_clEq(specifically, clNCONC))
        if (_clEq(specifically, clAPPEND))
          { clObject L_test__R3;
            { clObject L_0;
              { clObject L_test__R4;
                { clObject L_0__R1;
                  clSetq(L_0__R1, form);
                  clSetq(L_test__R4, clConsp(L_0__R1, clEOA)); }
                if (clTrue(L_test__R4))
                  { clObject L_0__R1;
                    { clObject L_0__R2;
                      clSetq(L_0__R2, form);
                      clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
                    clSetq(L_0, clEq(L_0__R1, clLIST, clEOA)); }
                else clSetq(L_0, clNIL); }
              clSetq(L_test__R3, clNot(L_0, clEOA)); }
            if (clTrue(L_test__R3))
              { clObject L_1;
                clSetq(L_1, form);
                clSetq(form,
                       clList(clLOOP_COPYLISTstar, L_1, clEOA)); } }
        else
          clError(clTYPE_ERROR, keyDATUM, specifically,
                  keyEXPECTED_TYPE, CONS_294, clEOA);
      { clObject L_0;
        { clObject L_2, L_1;
          clSetq(L_1, tempvars);
          clSetq(L_2, form);
          clSetq(L_0,
                 clList(clLOOP_COLLECT_RPLACD, L_1, L_2, clEOA)); }
        return(clLoopEmitBody(L_0, clEOA)); } } } }

clObject clLoopSumCollection clVdecl(_ap)
{ clObject specifically, required_type, default_type;
  { clBeginParse(_ap);
    clSetq(specifically,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(required_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(default_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values469, lc, form;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clLoopGetCollectionInfo(specifically,
                              clSUM,
                              default_type,
                              clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values469, clMultipleValueFuncall(MVC)); }
    clSetq(lc, clCar(L_values469, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values469);
        clSetq(L_0, clSetq(L_values469, clCdr(L_0__R1, clEOA))); }
      clSetq(form, clCar(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, clLoopCollectorDtype(lc, clEOA));
      clLoopCheckDataType(L_0, required_type, clEOA); }
    { clObject tempvars;
      clSetq(tempvars, clLoopCollectorTempvars(lc, clEOA));
      if (clTrue(clNot(tempvars, clEOA)))
        { { clObject L_value470;
            { clObject L_0;
              { clObject L_0__R1;
                { clObject L_g472;
                  clSetq(L_g472, clLoopCollectorName(lc, clEOA));
                  clSetq(L_0__R1,
                         (clTrue(L_g472) ?
                          L_g472 :
                          clLoopGentemp(clLOOP_SUM_, clEOA))); }
                clSetq(L_0,
                       clLoopMakeVariable(L_0__R1,
                                          clNIL,
                                          clLoopCollectorDtype(lc,
                                                               clEOA),
                                          clEOA)); }
              clSetq(L_value470,
                     clSetq(tempvars, clList(L_0, clEOA))); }
            cl_SETF_LoopCollectorTempvars(L_value470, lc, clEOA); }
          if (clTrue(clNot(clLoopCollectorName(lc, clEOA), clEOA)))
            clLoopEmitFinalValue(clCar(clLoopCollectorTempvars(lc,
                                                               clEOA),
                                       clEOA),
                                 clEOA); }
      { clObject L_0;
        if (_clEq(specifically, clCOUNT))
          { clObject L_2;
            { clObject L_2__R1, L_1__R1;
              { clObject L_0__R3;
                clSetq(L_0__R3, tempvars);
                clSetq(L_1__R1, clCar(L_0__R3, clEOA)); }
              { clObject L_2__R2, L_1__R2;
                { clObject L_0__R4;
                  clSetq(L_0__R4, tempvars);
                  clSetq(L_1__R2, clCar(L_0__R4, clEOA)); }
                { clObject L_1__R3;
                  { clObject L_0__R5;
                    clSetq(L_0__R5, tempvars);
                    clSetq(L_1__R3, clCar(L_0__R5, clEOA)); }
                  clSetq(L_2__R2,
                         clList(cl1plussymbol, L_1__R3, clEOA)); }
                clSetq(L_2__R1,
                       clHideVariableReference(clT,
                                               L_1__R2,
                                               L_2__R2,
                                               clEOA)); }
              clSetq(L_2, clList(clSETQ, L_1__R1, L_2__R1, clEOA)); }
            clSetq(L_0, clList(clWHEN, form, L_2, clEOA)); }
        else
          { clObject L_2, L_1;
            { clObject L_0__R2;
              clSetq(L_0__R2, tempvars);
              clSetq(L_1, clCar(L_0__R2, clEOA)); }
            { clObject L_1__R1;
              { clObject L_2__R2, L_1__R2;
                { clObject L_0__R4;
                  clSetq(L_0__R4, tempvars);
                  clSetq(L_1__R2, clCar(L_0__R4, clEOA)); }
                { clObject L_0__R4;
                  clSetq(L_0__R4, tempvars);
                  clSetq(L_2__R2, clCar(L_0__R4, clEOA)); }
                clSetq(L_1__R1,
                       clHideVariableReference(clT,
                                               L_1__R2,
                                               L_2__R2,
                                               clEOA)); }
              clSetq(L_2,
                     clList(clplussymbol, L_1__R1, form, clEOA)); }
            clSetq(L_0, clList(clSETQ, L_1, L_2, clEOA)); }
        return(clLoopEmitBody(L_0, clEOA)); } } } }

clObject clLoopMaxminCollection clVdecl(_ap)
{ clObject specifically;
  { clBeginParse(_ap);
    clSetq(specifically,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values473, lc, form;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clLoopGetCollectionInfo(specifically,
                              clMAXMIN,
                              clSymbolValue(clstarLOOP_REAL_DATA_TYPEstar,
                                            clEOA),
                              clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values473, clMultipleValueFuncall(MVC)); }
    clSetq(lc, clCar(L_values473, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values473);
        clSetq(L_0, clSetq(L_values473, clCdr(L_0__R1, clEOA))); }
      clSetq(form, clCar(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, clLoopCollectorDtype(lc, clEOA));
      clLoopCheckDataType(L_0,
                          clSymbolValue(clstarLOOP_REAL_DATA_TYPEstar,
                                        clEOA),
                          clEOA); }
    { clObject data;
      clSetq(data, clLoopCollectorData(lc, clEOA));
      if (clTrue(clNot(data, clEOA)))
        { { clObject L_value474;
            { clObject L_0;
              { clObject L_g476;
                clSetq(L_g476, clLoopCollectorName(lc, clEOA));
                clSetq(L_0,
                       (clTrue(L_g476) ?
                        L_g476 :
                        clLoopGentemp(clLOOP_MAXMIN_, clEOA))); }
              clSetq(L_value474,
                     clSetq(data,
                            clMakeLoopMinimax(L_0,
                                              clLoopCollectorDtype(lc,
                                                                   clEOA),
                                              clEOA))); }
            cl_SETF_LoopCollectorData(L_value474, lc, clEOA); }
          if (clTrue(clNot(clLoopCollectorName(lc, clEOA), clEOA)))
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, data);
                clSetq(L_0,
                       clLoopMinimaxAnswerVariable(L_0__R1, clEOA)); }
              clLoopEmitFinalValue(L_0, clEOA); } }
      { clObject L_1;
        clSetq(L_1, data);
        clLoopNoteMinimaxOperation(specifically, L_1, clEOA); }
      { clObject L_0;
        { clObject L_1__R1;
          clSetq(L_1__R1, data);
          clSetq(L_0, clList(clWITH_MINIMAX_VALUE, L_1__R1, clEOA)); }
        clSetSymbolValueValue(clstarLOOP_WRAPPERSstar,
                              clCons(L_0,
                                     clSymbolValue(clstarLOOP_WRAPPERSstar,
                                                   clEOA),
                                     clEOA)); }
      { clObject L_0;
        { clObject L_1;
          clSetq(L_1, data);
          clSetq(L_0,
                 clList(clLOOP_ACCUMULATE_MINIMAX_VALUE,
                        L_1,
                        specifically,
                        form,
                        clEOA)); }
        return(clLoopEmitBody(L_0, clEOA)); } } } }

clObject clLoopDoAlways clVdecl(_ap)
{ clObject restrictive, negate;
  { clBeginParse(_ap);
    clSetq(restrictive,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(negate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject form;
    clSetq(form, clLoopGetForm(clEOA));
    if (clTrue(restrictive)) clLoopDisallowConditional(clEOA);
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, (clTrue(negate) ? clWHEN : clUNLESS));
        clSetq(L_0,
               clList(L_0__R1,
                      form,
                      clLoopConstructReturn(clNIL, clEOA),
                      clEOA)); }
      clLoopEmitBody(L_0, clEOA); }
    return(clLoopEmitFinalValue(clT, clEOA)); } }

clObject clLoopDoThereis clVdecl(_ap)
{ clObject restrictive;
  { clBeginParse(_ap);
    clSetq(restrictive,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(restrictive)) clLoopDisallowConditional(clEOA);
  { clObject L_0;
    { clObject L_1;
      { clObject L_1__R1;
        clSetq(L_1__R1, clLoopWhenItVariable(clEOA));
        clSetq(L_1,
               clList(clSETQ, L_1__R1, clLoopGetForm(clEOA), clEOA)); }
      clSetq(L_0,
             clList(clWHEN, L_1,
                    clLoopConstructReturn(clSymbolValue(clstarLOOP_WHEN_IT_VARIABLEstar,
                                                        clEOA),
                                          clEOA),
                    clEOA)); }
    return(clLoopEmitBody(L_0, clEOA)); } }

clObject clLoopDoWhile clVdecl(_ap)
{ clObject negate, kwd, form;
  { clBeginParse(_ap);
    clSetq(negate,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(kwd,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(form, clLoopGetForm(clEOA));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLoopDisallowConditional(kwd, clEOA);
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, (clTrue(negate) ? clWHEN : clUNLESS));
      clSetq(L_0, clListSTAR(L_0__R1, form, CONS_298, clEOA)); }
    return(clLoopPseudoBody(L_0, clEOA)); } }

clObject clLoopDoWith clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLoopDisallowConditional(keyWITH, clEOA);
  { clObject var, val, dtype;
    clSetq(var, clNIL);
    clSetq(val, clNIL);
    clSetq(dtype, clNIL);
    clLabel(l_ITERATE477);
    if (clTrue(clNIL)) return(clValues1(clNIL));
    clSetq(var, clLoopPopSource(clEOA));
    { clObject L_0;
      clSetq(L_0, var);
      clSetq(dtype, clLoopOptionalType(L_0, clEOA)); }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0,
               clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                     clEOA));
        clSetq(L_test, clLoopTequal(L_0, keyequalsymbol, clEOA)); }
      clSetq(val,
             (clTrue(L_test) ?
              (clLoopPopSource(clEOA), clLoopGetForm(clEOA)) :
              clNIL)); }
    { clObject L_2, L_1, L_0;
      clSetq(L_0, var);
      clSetq(L_1, val);
      clSetq(L_2, dtype);
      clLoopMakeVariable(L_0, L_1, L_2, clEOA); }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0,
               clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                     clEOA));
        clSetq(L_test, clLoopTequal(L_0, keyAND, clEOA)); }
      if (clTrue(L_test))
        clLoopPopSource(clEOA);
      else return(clLoopBindBlock(clEOA)); }
    goto l_ITERATE477; } }

static clObject clLoopHackIteration_MakeEndtest clVdecl(_ap)
{ clObject list_of_forms;
  { clBeginParse(_ap);
    clSetq(list_of_forms,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clNull(list_of_forms, clEOA)))
    return(clValues1(clNIL));
  else
    { clObject L_test__R1;
      { clObject L_sub478;
        clSetq(L_sub478, list_of_forms);
        clLabel(l_ITERATE481);
        if (clTrue(clEndp(L_sub478, clEOA)))
          { clSetq(L_test__R1, clNIL); clLocalReturn(NIL__r1); }
        if (_clEq(clT, clCar(L_sub478, clEOA)))
          { clSetq(L_test__R1, L_sub478);
            clLocalReturn(l_MEMBER480__r1); }
        { clObject L_value482;
          clSetq(L_value482, clCdr(L_sub478, clEOA));
          clSetq(L_sub478, L_value482); }
        goto l_ITERATE481; }
      clBlockEnd(NIL__r1);
      clBlockEnd(l_MEMBER480__r1);
      if (clTrue(L_test__R1))
        return(clValues1(CONS_237));
      else
        { clObject L_1;
          { clObject L_test__R2;
            { clObject L_0__R1;
              { clObject L_0__R2;
                { clObject L_0__R3;
                  clSetq(L_0__R3, list_of_forms);
                  clSetq(L_0__R2,
                         clSetq(list_of_forms,
                                clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                                  L_0__R3,
                                                  clEOA))); }
                clSetq(L_0__R1, clCdr(L_0__R2, clEOA)); }
              clSetq(L_test__R2, clNull(L_0__R1, clEOA)); }
            if (clTrue(L_test__R2))
              { clObject L_0__R1;
                clSetq(L_0__R1, list_of_forms);
                clSetq(L_1, clCar(L_0__R1, clEOA)); }
            else
              { clObject L_1__R1;
                clSetq(L_1__R1, list_of_forms);
                clSetq(L_1, clCons(clOR, L_1__R1, clEOA)); } }
          return(clListSTAR(clWHEN, L_1, CONS_298, clEOA)); } } }

clObject clLoopHackIteration clVdecl(_ap)
{ clObject CL_entry;
  { clBeginParse(_ap);
    clSetq(CL_entry,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject _MakeEndtest_;
    clSetq(_MakeEndtest_,
           clMakeClosure(0,
                         clLoopHackIteration_MakeEndtest,
                         clNULL_HOOK));
    { clObject pre_step_tests, steps, post_step_tests, pseudo_steps,
      pre_loop_pre_step_tests, pre_loop_steps,
      pre_loop_post_step_tests, pre_loop_pseudo_steps, tem, data;
      clSetq(pre_step_tests, clNIL);
      clSetq(steps, clNIL);
      clSetq(post_step_tests, clNIL);
      clSetq(pseudo_steps, clNIL);
      clSetq(pre_loop_pre_step_tests, clNIL);
      clSetq(pre_loop_steps, clNIL);
      clSetq(pre_loop_post_step_tests, clNIL);
      clSetq(pre_loop_pseudo_steps, clNIL);
      clSetq(tem, clNIL);
      clSetq(data, clNIL);
      clLabel(l_ITERATE483);
      if (clTrue(clNIL)) return(clValues1(clNIL));
      { clObject L_0;
        clSetq(L_0, clSymbolFunction(clFirst(CL_entry, clEOA), clEOA));
        clSetq(tem,
               clSetq(data,
                      clApply(L_0, clRest(CL_entry, clEOA), clEOA))); }
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, tem);
          clSetq(L_test, clCar(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, tem);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_1, pre_step_tests);
            clSetq(pre_step_tests, clCons(L_0, L_1, clEOA)); } }
      { clObject L_1, L_0;
        clSetq(L_0, steps);
        { clObject L_0__R1;
          { clObject L_0__R2;
            { clObject L_0__R3;
              clSetq(L_0__R3, tem);
              clSetq(L_0__R2, clSetq(tem, clCdr(L_0__R3, clEOA))); }
            clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
          clSetq(L_1, clCopyList(L_0__R1, clEOA)); }
        clSetq(steps, clNconc(L_0, L_1, clEOA)); }
      { clObject L_test;
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, tem);
            clSetq(L_0, clSetq(tem, clCdr(L_0__R1, clEOA))); }
          clSetq(L_test, clCar(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, tem);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_1, post_step_tests);
            clSetq(post_step_tests, clCons(L_0, L_1, clEOA)); } }
      { clObject L_1, L_0;
        clSetq(L_0, pseudo_steps);
        { clObject L_0__R1;
          { clObject L_0__R2;
            { clObject L_0__R3;
              clSetq(L_0__R3, tem);
              clSetq(L_0__R2, clSetq(tem, clCdr(L_0__R3, clEOA))); }
            clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
          clSetq(L_1, clCopyList(L_0__R1, clEOA)); }
        clSetq(pseudo_steps, clNconc(L_0, L_1, clEOA)); }
      { clObject L_0;
        clSetq(L_0, tem);
        clSetq(tem, clCdr(L_0, clEOA)); }
      if (clTrue(clSymbolValue(clstarLOOP_EMITTED_BODYstar, clEOA)))
        clLoopError(STRn_80, clEOA);
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, tem);
          clSetq(L_test, clNot(L_0, clEOA)); }
        if (clTrue(L_test)) clSetq(tem, data); }
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, tem);
          clSetq(L_test, clCar(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, tem);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_1, pre_loop_pre_step_tests);
            clSetq(pre_loop_pre_step_tests,
                   clCons(L_0, L_1, clEOA)); } }
      { clObject L_1, L_0;
        clSetq(L_0, pre_loop_steps);
        { clObject L_0__R1;
          { clObject L_0__R2;
            { clObject L_0__R3;
              clSetq(L_0__R3, tem);
              clSetq(L_0__R2, clSetq(tem, clCdr(L_0__R3, clEOA))); }
            clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
          clSetq(L_1, clCopyList(L_0__R1, clEOA)); }
        clSetq(pre_loop_steps, clNconc(L_0, L_1, clEOA)); }
      { clObject L_test;
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, tem);
            clSetq(L_0, clSetq(tem, clCdr(L_0__R1, clEOA))); }
          clSetq(L_test, clCar(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, tem);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_1, pre_loop_post_step_tests);
            clSetq(pre_loop_post_step_tests,
                   clCons(L_0, L_1, clEOA)); } }
      { clObject L_1, L_0;
        clSetq(L_0, pre_loop_pseudo_steps);
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, tem);
            clSetq(L_0__R1, clCadr(L_0__R2, clEOA)); }
          clSetq(L_1, clCopyList(L_0__R1, clEOA)); }
        clSetq(pre_loop_pseudo_steps, clNconc(L_0, L_1, clEOA)); }
      { clObject L_test;
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1,
                   clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                       clEOA),
                         clEOA));
            clSetq(L_0, clLoopTequal(L_0__R1, keyAND, clEOA)); }
          clSetq(L_test, clNot(L_0, clEOA)); }
        if (clTrue(L_test))
          { { clObject L_3, L_2, L_1, L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, pre_loop_pseudo_steps);
                clSetq(L_0, clLoopMakeDesetq(L_0__R1, clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, pre_loop_post_step_tests);
                clSetq(L_1,
                       clFuncallFunction(_MakeEndtest_,
                                         L_0__R1,
                                         clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, pre_loop_steps);
                clSetq(L_2, clLoopMakePsetq(L_0__R1, clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, pre_loop_pre_step_tests);
                clSetq(L_3,
                       clFuncallFunction(_MakeEndtest_,
                                         L_0__R1,
                                         clEOA)); }
              clSetSymbolValueValue(clstarLOOP_BEFORE_LOOPstar,
                                    clListSTAR(L_0,
                                               L_1,
                                               L_2,
                                               L_3,
                                               clSymbolValue(clstarLOOP_BEFORE_LOOPstar,
                                                             clEOA),
                                               clEOA)); }
            { clObject L_3, L_2, L_1, L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, pseudo_steps);
                clSetq(L_0, clLoopMakeDesetq(L_0__R1, clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, post_step_tests);
                clSetq(L_1,
                       clFuncallFunction(_MakeEndtest_,
                                         L_0__R1,
                                         clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, steps);
                clSetq(L_2, clLoopMakePsetq(L_0__R1, clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, pre_step_tests);
                clSetq(L_3,
                       clFuncallFunction(_MakeEndtest_,
                                         L_0__R1,
                                         clEOA)); }
              clSetSymbolValueValue(clstarLOOP_AFTER_BODYstar,
                                    clListSTAR(L_0,
                                               L_1,
                                               L_2,
                                               L_3,
                                               clSymbolValue(clstarLOOP_AFTER_BODYstar,
                                                             clEOA),
                                               clEOA)); }
            clLoopBindBlock(clEOA);
            return(clValues1(clNIL)); } }
      clLoopPopSource(clEOA);
      { clObject L_test;
        if (clTrue(clNot(clLoopUniverseImplicitForRequired(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                         clEOA),
                                                           clEOA),
                         clEOA)))
          { clObject L_0;
            clSetq(L_0,
                   clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                       clEOA),
                         clEOA));
            clSetq(L_test,
                   clSetq(tem,
                          clLoopLookupKeyword(L_0,
                                              clLoopUniverseIterationKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                            clEOA),
                                                                              clEOA),
                                              clEOA))); }
        else clSetq(L_test, clNIL);
        if (clTrue(L_test))
          { clLoopPopSource(clEOA); clSetq(CL_entry, tem); } }
      goto l_ITERATE483; } } }

clObject clLoopDoFor clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject var, data_type, keyword, first_arg, tem;
    clSetq(var, clLoopPopSource(clEOA));
    clSetq(data_type, clLoopOptionalType(var, clEOA));
    clSetq(keyword, clLoopPopSource(clEOA));
    clSetq(first_arg, clNIL);
    clSetq(tem, clNIL);
    clSetq(first_arg, clLoopGetForm(clEOA));
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0,
               (clTrue(clSymbolp(keyword, clEOA)) ?
                clSetq(tem,
                       clLoopLookupKeyword(keyword,
                                           clLoopUniverseForKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                   clEOA),
                                                                     clEOA),
                                           clEOA)) :
                clNIL));
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test)) clLoopError(STRn_81, keyword, clEOA); }
    { clObject L_4, L_2, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, tem);
        clSetq(L_0, clCar(L_0__R1, clEOA)); }
      clSetq(L_2, first_arg);
      { clObject L_0__R1;
        clSetq(L_0__R1, tem);
        clSetq(L_4, clCdr(L_0__R1, clEOA)); }
      return(clApply(L_0, var, L_2, data_type, L_4, clEOA)); } } }

clObject clLoopDoRepeat clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject form, type;
    clSetq(form, clLoopGetForm(clEOA));
    { clObject L_0;
      clSetq(L_0, clLoopOptionalType(clEOA));
      clSetq(type,
             clLoopCheckDataType(L_0,
                                 clSymbolValue(clstarLOOP_REAL_DATA_TYPEstar,
                                               clEOA),
                                 clEOA)); }
    { clObject L_test;
      if (clTrue(clConsp(form, clEOA)))
        { clObject L_test__R2;
          { clObject L_0;
            clSetq(L_0, clCar(form, clEOA));
            clSetq(L_test__R2, clEq(L_0, clTHE, clEOA)); }
          if (clTrue(L_test__R2))
            { clObject L_0;
              clSetq(L_0, clSecond(form, clEOA));
              clSetq(L_test,
                     clFuncallFunction(clSymbolFunctionValue(clSUBTYPEP),
                                       L_0,
                                       type,
                                       clEOA)); }
          else clSetq(L_test, clNIL); }
      else clSetq(L_test, clNIL);
      if (clTrue(L_test)) clSetq(type, clSecond(form, clEOA)); }
    { clObject L_values484, number, constantp, value;
      { clMultipleValueCall(MVC);
        clSetq(MVC, clSymbolFunctionValue(clLIST));
        { clObject L_1;
          clSetq(L_1, type);
          clLoopConstantFoldIfPossible(form, L_1, clEOA); }
        clAccumulateValues(MVC);
        clSetq(L_values484, clMultipleValueFuncall(MVC)); }
      clSetq(number, clCar(L_values484, clEOA));
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values484);
          clSetq(L_0, clSetq(L_values484, clCdr(L_0__R1, clEOA))); }
        clSetq(constantp, clCar(L_0, clEOA)); }
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values484);
          clSetq(L_0, clSetq(L_values484, clCdr(L_0__R1, clEOA))); }
        clSetq(value, clCar(L_0, clEOA)); }
      if (clTrue((clTrue(constantp) ?
                  clFuncallFunction(clSymbolFunctionValue(clLE),
                                    value,
                                    I_1,
                                    clEOA) :
                  clNIL)))
        { clObject L_4;
          clSetq(L_4,
                 clFuncallFunction(clSymbolFunctionValue(clLE),
                                   value,
                                   I_0,
                                   clEOA));
          return(clListSTAR(clT,
                            clNIL,
                            clNIL,
                            clNIL,
                            L_4,
                            CONS_299,
                            clEOA)); }
      else
        { clObject var;
          { clObject L_2, L_0;
            clSetq(L_0, clLoopGentemp(clLOOP_REPEAT_, clEOA));
            clSetq(L_2, type);
            clSetq(var, clLoopMakeVariable(L_0, number, L_2, clEOA)); }
          if (clTrue(constantp))
            { clObject L_0;
              clSetq(L_0,
                     clList(clNOT,
                            clList(clPLUSP,
                                   clList(clSETQ,
                                          var,
                                          clList(cl1_symbol,
                                                 var,
                                                 clEOA),
                                          clEOA),
                                   clEOA),
                            clEOA));
              return(clListSTAR(L_0, CONS_301, clEOA)); }
          else
            { clObject L_0;
              clSetq(L_0,
                     clList(clMINUSP,
                            clList(clSETQ,
                                   var,
                                   clList(cl1_symbol, var, clEOA),
                                   clEOA),
                            clEOA));
              return(clListSTAR(L_0, CONS_299, clEOA)); } } } } }

clObject clLoopWhenItVariable clVdecl(_ap)
{ { clBeginParse(_ap);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g485;
    clSetq(L_g485,
           clSymbolValue(clstarLOOP_WHEN_IT_VARIABLEstar, clEOA));
    if (clTrue(L_g485))
      return(clValues1(L_g485));
    else
      { clObject L_0;
        clSetq(L_0, clLoopGentemp(clLOOP_IT_, clEOA));
        return(clValues1(clSetSymbolValueValue(clstarLOOP_WHEN_IT_VARIABLEstar,
                                               clLoopMakeVariable(L_0,
                                                                  clNIL,
                                                                  clNIL,
                                                                  clEOA)))); } } }

clObject clLoopAnsiForEquals clVdecl(_ap)
{ clObject var, val, data_type;
  { clBeginParse(_ap);
    clSetq(var,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(val,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLoopMakeIterationVariable(var, clNIL, data_type, clEOA);
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0,
             clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                   clEOA));
      clSetq(L_test, clLoopTequal(L_0, keyTHEN, clEOA)); }
    if (clTrue(L_test))
      { clLoopPopSource(clEOA);
        { clObject L_5, L_1;
          clSetq(L_1, clList(var, clLoopGetForm(clEOA), clEOA));
          clSetq(L_5, clList(var, val, clEOA));
          return(clListSTAR(clNIL,
                            L_1,
                            clNIL,
                            clNIL,
                            clNIL,
                            L_5,
                            CONS_300,
                            clEOA)); } }
    else
      { clObject L_1;
        clSetq(L_1, clList(var, val, clEOA));
        return(clListSTAR(clNIL, L_1, CONS_300, clEOA)); } } }

clObject clLoopForAcross clVdecl(_ap)
{ clObject var, val, data_type;
  { clBeginParse(_ap);
    clSetq(var,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(val,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  clLoopMakeIterationVariable(var, clNIL, data_type, clEOA);
  { clObject vector_var, index_var;
    clSetq(vector_var, clLoopGentemp(clLOOP_ACROSS_VECTOR_, clEOA));
    clSetq(index_var, clLoopGentemp(clLOOP_ACROSS_INDEX_, clEOA));
    { clObject L_values486, vector_form, constantp, vector_value;
      { clMultipleValueCall(MVC);
        clSetq(MVC, clSymbolFunctionValue(clLIST));
        clLoopConstantFoldIfPossible(val, clVECTOR, clEOA);
        clAccumulateValues(MVC);
        clSetq(L_values486, clMultipleValueFuncall(MVC)); }
      clSetq(vector_form, clCar(L_values486, clEOA));
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values486);
          clSetq(L_0, clSetq(L_values486, clCdr(L_0__R1, clEOA))); }
        clSetq(constantp, clCar(L_0, clEOA)); }
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values486);
          clSetq(L_0, clSetq(L_values486, clCdr(L_0__R1, clEOA))); }
        clSetq(vector_value, clCar(L_0, clEOA)); }
      { clObject L_2;
        { clObject L_test;
          if (clTrue(clConsp(vector_form, clEOA)))
            { clObject L_0__R1;
              clSetq(L_0__R1, clCar(vector_form, clEOA));
              clSetq(L_test, clEq(L_0__R1, clTHE, clEOA)); }
          else clSetq(L_test, clNIL);
          clSetq(L_2,
                 (clTrue(L_test) ? clCadr(vector_form, clEOA) :
                  clVECTOR)); }
        clLoopMakeVariable(vector_var, vector_form, L_2, clEOA); }
      clLoopMakeVariable(index_var, I_0, clFIXNUM, clEOA);
      { clObject length, length_form, first_test, other_test, step,
        pstep;
        clSetq(length, I_0);
        if (clTrue(clNot(constantp, clEOA)))
          { clObject v;
            clSetq(v, clLoopGentemp(clLOOP_ACROSS_LIMIT_, clEOA));
            { clObject L_0;
              clSetq(L_0,
                     clList(clSETQ,
                            v,
                            clList(clLENGTH, vector_var, clEOA),
                            clEOA));
              clSetSymbolValueValue(clstarLOOP_PROLOGUEstar,
                                    clCons(L_0,
                                           clSymbolValue(clstarLOOP_PROLOGUEstar,
                                                         clEOA),
                                           clEOA)); }
            clSetq(length_form,
                   clLoopMakeVariable(v, I_0, clFIXNUM, clEOA)); }
        else
          clSetq(length_form,
                 clSetq(length, clLength(vector_value, clEOA)));
        { clObject L_2;
          clSetq(L_2, length_form);
          clSetq(first_test,
                 clList(clgreaterequalsymbol,
                        index_var,
                        L_2,
                        clEOA)); }
        clSetq(other_test, first_test);
        clSetq(step,
               clList(var,
                      clList(clAREF, vector_var, index_var, clEOA),
                      clEOA));
        clSetq(pstep,
               clList(index_var,
                      clList(cl1plussymbol, index_var, clEOA),
                      clEOA));
        if (clTrue(constantp))
          { { clObject L_0;
              clSetq(L_0, length);
              clSetq(first_test,
                     clFuncallFunction(clSymbolFunctionValue(clEQ_NUMBER),
                                       L_0,
                                       I_0,
                                       clEOA)); }
            { clObject L_test__R1;
              { clObject L_0;
                clSetq(L_0, length);
                clSetq(L_test__R1,
                       clFuncallFunction(clSymbolFunctionValue(clLE),
                                         L_0,
                                         I_1,
                                         clEOA)); }
              if (clTrue(L_test__R1)) clSetq(other_test, clT); } }
        { clObject L_4, L_0;
          clSetq(L_0, other_test);
          { clObject L_test;
            { clObject L_0__R1;
              { clObject L_1__R1, L_0__R2;
                clSetq(L_0__R2, first_test);
                clSetq(L_1__R1, other_test);
                clSetq(L_0__R1, clEq(L_0__R2, L_1__R1, clEOA)); }
              clSetq(L_test, clNot(L_0__R1, clEOA)); }
            if (clTrue(L_test))
              { clObject L_0__R1;
                clSetq(L_0__R1, first_test);
                clSetq(L_4,
                       clList(L_0__R1, step, clNIL, pstep, clEOA)); }
            else clSetq(L_4, clNIL); }
          return(clListSTAR(L_0,
                            step,
                            clNIL,
                            pstep,
                            L_4,
                            clEOA)); } } } } }

clObject clLoopListStep clVdecl(_ap)
{ clObject listvar;
  { clBeginParse(_ap);
    clSetq(listvar,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject stepper;
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0,
               clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                     clEOA));
        clSetq(L_test, clLoopTequal(L_0, keyBY, clEOA)); }
      clSetq(stepper,
             (clTrue(L_test) ?
              (clLoopPopSource(clEOA), clLoopGetForm(clEOA)) :
              CONS_305)); }
    { clObject L_test;
      { clObject L_test__R1;
        { clObject L_0;
          clSetq(L_0, stepper);
          clSetq(L_test__R1, clConsp(L_0, clEOA)); }
        if (clTrue(L_test__R1))
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, stepper);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_test, clEq(L_0, clQUOTE, clEOA)); }
        else clSetq(L_test, clNIL); }
      if (clTrue(L_test))
        { clLoopWarn(STRn_84, clEOA);
          { clObject L_0;
            { clObject L_1__R1;
              clSetq(L_1__R1, stepper);
              clSetq(L_0,
                     clList(clFUNCALL, L_1__R1, listvar, clEOA)); }
            return(clValues(L_0, clNIL, clEOA)); } }
      else
        { clObject L_test__R1;
          { clObject L_test__R2;
            { clObject L_0;
              clSetq(L_0, stepper);
              clSetq(L_test__R2, clConsp(L_0, clEOA)); }
            if (clTrue(L_test__R2))
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, stepper);
                  clSetq(L_0, clCar(L_0__R1, clEOA)); }
                clSetq(L_test__R1, clEq(L_0, clFUNCTION, clEOA)); }
            else clSetq(L_test__R1, clNIL); }
          if (clTrue(L_test__R1))
            { clObject L_1, L_0;
              { clObject L_0__R1;
                { clObject L_0__R2;
                  clSetq(L_0__R2, stepper);
                  clSetq(L_0__R1, clCadr(L_0__R2, clEOA)); }
                clSetq(L_0, clList(L_0__R1, listvar, clEOA)); }
              { clObject L_0__R1;
                clSetq(L_0__R1, stepper);
                clSetq(L_1, clCadr(L_0__R1, clEOA)); }
              return(clValues(L_0, L_1, clEOA)); }
          else
            { clObject L_0;
              { clObject L_1__R1;
                { clObject L_1__R2, L_0__R2;
                  clSetq(L_0__R2, clLoopGentemp(clLOOP_FN_, clEOA));
                  clSetq(L_1__R2, stepper);
                  clSetq(L_1__R1,
                         clLoopMakeVariable(L_0__R2,
                                            L_1__R2,
                                            clFUNCTION,
                                            clEOA)); }
                clSetq(L_0,
                       clList(clFUNCALL, L_1__R1, listvar, clEOA)); }
              return(clValues(L_0, clNIL, clEOA)); } } } } }

clObject clLoopForOn clVdecl(_ap)
{ clObject var, val, data_type;
  { clBeginParse(_ap);
    clSetq(var,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(val,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values487, list, constantp, list_value;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clLoopConstantFoldIfPossible(val, clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values487, clMultipleValueFuncall(MVC)); }
    clSetq(list, clCar(L_values487, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values487);
        clSetq(L_0, clSetq(L_values487, clCdr(L_0__R1, clEOA))); }
      clSetq(constantp, clCar(L_0, clEOA)); }
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values487);
        clSetq(L_0, clSetq(L_values487, clCdr(L_0__R1, clEOA))); }
      clSetq(list_value, clCar(L_0, clEOA)); }
    { clObject listvar;
      clSetq(listvar, var);
      if (clTrue((clTrue(var) ? clSymbolp(var, clEOA) : clNIL)))
        clLoopMakeIterationVariable(var, list, data_type, clEOA);
      else
        { { clObject L_0;
            clSetq(L_0, clSetq(listvar, clLoopGentemp(clEOA)));
            clLoopMakeVariable(L_0, list, clLIST, clEOA); }
          clLoopMakeIterationVariable(var, clNIL, data_type, clEOA); }
      { clObject L_values488, list_step, step_function;
        { clMultipleValueCall(MVC__r1);
          clSetq(MVC__r1, clSymbolFunctionValue(clLIST));
          { clObject L_0;
            clSetq(L_0, listvar);
            clLoopListStep(L_0, clEOA); }
          clAccumulateValues(MVC__r1);
          clSetq(L_values488, clMultipleValueFuncall(MVC__r1)); }
        clSetq(list_step, clCar(L_values488, clEOA));
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, L_values488);
            clSetq(L_0, clSetq(L_values488, clCdr(L_0__R1, clEOA))); }
          clSetq(step_function, clCar(L_0, clEOA)); }
        { clObject first_endtest, other_endtest;
          { clObject L_2, L_1, L_0;
            { clObject L_1__R1;
              clSetq(L_1__R1, listvar);
              clSetq(L_0, clEq(var, L_1__R1, clEOA)); }
            clSetq(L_1, listvar);
            { clObject L_1__R1;
              clSetq(L_1__R1, listvar);
              clSetq(L_2, clList(clATOM, L_1__R1, clEOA)); }
            clSetq(first_endtest,
                   clHideVariableReference(L_0, L_1, L_2, clEOA)); }
          clSetq(other_endtest, first_endtest);
          if (clTrue((clTrue(constantp) ?
                      clListp(list_value, clEOA) :
                      clNIL)))
            clSetq(first_endtest, clNull(list_value, clEOA));
          { clObject L_test;
            { clObject L_1;
              clSetq(L_1, listvar);
              clSetq(L_test, clEq(var, L_1, clEOA)); }
            if (clTrue(L_test))
              { clObject L_6, L_1;
                { clObject L_1__R1, L_0__R1;
                  clSetq(L_0__R1, listvar);
                  { clObject L_1__R2;
                    clSetq(L_1__R2, listvar);
                    clSetq(L_1__R1,
                           clHideVariableReference(clT,
                                                   L_1__R2,
                                                   list_step,
                                                   clEOA)); }
                  clSetq(L_1, clList(L_0__R1, L_1__R1, clEOA)); }
                clSetq(L_6, first_endtest);
                return(clListSTAR(clNIL,
                                  L_1,
                                  other_endtest,
                                  clNIL,
                                  clNIL,
                                  clNIL,
                                  L_6,
                                  CONS_2,
                                  clEOA)); }
            else
              { clObject step, pseudo;
                { clObject L_1;
                  clSetq(L_1, listvar);
                  clSetq(step, clList(var, L_1, clEOA)); }
                { clObject L_0;
                  clSetq(L_0, listvar);
                  clSetq(pseudo, clList(L_0, list_step, clEOA)); }
                { clObject L_4;
                  { clObject L_test__R1;
                    { clObject L_0__R1;
                      { clObject L_0__R2;
                        clSetq(L_0__R2, first_endtest);
                        clSetq(L_0__R1,
                               clEq(L_0__R2, other_endtest, clEOA)); }
                      clSetq(L_test__R1, clNot(L_0__R1, clEOA)); }
                    if (clTrue(L_test__R1))
                      { clObject L_0__R1;
                        clSetq(L_0__R1, first_endtest);
                        clSetq(L_4,
                               clList(L_0__R1,
                                      step,
                                      clNIL,
                                      pseudo,
                                      clEOA)); }
                    else clSetq(L_4, clNIL); }
                  return(clListSTAR(other_endtest,
                                    step,
                                    clNIL,
                                    pseudo,
                                    L_4,
                                    clEOA)); } } } } } } } }

clObject clLoopForIn clVdecl(_ap)
{ clObject var, val, data_type;
  { clBeginParse(_ap);
    clSetq(var,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(val,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values489, list, constantp, list_value;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clLoopConstantFoldIfPossible(val, clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values489, clMultipleValueFuncall(MVC)); }
    clSetq(list, clCar(L_values489, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values489);
        clSetq(L_0, clSetq(L_values489, clCdr(L_0__R1, clEOA))); }
      clSetq(constantp, clCar(L_0, clEOA)); }
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values489);
        clSetq(L_0, clSetq(L_values489, clCdr(L_0__R1, clEOA))); }
      clSetq(list_value, clCar(L_0, clEOA)); }
    { clObject listvar;
      clSetq(listvar, clLoopGentemp(clLOOP_LIST_, clEOA));
      clLoopMakeIterationVariable(var, clNIL, data_type, clEOA);
      clLoopMakeVariable(listvar, list, clLIST, clEOA);
      { clObject L_values490, list_step, step_function;
        { clMultipleValueCall(MVC__r1);
          clSetq(MVC__r1, clSymbolFunctionValue(clLIST));
          clLoopListStep(listvar, clEOA);
          clAccumulateValues(MVC__r1);
          clSetq(L_values490, clMultipleValueFuncall(MVC__r1)); }
        clSetq(list_step, clCar(L_values490, clEOA));
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, L_values490);
            clSetq(L_0, clSetq(L_values490, clCdr(L_0__R1, clEOA))); }
          clSetq(step_function, clCar(L_0, clEOA)); }
        { clObject first_endtest, other_endtest, step, pseudo_step;
          clSetq(first_endtest, clList(clENDP, listvar, clEOA));
          clSetq(other_endtest, first_endtest);
          clSetq(step,
                 clList(var, clList(clCAR, listvar, clEOA), clEOA));
          clSetq(pseudo_step, clList(listvar, list_step, clEOA));
          if (clTrue((clTrue(constantp) ?
                      clListp(list_value, clEOA) :
                      clNIL)))
            clSetq(first_endtest, clNull(list_value, clEOA));
          { clObject L_4;
            { clObject L_test;
              { clObject L_0__R1;
                { clObject L_0__R2;
                  clSetq(L_0__R2, first_endtest);
                  clSetq(L_0__R1,
                         clEq(L_0__R2, other_endtest, clEOA)); }
                clSetq(L_test, clNot(L_0__R1, clEOA)); }
              if (clTrue(L_test))
                { clObject L_0__R1;
                  clSetq(L_0__R1, first_endtest);
                  clSetq(L_4,
                         clList(L_0__R1,
                                step,
                                clNIL,
                                pseudo_step,
                                clEOA)); }
              else clSetq(L_4, clNIL); }
            return(clListSTAR(other_endtest,
                              step,
                              clNIL,
                              pseudo_step,
                              L_4,
                              clEOA)); } } } } } }

clObject clMakeLoopPath clVdecl(_ap)
{ clObject L_ap, L_keys, L_names, L_preposition_groups,
  L_inclusive_permitted, L_function, L_user_data;
  { clBeginParse(_ap);
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyNAMES, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_names, clCar(L_0, clEOA)); }
    else clSetq(L_names, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyPREPOSITION_GROUPS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_preposition_groups, clCar(L_0, clEOA)); }
    else clSetq(L_preposition_groups, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyINCLUSIVE_PERMITTED,
                               L_keys,
                               clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_inclusive_permitted, clCar(L_0, clEOA)); }
    else clSetq(L_inclusive_permitted, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyFUNCTION, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_function, clCar(L_0, clEOA)); }
    else clSetq(L_function, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyUSER_DATA, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(L_user_data, clCar(L_0, clEOA)); }
    else clSetq(L_user_data, clNIL);
    clCheckKeys(L_keys, CONS_332, clEOA);
    clEndParse(_ap); }
  { clObject L_5, L_4, L_3, L_2, L_1;
    clSetq(L_1, L_names);
    clSetq(L_2, L_preposition_groups);
    clSetq(L_3, L_inclusive_permitted);
    clSetq(L_4, L_function);
    clSetq(L_5, L_user_data);
    return(clMakeStructure(clLOOP_PATH,
                           L_1,
                           L_2,
                           L_3,
                           L_4,
                           L_5,
                           clEOA)); } }

clObject clLoopPathNames clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_0, clEOA)); }

clObject cl_SETF_LoopPathNames clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_0, clEOA)); }

clObject clLoopPathPrepositionGroups clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_1, clEOA)); }

clObject cl_SETF_LoopPathPrepositionGroups clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_1, clEOA)); }

clObject clLoopPathInclusivePermitted clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_2, clEOA)); }

clObject cl_SETF_LoopPathInclusivePermitted clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_2, clEOA)); }

clObject clLoopPathFunction clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_3, clEOA)); }

clObject cl_SETF_LoopPathFunction clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_3, clEOA)); }

clObject clLoopPathUserData clVdecl(_ap)
{ clObject structure;
  { clBeginParse(_ap);
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clStructref(structure, I_4, clEOA)); }

clObject cl_SETF_LoopPathUserData clVdecl(_ap)
{ clObject CL_new, structure;
  { clBeginParse(_ap);
    clSetq(CL_new,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(structure,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(cl_SETF_Structref(CL_new, structure, I_4, clEOA)); }

static clObject clAddLoopPath_Lambda clVdecl(_ap)
{ clObject x;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clListp(x, clEOA)))
    return(clValues1(x));
  else return(clList(x, clEOA)); }

clObject clAddLoopPath clVdecl(_ap)
{ clObject L_ap, names, function, universe, L_keys, preposition_groups,
  inclusive_permitted, user_data;
  { clBeginParse(_ap);
    clSetq(names,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(universe,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyPREPOSITION_GROUPS, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(preposition_groups, clCar(L_0, clEOA)); }
    else clSetq(preposition_groups, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyINCLUSIVE_PERMITTED,
                               L_keys,
                               clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(inclusive_permitted, clCar(L_0, clEOA)); }
    else clSetq(inclusive_permitted, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyUSER_DATA, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(user_data, clCar(L_0, clEOA)); }
    else clSetq(user_data, clNIL);
    clCheckKeys(L_keys, CONS_347, clEOA);
    clEndParse(_ap); }
  if (clTrue(clNot(clListp(names, clEOA), clEOA)))
    { clObject L_0;
      clSetq(L_0, names);
      clSetq(names, clList(L_0, clEOA)); }
  { clObject ht, lp;
    clSetq(ht, clLoopUniversePathKeywords(universe, clEOA));
    { clObject L_9, L_7, L_5, L_1;
      { clObject L_1__R1, L_0__R1;
        clSetq(L_0__R1, clSymbolFunctionValue(clSYMBOL_NAME));
        clSetq(L_1__R1, names);
        clSetq(L_1, clMapcar(L_0__R1, L_1__R1, clEOA)); }
      clSetq(L_5, user_data);
      { clObject L_1__R1, L_0__R1;
        clSetq(L_0__R1,
               clMakeClosure(0, clAddLoopPath_Lambda, clNULL_HOOK));
        clSetq(L_1__R1, preposition_groups);
        clSetq(L_7, clMapcar(L_0__R1, L_1__R1, clEOA)); }
      clSetq(L_9, inclusive_permitted);
      clSetq(lp,
             clMakeLoopPath(keyNAMES,
                            L_1,
                            keyFUNCTION,
                            function,
                            keyUSER_DATA,
                            L_5,
                            keyPREPOSITION_GROUPS,
                            L_7,
                            keyINCLUSIVE_PERMITTED,
                            L_9,
                            clEOA)); }
    { clObject L_sublist506, name;
      clSetq(L_sublist506, names);
      clSetq(name, clCar(L_sublist506, clEOA));
      clLabel(l_ITERATE507);
      if (clTrue(clEndp(L_sublist506, clEOA))) clLocalReturn(NIL);
      { clObject L_arg509;
        clSetq(L_arg509, clSymbolName(name, clEOA));
        clFuncallFunction(clFdefinition(CONS_128, clEOA),
                          lp,
                          L_arg509,
                          ht,
                          clEOA); }
      { clObject L_0;
        clSetq(L_0, L_sublist506);
        clSetq(L_sublist506, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist506);
        clSetq(name, clCar(L_0, clEOA)); }
      goto l_ITERATE507; }
    clBlockEnd(NIL);
    return(clValues1(lp)); } }

clObject clLoopForBeing clVdecl(_ap)
{ clObject var, val, data_type;
  { clBeginParse(_ap);
    clSetq(var,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(val,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject path, data, inclusive, stuff, initial_prepositions;
    clSetq(path, clNIL);
    clSetq(data, clNIL);
    clSetq(inclusive, clNIL);
    clSetq(stuff, clNIL);
    clSetq(initial_prepositions, clNIL);
    if (clTrue(clLoopTmember(val, CONS_350, clEOA)))
      clSetq(path, clLoopPopSource(clEOA));
    else
      { clObject L_test__R1;
        { clObject L_0;
          clSetq(L_0,
                 clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                     clEOA),
                       clEOA));
          clSetq(L_test__R1, clLoopTequal(L_0, keyAND, clEOA)); }
        if (clTrue(L_test__R1))
          { clLoopPopSource(clEOA);
            clSetq(inclusive, clT);
            { clObject L_test__R2;
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1,
                         clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                             clEOA),
                               clEOA));
                  clSetq(L_0,
                         clLoopTmember(L_0__R1, CONS_352, clEOA)); }
                clSetq(L_test__R2, clNot(L_0, clEOA)); }
              if (clTrue(L_test__R2))
                clLoopError(STRn_94,
                            clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                                clEOA),
                                  clEOA),
                            clEOA); }
            clLoopPopSource(clEOA);
            clSetq(path, clLoopPopSource(clEOA));
            clSetq(initial_prepositions,
                   clList(clList(keyIN, val, clEOA), clEOA)); }
        else clLoopError(STRn_96, clEOA); }
    { clObject L_test;
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, path);
          clSetq(L_0, clSymbolp(L_0__R1, clEOA)); }
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test))
        { clObject L_1;
          clSetq(L_1, path);
          clLoopError(STRn_97, L_1, clEOA); }
      else
        { clObject L_test__R1;
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, path);
              clSetq(L_0,
                     clSetq(data,
                            clLoopLookupKeyword(L_0__R1,
                                                clLoopUniversePathKeywords(clSymbolValue(clstarLOOP_UNIVERSEstar,
                                                                                         clEOA),
                                                                           clEOA),
                                                clEOA))); }
            clSetq(L_test__R1, clNot(L_0, clEOA)); }
          if (clTrue(L_test__R1))
            { clObject L_1;
              clSetq(L_1, path);
              clLoopError(STRn_98, L_1, clEOA); }
          else
            { clObject L_test__R2;
              if (clTrue(inclusive))
                { clObject L_0;
                  { clObject L_0__R1;
                    clSetq(L_0__R1, data);
                    clSetq(L_0,
                           clLoopPathInclusivePermitted(L_0__R1,
                                                        clEOA)); }
                  clSetq(L_test__R2, clNot(L_0, clEOA)); }
              else clSetq(L_test__R2, clNIL);
              if (clTrue(L_test__R2))
                { clObject L_1;
                  clSetq(L_1, path);
                  clLoopError(STRn_99, L_1, clEOA); } } } }
    { clObject fun, preps, user_data;
      { clObject L_0;
        clSetq(L_0, data);
        clSetq(fun, clLoopPathFunction(L_0, clEOA)); }
      { clObject L_1, L_0;
        clSetq(L_0, initial_prepositions);
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, data);
            clSetq(L_0__R1,
                   clLoopPathPrepositionGroups(L_0__R2, clEOA)); }
          clSetq(L_1,
                 clLoopCollectPrepositionalPhrases(L_0__R1,
                                                   clT,
                                                   clEOA)); }
        clSetq(preps, clNconc(L_0, L_1, clEOA)); }
      { clObject L_0;
        clSetq(L_0, data);
        clSetq(user_data, clLoopPathUserData(L_0, clEOA)); }
      if (clTrue(clSymbolp(fun, clEOA)))
        { clObject L_0;
          clSetq(L_0, fun);
          clSetq(fun, clSymbolFunction(L_0, clEOA)); }
      if (clTrue(inclusive))
        { clObject L_0;
          clSetq(L_0, fun);
          clSetq(stuff,
                 clApply(L_0,
                         var,
                         data_type,
                         preps,
                         keyINCLUSIVE,
                         clT,
                         user_data,
                         clEOA)); }
      else
        { clObject L_0;
          clSetq(L_0, fun);
          clSetq(stuff,
                 clApply(L_0,
                         var,
                         data_type,
                         preps,
                         user_data,
                         clEOA)); } }
    if (clTrue(clSymbolValue(clstarLOOP_NAMED_VARIABLESstar, clEOA)))
      clLoopError(STRn_101,
                  clSymbolValue(clstarLOOP_NAMED_VARIABLESstar, clEOA),
                  clEOA);
    { clObject L_test;
      { clObject L_0;
        { clObject L_item511;
          { clObject L_0__R1;
            clSetq(L_0__R1, stuff);
            clSetq(L_item511, clLength(L_0__R1, clEOA)); }
          clSetq(L_0,
                 (_clEq(L_item511, I_6) ? CONS_356 :
                  (_clEq(L_item511, I_10) ? CONS_357 : clNIL))); }
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test))
        { clObject L_1;
          clSetq(L_1, path);
          clLoopError(STRn_102, L_1, clEOA); } }
    { clObject l, x;
      { clObject L_0;
        clSetq(L_0, stuff);
        clSetq(l, clCar(L_0, clEOA)); }
      clSetq(x, clNIL);
      clLabel(l_ITERATE512);
      if (clTrue(clNull(l, clEOA))) clLocalReturn(NIL);
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, clSetq(x, clCar(l, clEOA)));
          clSetq(L_test, clAtom(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_0;
            clSetq(L_0, x);
            clLoopMakeIterationVariable(L_0, clNIL, clNIL, clEOA); }
        else
          { clObject L_2, L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, x);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            { clObject L_0__R1;
              clSetq(L_0__R1, x);
              clSetq(L_1, clCadr(L_0__R1, clEOA)); }
            { clObject L_0__R1;
              clSetq(L_0__R1, x);
              clSetq(L_2, clCaddr(L_0__R1, clEOA)); }
            clLoopMakeIterationVariable(L_0, L_1, L_2, clEOA); } }
      { clObject L_value513;
        clSetq(L_value513, clCdr(l, clEOA));
        clSetq(l, L_value513); }
      goto l_ITERATE512; }
    clBlockEnd(NIL);
    { clObject L_0;
      { clObject L_0__R1;
        { clObject L_0__R2;
          clSetq(L_0__R2, stuff);
          clSetq(L_0__R1, clCadr(L_0__R2, clEOA)); }
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clREVERSE),
                                 L_0__R1,
                                 clEOA)); }
      clSetSymbolValueValue(clstarLOOP_PROLOGUEstar,
                            clNconc(L_0,
                                    clSymbolValue(clstarLOOP_PROLOGUEstar,
                                                  clEOA),
                                    clEOA)); }
    { clObject L_0;
      clSetq(L_0, stuff);
      return(clCddr(L_0, clEOA)); } } }

clObject clNamedVariable clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject tem;
    clSetq(tem,
           clLoopTassoc(name,
                        clSymbolValue(clstarLOOP_NAMED_VARIABLESstar,
                                      clEOA),
                        clEOA));
    if (clTrue(clNull(tem, clEOA)))
      { clObject L_0;
        clSetq(L_0, clLoopGentemp(clEOA));
        return(clValues(L_0, clNIL, clEOA)); }
    else
      { clSetSymbolValueValue(clstarLOOP_NAMED_VARIABLESstar,
                              clDelete(tem,
                                       clSymbolValue(clstarLOOP_NAMED_VARIABLESstar,
                                                     clEOA),
                                       clEOA));
        { clObject L_0;
          clSetq(L_0, clCdr(tem, clEOA));
          return(clValues(L_0, clT, clEOA)); } } } }

clDeclareEnv(clLoopCollectPrepositionalPhrases_Lambda);
static clObject clLoopCollectPrepositionalPhrases_Lambda clVdecl(_ap)
{ clUseEnv(clLoopCollectPrepositionalPhrases_Lambda);
  { clObject x;
    { clBeginParse(_ap);
      clSetq(x,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clCar(x, clEOA));
        clSetq(L_0,
               clFind(L_0__R1,
                      clEnv(0, *preposition_groups),
                      keyTEST,
                      clEnv(1, *_InGroupP_),
                      clEOA)); }
      return(clCopyList(L_0, clEOA)); } } }

static clObject clLoopCollectPrepositionalPhrases_InGroupP clVdecl(_ap)
{ clObject x, group;
  { clBeginParse(_ap);
    clSetq(x, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(group,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clCar(clLoopTmember(x, group, clEOA), clEOA)); }

clObject clLoopCollectPrepositionalPhrases clVdecl(_ap)
{ clObject *preposition_groups = clMakeBinding(), using_allowed,
  initial_phrases;
  { clBeginParse(_ap);
    clSetq(*preposition_groups,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(using_allowed, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    clSetq(initial_phrases, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject *_InGroupP_ = clMakeBinding();
    clSetq(*_InGroupP_,
           clMakeClosure(0,
                         clLoopCollectPrepositionalPhrases_InGroupP,
                         clNULL_HOOK));
    { clObject token, prepositional_phrases, this_group, this_prep,
      disallowed_prepositions, used_prepositions;
      clSetq(token, clNIL);
      clSetq(prepositional_phrases, initial_phrases);
      clSetq(this_group, clNIL);
      clSetq(this_prep, clNIL);
      { clObject L_1, L_0;
        clSetq(L_0,
               clMakeClosure(2,
                             clLoopCollectPrepositionalPhrases_Lambda,
                             &clEnvHook(clLoopCollectPrepositionalPhrases_Lambda),
                             &*preposition_groups,
                             &*_InGroupP_));
        clSetq(L_1, initial_phrases);
        clSetq(disallowed_prepositions, clMapcan(L_0, L_1, clEOA)); }
      { clObject L_1, L_0;
        clSetq(L_0, clSymbolFunctionValue(clCAR));
        clSetq(L_1, initial_phrases);
        clSetq(used_prepositions, clMapcar(L_0, L_1, clEOA)); }
      clLabel(l_ITERATE514);
      if (clTrue(clNull(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                      clEOA),
                        clEOA)))
        return(clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                 prepositional_phrases,
                                 clEOA));
      clSetq(token,
             clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar, clEOA),
                   clEOA));
      { clObject L_sublist515, group;
        clSetq(L_sublist515, *preposition_groups);
        clSetq(group, clCar(L_sublist515, clEOA));
        clLabel(l_ITERATE516);
        if (clTrue(clEndp(L_sublist515, clEOA))) clLocalReturn(NIL);
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, token);
            clSetq(L_test,
                   clSetq(this_prep,
                          clFuncallFunction(*_InGroupP_,
                                            L_0,
                                            group,
                                            clEOA))); }
          if (clTrue(L_test))
            { clSetq(this_group, group); clLocalReturn(NIL); } }
        { clObject L_0;
          clSetq(L_0, L_sublist515);
          clSetq(L_sublist515, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist515);
          clSetq(group, clCar(L_0, clEOA)); }
        goto l_ITERATE516; }
      clBlockEnd(NIL);
      if (clTrue(this_group))
        { { clObject L_test__R1;
            { clObject L_item518, L_sub517;
              clSetq(L_item518, this_prep);
              clSetq(L_sub517, disallowed_prepositions);
              clLabel(l_ITERATE520);
              if (clTrue(clEndp(L_sub517, clEOA)))
                { clSetq(L_test__R1, clNIL); clLocalReturn(NIL__r1); }
              if (clTrue(clEql(L_item518,
                               clCar(L_sub517, clEOA),
                               clEOA)))
                { clSetq(L_test__R1, L_sub517);
                  clLocalReturn(l_MEMBER519__r1); }
              { clObject L_value521;
                clSetq(L_value521, clCdr(L_sub517, clEOA));
                clSetq(L_sub517, L_value521); }
              goto l_ITERATE520; }
            clBlockEnd(NIL__r1);
            clBlockEnd(l_MEMBER519__r1);
            if (clTrue(L_test__R1))
              { clObject L_1, L_0;
                { clObject L_test__R2;
                  { clObject L_item523, L_sub522;
                    clSetq(L_item523, this_prep);
                    clSetq(L_sub522, used_prepositions);
                    clLabel(l_ITERATE525);
                    if (clTrue(clEndp(L_sub522, clEOA)))
                      { clSetq(L_test__R2, clNIL);
                        clLocalReturn(NIL__r2); }
                    if (clTrue(clEql(L_item523,
                                     clCar(L_sub522, clEOA),
                                     clEOA)))
                      { clSetq(L_test__R2, L_sub522);
                        clLocalReturn(l_MEMBER524__r2); }
                    { clObject L_value526;
                      clSetq(L_value526, clCdr(L_sub522, clEOA));
                      clSetq(L_sub522, L_value526); }
                    goto l_ITERATE525; }
                  clBlockEnd(NIL__r2);
                  clBlockEnd(l_MEMBER524__r2);
                  clSetq(L_0,
                         (clTrue(L_test__R2) ? STRn_103 : STRn_104)); }
                clSetq(L_1, token);
                clLoopError(L_0, L_1, clEOA); } }
          { clObject L_test__R1;
            { clObject L_0;
              clSetq(L_0, this_group);
              clSetq(L_test__R1, clListp(L_0, clEOA)); }
            if (clTrue(L_test__R1))
              { clObject L_1, L_0;
                clSetq(L_0, this_group);
                clSetq(L_1, used_prepositions);
                clSetq(used_prepositions, clAppend(L_0, L_1, clEOA)); }
            else
              { clObject L_1, L_0;
                clSetq(L_0, this_group);
                clSetq(L_1, used_prepositions);
                clSetq(used_prepositions, clCons(L_0, L_1, clEOA)); } }
          clLoopPopSource(clEOA);
          { clObject L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, this_prep);
              clSetq(L_0,
                     clList(L_0__R1, clLoopGetForm(clEOA), clEOA)); }
            clSetq(L_1, prepositional_phrases);
            clSetq(prepositional_phrases, clCons(L_0, L_1, clEOA)); } }
      else
        { clObject L_test__R1;
          if (clTrue(using_allowed))
            { clObject L_0;
              clSetq(L_0, token);
              clSetq(L_test__R1, clLoopTequal(L_0, clUSING, clEOA)); }
          else clSetq(L_test__R1, clNIL);
          if (clTrue(L_test__R1))
            { clLoopPopSource(clEOA);
              { clObject z, tem;
                clSetq(z, clLoopPopSource(clEOA));
                clSetq(tem, clNIL);
                clLabel(l_ITERATE527);
                if (clTrue(clNIL)) clLocalReturn(NIL__r3);
                { clObject L_test__R2;
                  { clObject L_g528;
                    clSetq(L_g528, clAtom(z, clEOA));
                    if (clTrue(L_g528))
                      clSetq(L_test__R2, L_g528);
                    else
                      { clObject L_g529;
                        clSetq(L_g529, clAtom(clCdr(z, clEOA), clEOA));
                        if (clTrue(L_g529))
                        clSetq(L_test__R2, L_g529);
                        else
                        { clObject L_g530;
                          clSetq(L_g530,
                                 clNot(clNull(clCddr(z, clEOA), clEOA),
                                       clEOA));
                          if (clTrue(L_g530))
                          clSetq(L_test__R2, L_g530);
                          else
                          { clObject L_g531;
                            clSetq(L_g531,
                                   clNot(clSymbolp(clCar(z, clEOA),
                                                   clEOA),
                                         clEOA));
                            clSetq(L_test__R2,
                                   (clTrue(L_g531) ?
                                    L_g531 :
                                    (clTrue(clCadr(z, clEOA)) ?
                                     clNot(clSymbolp(clCadr(z, clEOA),
                                                     clEOA),
                                           clEOA) :
                                     clNIL))); } } } }
                  if (clTrue(L_test__R2))
                    clLoopError(STRn_105, z, clEOA); }
                if (clTrue(clCadr(z, clEOA)))
                  { clObject L_test__R3;
                    { clObject L_0;
                      clSetq(L_0, clCar(z, clEOA));
                      clSetq(L_test__R3,
                             clSetq(tem,
                                    clLoopTassoc(L_0,
                                                 clSymbolValue(clstarLOOP_NAMED_VARIABLESstar,
                                                               clEOA),
                                                 clEOA))); }
                    if (clTrue(L_test__R3))
                      { clObject L_3, L_2, L_1;
                        clSetq(L_1, clCar(z, clEOA));
                        clSetq(L_2, clCadr(z, clEOA));
                        { clObject L_0__R1;
                          clSetq(L_0__R1, tem);
                          clSetq(L_3, clCadr(L_0__R1, clEOA)); }
                        clLoopError(STRn_106, L_1, L_2, L_3, clEOA); }
                    else
                      { clObject L_0;
                        { clObject L_0__R1;
                          clSetq(L_0__R1, clCar(z, clEOA));
                          clSetq(L_0,
                                 clCons(L_0__R1,
                                        clCadr(z, clEOA),
                                        clEOA)); }
                        clSetSymbolValueValue(clstarLOOP_NAMED_VARIABLESstar,
                                              clCons(L_0,
                                                     clSymbolValue(clstarLOOP_NAMED_VARIABLESstar,
                                                                   clEOA),
                                                     clEOA)); } }
                { clObject L_test__R2;
                  { clObject L_g532;
                    clSetq(L_g532,
                           clNull(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                                clEOA),
                                  clEOA));
                    clSetq(L_test__R2,
                           (clTrue(L_g532) ?
                            L_g532 :
                            clSymbolp(clCar(clSymbolValue(clstarLOOP_SOURCE_CODEstar,
                                                          clEOA),
                                            clEOA),
                                      clEOA))); }
                  if (clTrue(L_test__R2)) clLocalReturn(NIL__r3); }
                { clObject L_value533;
                  clSetq(L_value533, clLoopPopSource(clEOA));
                  clSetq(z, L_value533); }
                goto l_ITERATE527; }
              clBlockEnd(NIL__r3); }
          else
            { clObject L_0;
              clSetq(L_0, prepositional_phrases);
              return(clFuncallFunction(clSymbolFunctionValue(clNREVERSE),
                                       L_0,
                                       clEOA)); } }
      (clSetq(this_group, clNIL), clSetq(this_prep, clNIL));
      goto l_ITERATE514; } } }

clObject clLoopSequencer clVdecl(_ap)
{ clObject indexv, indexv_type, indexv_user_specified_p, variable,
  variable_type, sequence_variable, sequence_type, step_hack,
  default_top, prep_phrases;
  { clBeginParse(_ap);
    clSetq(indexv,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(indexv_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(indexv_user_specified_p,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    clSetq(variable_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_5, clEOA)));
    clSetq(sequence_variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_6, clEOA)));
    clSetq(sequence_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_7, clEOA)));
    clSetq(step_hack,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_8, clEOA)));
    clSetq(default_top,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_9, clEOA)));
    clSetq(prep_phrases,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_10, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject endform, sequencep, testfn, test, stepby,
    stepby_constantp, step, dir, inclusive_iteration, start_given,
    start_value, start_constantp, limit_given, limit_constantp,
    limit_value;
    clSetq(endform, clNIL);
    clSetq(sequencep, clNIL);
    clSetq(testfn, clNIL);
    clSetq(test, clNIL);
    { clObject L_0;
      { clObject L_g536;
        clSetq(L_g536, clLoopTypedInit(indexv_type, clEOA));
        clSetq(L_0, (clTrue(L_g536) ? L_g536 : I_0)); }
      clSetq(stepby, cl1PLUS_FUNC(L_0, clEOA)); }
    clSetq(stepby_constantp, clT);
    clSetq(step, clNIL);
    clSetq(dir, clNIL);
    clSetq(inclusive_iteration, clNIL);
    clSetq(start_given, clNIL);
    clSetq(start_value, clNIL);
    clSetq(start_constantp, clNIL);
    clSetq(limit_given, clNIL);
    clSetq(limit_constantp, clNIL);
    clSetq(limit_value, clNIL);
    if (clTrue(variable))
      clLoopMakeIterationVariable(variable,
                                  clNIL,
                                  variable_type,
                                  clEOA);
    { clObject l, prep, form, odir;
      clSetq(l, prep_phrases);
      clSetq(prep, clNIL);
      clSetq(form, clNIL);
      clSetq(odir, clNIL);
      clLabel(l_ITERATE537);
      if (clTrue(clNull(l, clEOA))) clLocalReturn(NIL);
      clSetq(prep, clCaar(l, clEOA));
      clSetq(form, clCadar(l, clEOA));
      { clObject L_key538;
        clSetq(L_key538, prep);
        if (clTrue((_clEq(L_key538, keyOF) ? CONS_358 :
                    (_clEq(L_key538, keyIN) ? CONS_359 : clNIL))))
          { clSetq(sequencep, clT);
            { clObject L_1;
              clSetq(L_1, form);
              clLoopMakeVariable(sequence_variable,
                                 L_1,
                                 sequence_type,
                                 clEOA); } }
        else if (clTrue((_clEq(L_key538, keyFROM) ?
                         CONS_360 :
                         (_clEq(L_key538, keyDOWNFROM) ?
                          CONS_361 :
                          (_clEq(L_key538, keyUPFROM) ?
                           CONS_362 :
                           clNIL)))))
          { clSetq(start_given, clT);
            { clObject L_test__R2;
              { clObject L_0;
                clSetq(L_0, prep);
                clSetq(L_test__R2, clEq(L_0, keyDOWNFROM, clEOA)); }
              if (clTrue(L_test__R2))
                clSetq(dir, keyDOWN);
              else
                { clObject L_test__R3;
                  { clObject L_0;
                    clSetq(L_0, prep);
                    clSetq(L_test__R3, clEq(L_0, keyUPFROM, clEOA)); }
                  if (clTrue(L_test__R3)) clSetq(dir, keyUP); } }
            { clObject L_values544, L_form541, L_start_constantp542,
              L_start_value543;
              { clMultipleValueCall(MVC);
                clSetq(MVC, clSymbolFunctionValue(clLIST));
                { clObject L_0;
                  clSetq(L_0, form);
                  clLoopConstantFoldIfPossible(L_0,
                                               indexv_type,
                                               clEOA); }
                clAccumulateValues(MVC);
                clSetq(L_values544, clMultipleValueFuncall(MVC)); }
              clSetq(L_form541, clCar(L_values544, clEOA));
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values544);
                  clSetq(L_0,
                         clSetq(L_values544, clCdr(L_0__R1, clEOA))); }
                clSetq(L_start_constantp542, clCar(L_0, clEOA)); }
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values544);
                  clSetq(L_0,
                         clSetq(L_values544, clCdr(L_0__R1, clEOA))); }
                clSetq(L_start_value543, clCar(L_0, clEOA)); }
              clSetq(form, L_form541);
              clSetq(start_constantp, L_start_constantp542);
              clSetq(start_value, L_start_value543);
              (void) L_form541; }
            { clObject L_1;
              clSetq(L_1, form);
              clLoopMakeIterationVariable(indexv,
                                          L_1,
                                          indexv_type,
                                          clEOA); } }
        else if (clTrue((_clEq(L_key538, keyUPTO) ?
                         CONS_363 :
                         (_clEq(L_key538, keyTO) ?
                          CONS_364 :
                          (_clEq(L_key538, keyDOWNTO) ?
                           CONS_365 :
                           (_clEq(L_key538, keyABOVE) ?
                            CONS_366 :
                            (_clEq(L_key538, keyBELOW) ?
                             CONS_367 :
                             clNIL)))))))
          { { clObject L_test__R3;
              { clObject L_0;
                clSetq(L_0, prep);
                clSetq(L_test__R3,
                       clLoopTequal(L_0, keyUPTO, clEOA)); }
              if (clTrue(L_test__R3))
                clSetq(inclusive_iteration, clSetq(dir, keyUP));
              else
                { clObject L_test__R4;
                  { clObject L_0;
                    clSetq(L_0, prep);
                    clSetq(L_test__R4,
                           clLoopTequal(L_0, keyTO, clEOA)); }
                  if (clTrue(L_test__R4))
                    clSetq(inclusive_iteration, clT);
                  else
                    { clObject L_test__R5;
                      { clObject L_0;
                        clSetq(L_0, prep);
                        clSetq(L_test__R5,
                               clLoopTequal(L_0, keyDOWNTO, clEOA)); }
                      if (clTrue(L_test__R5))
                      clSetq(inclusive_iteration,
                             clSetq(dir, keyDOWN));
                      else
                      { clObject L_test__R6;
                        { clObject L_0;
                          clSetq(L_0, prep);
                          clSetq(L_test__R6,
                                 clLoopTequal(L_0, keyABOVE, clEOA)); }
                        if (clTrue(L_test__R6))
                        clSetq(dir, keyDOWN);
                        else
                        { clObject L_test__R7;
                          { clObject L_0;
                            clSetq(L_0, prep);
                            clSetq(L_test__R7,
                                   clLoopTequal(L_0,
                                                keyBELOW,
                                                clEOA)); }
                          if (clTrue(L_test__R7))
                          clSetq(dir, keyUP); } } } } }
            clSetq(limit_given, clT);
            { clObject L_values549, L_form546, L_limit_constantp547,
              L_limit_value548;
              { clMultipleValueCall(MVC__r1);
                clSetq(MVC__r1, clSymbolFunctionValue(clLIST));
                { clObject L_0;
                  clSetq(L_0, form);
                  clLoopConstantFoldIfPossible(L_0,
                                               indexv_type,
                                               clEOA); }
                clAccumulateValues(MVC__r1);
                clSetq(L_values549, clMultipleValueFuncall(MVC__r1)); }
              clSetq(L_form546, clCar(L_values549, clEOA));
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values549);
                  clSetq(L_0,
                         clSetq(L_values549, clCdr(L_0__R1, clEOA))); }
                clSetq(L_limit_constantp547, clCar(L_0, clEOA)); }
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values549);
                  clSetq(L_0,
                         clSetq(L_values549, clCdr(L_0__R1, clEOA))); }
                clSetq(L_limit_value548, clCar(L_0, clEOA)); }
              clSetq(form, L_form546);
              clSetq(limit_constantp, L_limit_constantp547);
              clSetq(limit_value, L_limit_value548);
              (void) L_form546; }
            if (clTrue(limit_constantp))
              { clObject L_1;
                clSetq(L_1, limit_value);
                clSetq(endform, clList(clQUOTE, L_1, clEOA)); }
            else
              { clObject L_1, L_0;
                clSetq(L_0, clLoopGentemp(clLOOP_LIMIT_, clEOA));
                clSetq(L_1, form);
                clSetq(endform,
                       clLoopMakeVariable(L_0,
                                          L_1,
                                          indexv_type,
                                          clEOA)); } }
        else if (_clEq(L_key538, keyBY))
          { { clObject L_values553, L_form550, L_stepby_constantp551,
              L_stepby552;
              { clMultipleValueCall(MVC__r2);
                clSetq(MVC__r2, clSymbolFunctionValue(clLIST));
                { clObject L_0;
                  clSetq(L_0, form);
                  clLoopConstantFoldIfPossible(L_0,
                                               indexv_type,
                                               clEOA); }
                clAccumulateValues(MVC__r2);
                clSetq(L_values553, clMultipleValueFuncall(MVC__r2)); }
              clSetq(L_form550, clCar(L_values553, clEOA));
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values553);
                  clSetq(L_0,
                         clSetq(L_values553, clCdr(L_0__R1, clEOA))); }
                clSetq(L_stepby_constantp551, clCar(L_0, clEOA)); }
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values553);
                  clSetq(L_0,
                         clSetq(L_values553, clCdr(L_0__R1, clEOA))); }
                clSetq(L_stepby552, clCar(L_0, clEOA)); }
              clSetq(form, L_form550);
              clSetq(stepby_constantp, L_stepby_constantp551);
              clSetq(stepby, L_stepby552);
              (void) L_form550; }
            { clObject L_test__R4;
              { clObject L_0;
                clSetq(L_0, stepby_constantp);
                clSetq(L_test__R4, clNot(L_0, clEOA)); }
              if (clTrue(L_test__R4))
                { clObject L_1, L_0;
                  clSetq(L_0,
                         clSetq(stepby,
                                clLoopGentemp(clLOOP_STEP_BY_,
                                              clEOA)));
                  clSetq(L_1, form);
                  clLoopMakeVariable(L_0,
                                     L_1,
                                     indexv_type,
                                     clEOA); } } }
        else
          { clObject L_1;
            clSetq(L_1, prep);
            clLoopError(STRn_118, L_1, clEOA); } }
      { clObject L_test;
        if (clTrue(odir))
          if (clTrue(dir))
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, dir);
                clSetq(L_0, clEq(L_0__R1, odir, clEOA)); }
              clSetq(L_test, clNot(L_0, clEOA)); }
          else clSetq(L_test, clNIL);
        else clSetq(L_test, clNIL);
        if (clTrue(L_test)) clLoopError(STRn_119, clEOA); }
      clSetq(odir, dir);
      { clObject L_value554;
        clSetq(L_value554, clCdr(l, clEOA));
        clSetq(l, L_value554); }
      goto l_ITERATE537; }
    clBlockEnd(NIL);
    { clObject L_test;
      if (clTrue(sequence_variable))
        { clObject L_0;
          clSetq(L_0, sequencep);
          clSetq(L_test, clNot(L_0, clEOA)); }
      else clSetq(L_test, clNIL);
      if (clTrue(L_test)) clLoopError(STRn_120, clEOA); }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0, start_given);
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test))
        { clObject L_1;
          clSetq(start_constantp, clT);
          { clObject L_g555;
            clSetq(L_g555, clLoopTypedInit(indexv_type, clEOA));
            clSetq(L_1,
                   (clTrue(L_g555) ? clSetq(start_value, L_g555) :
                    clSetq(start_value, I_0))); }
          clLoopMakeIterationVariable(indexv,
                                      L_1,
                                      indexv_type,
                                      clEOA); } }
    { clObject L_test;
      { clObject L_item556;
        clSetq(L_item556, dir);
        clSetq(L_test,
               (_clEq(L_item556, clNIL) ? CONS_368 :
                (_clEq(L_item556, keyUP) ? CONS_369 : clNIL))); }
      if (clTrue(L_test))
        { { clObject L_test__R1;
            { clObject L_g557;
              clSetq(L_g557, limit_given);
              clSetq(L_test__R1,
                     (clTrue(L_g557) ? L_g557 : default_top)); }
            if (clTrue(L_test__R1))
              { { clObject L_test__R2;
                  { clObject L_0;
                    clSetq(L_0, limit_given);
                    clSetq(L_test__R2, clNot(L_0, clEOA)); }
                  if (clTrue(L_test__R2))
                    { { clObject L_0;
                        clSetq(L_0,
                               clSetq(endform,
                                      clLoopGentemp(clLOOP_SEQ_LIMIT_,
                                                    clEOA)));
                        clLoopMakeVariable(L_0,
                                           clNIL,
                                           indexv_type,
                                           clEOA); }
                      { clObject L_0;
                        { clObject L_1__R1;
                          clSetq(L_1__R1, endform);
                          clSetq(L_0,
                                 clList(clSETQ,
                                        L_1__R1,
                                        default_top,
                                        clEOA)); }
                        clSetSymbolValueValue(clstarLOOP_PROLOGUEstar,
                                              clCons(L_0,
                                                     clSymbolValue(clstarLOOP_PROLOGUEstar,
                                                                   clEOA),
                                                     clEOA)); } } }
                clSetq(testfn,
                       (clTrue(inclusive_iteration) ?
                        clgreatersymbol :
                        clgreaterequalsymbol)); } }
          { clObject L_test__R1;
            { clObject L_0;
              clSetq(L_0, stepby);
              clSetq(L_test__R1, clEql(L_0, I_1, clEOA)); }
            if (clTrue(L_test__R1))
              clSetq(step, clList(cl1plussymbol, indexv, clEOA));
            else
              { clObject L_2;
                clSetq(L_2, stepby);
                clSetq(step,
                       clList(clplussymbol, indexv, L_2, clEOA)); } } }
      else
        { { clObject L_test__R1;
            { clObject L_0;
              clSetq(L_0, start_given);
              clSetq(L_test__R1, clNot(L_0, clEOA)); }
            if (clTrue(L_test__R1))
              { if (clTrue(clNot(default_top, clEOA)))
                  clLoopError(STRn_121, clEOA);
                { clObject L_0;
                  clSetq(L_0,
                         clList(clSETQ,
                                indexv,
                                clList(cl1_symbol, default_top, clEOA),
                                clEOA));
                  clSetSymbolValueValue(clstarLOOP_PROLOGUEstar,
                                        clCons(L_0,
                                               clSymbolValue(clstarLOOP_PROLOGUEstar,
                                                             clEOA),
                                               clEOA)); } } }
          { clObject L_test__R1;
            if (clTrue(default_top))
              { clObject L_0;
                clSetq(L_0, endform);
                clSetq(L_test__R1, clNot(L_0, clEOA)); }
            else clSetq(L_test__R1, clNIL);
            if (clTrue(L_test__R1))
              { clSetq(endform, clLoopTypedInit(indexv_type, clEOA));
                clSetq(inclusive_iteration, clT); } }
          if (clTrue(endform))
            clSetq(testfn,
                   (clTrue(inclusive_iteration) ? cllesssymbol :
                    cllessequalsymbol));
          { clObject L_test__R1;
            { clObject L_0;
              clSetq(L_0, stepby);
              clSetq(L_test__R1, clEql(L_0, I_1, clEOA)); }
            if (clTrue(L_test__R1))
              clSetq(step, clList(cl1_symbol, indexv, clEOA));
            else
              { clObject L_2;
                clSetq(L_2, stepby);
                clSetq(step,
                       clList(cl_symbol, indexv, L_2, clEOA)); } } } }
    if (clTrue(testfn))
      { clObject L_2;
        { clObject L_2__R1, L_0__R1;
          clSetq(L_0__R1, testfn);
          clSetq(L_2__R1, endform);
          clSetq(L_2, clList(L_0__R1, indexv, L_2__R1, clEOA)); }
        clSetq(test,
               clHideVariableReference(clT, indexv, L_2, clEOA)); }
    if (clTrue(step_hack))
      { clObject L_1;
        clSetq(L_1,
               clHideVariableReference(indexv_user_specified_p,
                                       indexv,
                                       step_hack,
                                       clEOA));
        clSetq(step_hack, clList(variable, L_1, clEOA)); }
    { clObject first_test, remaining_tests;
      clSetq(first_test, test);
      clSetq(remaining_tests, test);
      if (clTrue((clTrue(stepby_constantp) ?
                  (clTrue(start_constantp) ? limit_constantp : clNIL) :
                  clNIL)))
        { clObject L_test__R1;
          { clObject L_2, L_1, L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, testfn);
              clSetq(L_0, clSymbolFunction(L_0__R1, clEOA)); }
            clSetq(L_1, start_value);
            clSetq(L_2, limit_value);
            clSetq(L_test__R1,
                   clSetq(first_test,
                          clFuncall(L_0, L_1, L_2, clEOA))); }
          if (clTrue(L_test__R1)) clSetq(remaining_tests, clT); }
      { clObject L_7, L_6, L_3, L_2, L_1;
        { clObject L_1__R1;
          { clObject L_2__R1;
            clSetq(L_2__R1, step);
            clSetq(L_1__R1,
                   clHideVariableReference(clT,
                                           indexv,
                                           L_2__R1,
                                           clEOA)); }
          clSetq(L_1, clList(indexv, L_1__R1, clEOA)); }
        clSetq(L_2, remaining_tests);
        clSetq(L_3, step_hack);
        clSetq(L_6, first_test);
        clSetq(L_7, step_hack);
        return(clList(clNIL,
                      L_1,
                      L_2,
                      L_3,
                      clNIL,
                      clNIL,
                      L_6,
                      L_7,
                      clEOA)); } } } }

clObject clLoopForArithmetic clVdecl(_ap)
{ clObject var, val, data_type, kwd;
  { clBeginParse(_ap);
    clSetq(var,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(val,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(kwd,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1;
    clSetq(L_1,
           clLoopCheckDataType(data_type,
                               clSymbolValue(clstarLOOP_REAL_DATA_TYPEstar,
                                             clEOA),
                               clEOA));
    return(clLoopSequencer(var,
                           L_1,
                           clT,
                           clNIL,
                           clNIL,
                           clNIL,
                           clNIL,
                           clNIL,
                           clNIL,
                           clLoopCollectPrepositionalPhrases(CONS_370,
                                                             clNIL,
                                                             clList(clList(kwd,
                                                                           val,
                                                                           clEOA),
                                                                    clEOA),
                                                             clEOA),
                           clEOA)); } }

clObject clLoopSequenceElementsPath clVdecl(_ap)
{ clObject L_ap, variable, data_type, prep_phrases, L_keys,
  fetch_function, size_function, sequence_type, element_type;
  { clBeginParse(_ap);
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(prep_phrases,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keyFETCH_FUNCTION, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(fetch_function, clCar(L_0, clEOA)); }
    else clSetq(fetch_function, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keySIZE_FUNCTION, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(size_function, clCar(L_0, clEOA)); }
    else clSetq(size_function, clNIL);
    if (clTrue(clSetq(L_ap,
                      clKeyArg(keySEQUENCE_TYPE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(sequence_type, clCar(L_0, clEOA)); }
    else clSetq(sequence_type, clNIL);
    if (clTrue(clSetq(L_ap, clKeyArg(keyELEMENT_TYPE, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(element_type, clCar(L_0, clEOA)); }
    else clSetq(element_type, clNIL);
    clCheckKeys(L_keys, CONS_379, clEOA);
    clEndParse(_ap); }
  { clObject L_values558, indexv, indexv_user_specified_p;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      clNamedVariable(clINDEX, clEOA);
      clAccumulateValues(MVC);
      clSetq(L_values558, clMultipleValueFuncall(MVC)); }
    clSetq(indexv, clCar(L_values558, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values558);
        clSetq(L_0, clSetq(L_values558, clCdr(L_0__R1, clEOA))); }
      clSetq(indexv_user_specified_p, clCar(L_0, clEOA)); }
    { clObject sequencev;
      clSetq(sequencev, clNamedVariable(clSEQUENCE, clEOA));
      { clObject L_2;
        { clObject L_8, L_7, L_6, L_4;
          clSetq(L_4, (clTrue(data_type) ? data_type : element_type));
          clSetq(L_6, sequence_type);
          { clObject L_0__R2;
            clSetq(L_0__R2, fetch_function);
            clSetq(L_7, clList(L_0__R2, sequencev, indexv, clEOA)); }
          { clObject L_0__R2;
            clSetq(L_0__R2, size_function);
            clSetq(L_8, clList(L_0__R2, sequencev, clEOA)); }
          clSetq(L_2,
                 clLoopSequencer(indexv,
                                 clFIXNUM,
                                 indexv_user_specified_p,
                                 variable,
                                 L_4,
                                 sequencev,
                                 L_6,
                                 L_7,
                                 L_8,
                                 prep_phrases,
                                 clEOA)); }
        return(clListSTAR(clNIL, clNIL, L_2, clEOA)); } } } }

clObject clLoopHashTableIterationPath clVdecl(_ap)
{ clObject L_ap, variable, data_type, prep_phrases, L_keys, which;
  { clBeginParse(_ap);
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(prep_phrases,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keyWHICH, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(which, clCar(L_0, clEOA)); }
    else clSetq(which, clNIL);
    clCheckKeys(L_keys, CONS_383, clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_g560;
      clSetq(L_g560, clCdr(prep_phrases, clEOA));
      if (clTrue(L_g560))
        clSetq(L_test, L_g560);
      else
        { clObject L_0;
          { clObject L_item561;
            clSetq(L_item561, clCaar(prep_phrases, clEOA));
            clSetq(L_0,
                   (_clEq(L_item561, keyIN) ? CONS_384 :
                    (_clEq(L_item561, keyOF) ? CONS_385 : clNIL))); }
          clSetq(L_test, clNot(L_0, clEOA)); } }
    if (clTrue(L_test))
      clLoopError(STRn_127, clEOA);
    else if (clTrue(clNull(prep_phrases, clEOA)))
      clLoopError(STRn_128, clEOA); }
  { clObject ht_var, next_fn, dummy_predicate_var, post_steps;
    clSetq(ht_var, clLoopGentemp(clLOOP_HASHTAB_, clEOA));
    clSetq(next_fn, clLoopGentemp(clLOOP_HASHTAB_NEXT_, clEOA));
    clSetq(dummy_predicate_var, clNIL);
    clSetq(post_steps, clNIL);
    { clObject L_values562, other_var, other_p;
      { clMultipleValueCall(MVC);
        clSetq(MVC, clSymbolFunctionValue(clLIST));
        { clObject L_0;
          { clObject L_test;
            { clObject L_0__R1;
              clSetq(L_0__R1, which);
              clSetq(L_test, clEq(L_0__R1, clHASH_KEY, clEOA)); }
            clSetq(L_0,
                   (clTrue(L_test) ? clHASH_VALUE : clHASH_KEY)); }
          clNamedVariable(L_0, clEOA); }
        clAccumulateValues(MVC);
        clSetq(L_values562, clMultipleValueFuncall(MVC)); }
      clSetq(other_var, clCar(L_values562, clEOA));
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values562);
          clSetq(L_0, clSetq(L_values562, clCdr(L_0__R1, clEOA))); }
        clSetq(other_p, clCar(L_0, clEOA)); }
      clSetq(other_p, clT);
      clSetq(dummy_predicate_var, clLoopWhenItVariable(clEOA));
      { clObject key_var, val_var, bindings;
        clSetq(key_var, clNIL);
        clSetq(val_var, clNIL);
        { clObject L_2, L_1, L_0;
          clSetq(L_0, clList(variable, clNIL, data_type, clEOA));
          clSetq(L_1,
                 clList(ht_var, clCadar(prep_phrases, clEOA), clEOA));
          clSetq(L_2,
                 (clTrue(other_p) ?
                  (clTrue(other_var) ?
                   clList(clListSTAR(other_var, CONS_2, clEOA),
                          clEOA) :
                   clNIL) :
                  clNIL));
          clSetq(bindings, clListSTAR(L_0, L_1, L_2, clEOA)); }
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, which);
            clSetq(L_test, clEq(L_0, clHASH_KEY, clEOA)); }
          if (clTrue(L_test))
            { clSetq(key_var, variable);
              clSetq(val_var, (clTrue(other_p) ? other_var : clNIL)); }
          else
            { clSetq(key_var, (clTrue(other_p) ? other_var : clNIL));
              clSetq(val_var, variable); } }
        { clObject L_0;
          clSetq(L_0,
                 clList(clWITH_HASH_TABLE_ITERATOR,
                        clList(next_fn, ht_var, clEOA),
                        clEOA));
          clSetSymbolValueValue(clstarLOOP_WRAPPERSstar,
                                clCons(L_0,
                                       clSymbolValue(clstarLOOP_WRAPPERSstar,
                                                     clEOA),
                                       clEOA)); }
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, key_var);
            clSetq(L_test, clConsp(L_0, clEOA)); }
          if (clTrue(L_test))
            { { clObject L_2, L_1, L_0;
                clSetq(L_0, key_var);
                clSetq(L_1,
                       clSetq(key_var,
                              clLoopGentemp(clLOOP_HASH_KEY_TEMP_,
                                            clEOA)));
                clSetq(L_2, post_steps);
                clSetq(post_steps, clListSTAR(L_0, L_1, L_2, clEOA)); }
              { clObject L_1, L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, key_var);
                  clSetq(L_0, clListSTAR(L_0__R1, CONS_2, clEOA)); }
                clSetq(L_1, bindings);
                clSetq(bindings, clCons(L_0, L_1, clEOA)); } } }
        { clObject L_test;
          { clObject L_0;
            clSetq(L_0, val_var);
            clSetq(L_test, clConsp(L_0, clEOA)); }
          if (clTrue(L_test))
            { { clObject L_2, L_1, L_0;
                clSetq(L_0, val_var);
                clSetq(L_1,
                       clSetq(val_var,
                              clLoopGentemp(clLOOP_HASH_VAL_TEMP_,
                                            clEOA)));
                clSetq(L_2, post_steps);
                clSetq(post_steps, clListSTAR(L_0, L_1, L_2, clEOA)); }
              { clObject L_1, L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, val_var);
                  clSetq(L_0, clListSTAR(L_0__R1, CONS_2, clEOA)); }
                clSetq(L_1, bindings);
                clSetq(bindings, clCons(L_0, L_1, clEOA)); } } }
        { clObject L_5, L_4, L_0;
          clSetq(L_0, bindings);
          { clObject L_1__R1;
            { clObject L_1__R2;
              { clObject L_2__R2, L_1__R3, L_0__R3;
                clSetq(L_0__R3, dummy_predicate_var);
                clSetq(L_1__R3, key_var);
                clSetq(L_2__R2, val_var);
                clSetq(L_1__R2,
                       clList(L_0__R3, L_1__R3, L_2__R2, clEOA)); }
              clSetq(L_1__R1,
                     clList(clMULTIPLE_VALUE_SETQ,
                            L_1__R2,
                            clList(next_fn, clEOA),
                            clEOA)); }
            clSetq(L_4, clList(clNOT, L_1__R1, clEOA)); }
          clSetq(L_5, post_steps);
          return(clList(L_0,
                        clNIL,
                        clNIL,
                        clNIL,
                        L_4,
                        L_5,
                        clEOA)); } } } } }

clObject clLoopPackageSymbolsIterationPath clVdecl(_ap)
{ clObject L_ap, variable, data_type, prep_phrases, L_keys,
  symbol_types;
  { clBeginParse(_ap);
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(data_type,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(prep_phrases,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(L_keys, clVargs(_ap));
    if (clTrue(clSetq(L_ap, clKeyArg(keySYMBOL_TYPES, L_keys, clEOA))))
      { clObject L_0;
        clSetq(L_0, L_ap);
        clSetq(symbol_types, clCar(L_0, clEOA)); }
    else clSetq(symbol_types, clNIL);
    clCheckKeys(L_keys, CONS_386, clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_g563;
      clSetq(L_g563, clCdr(prep_phrases, clEOA));
      if (clTrue(L_g563))
        clSetq(L_test, L_g563);
      else
        { clObject L_0;
          { clObject L_item564;
            clSetq(L_item564, clCaar(prep_phrases, clEOA));
            clSetq(L_0,
                   (_clEq(L_item564, keyIN) ? CONS_384 :
                    (_clEq(L_item564, keyOF) ? CONS_385 : clNIL))); }
          clSetq(L_test, clNot(L_0, clEOA)); } }
    if (clTrue(L_test))
      clLoopError(STRn_127, clEOA);
    else if (clTrue(clNull(prep_phrases, clEOA)))
      clLoopError(STRn_128, clEOA); }
  if (clTrue(clNot(clSymbolp(variable, clEOA), clEOA)))
    clLoopError(STRn_130, clEOA);
  { clObject pkg_var, next_fn;
    clSetq(pkg_var, clLoopGentemp(clLOOP_PKGSYM_, clEOA));
    clSetq(next_fn, clLoopGentemp(clLOOP_PKGSYM_NEXT_, clEOA));
    { clObject L_0;
      { clObject L_1__R1;
        { clObject L_2;
          clSetq(L_2, symbol_types);
          clSetq(L_1__R1, clListSTAR(next_fn, pkg_var, L_2, clEOA)); }
        clSetq(L_0, clList(clWITH_PACKAGE_ITERATOR, L_1__R1, clEOA)); }
      clSetSymbolValueValue(clstarLOOP_WRAPPERSstar,
                            clCons(L_0,
                                   clSymbolValue(clstarLOOP_WRAPPERSstar,
                                                 clEOA),
                                   clEOA)); }
    { clObject L_4, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clList(variable, clNIL, data_type, clEOA));
        clSetq(L_0,
               clList(L_0__R1,
                      clList(pkg_var,
                             clCadar(prep_phrases, clEOA),
                             clEOA),
                      clEOA)); }
      { clObject L_1__R1;
        { clObject L_1__R2;
          { clObject L_0__R3;
            clSetq(L_0__R3, clLoopWhenItVariable(clEOA));
            clSetq(L_1__R2, clList(L_0__R3, variable, clEOA)); }
          clSetq(L_1__R1,
                 clList(clMULTIPLE_VALUE_SETQ,
                        L_1__R2,
                        clList(next_fn, clEOA),
                        clEOA)); }
        clSetq(L_4, clList(clNOT, L_1__R1, clEOA)); }
      return(clListSTAR(L_0,
                        clNIL,
                        clNIL,
                        clNIL,
                        L_4,
                        CONS_2,
                        clEOA)); } } }

clObject clMakeAnsiLoopUniverse clVdecl(_ap)
{ clObject extended_p;
  { clBeginParse(_ap);
    clSetq(extended_p,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject w;
    { clObject L_11, L_1;
      { clObject L_13, L_12;
        { clObject L_1__R2;
          { clObject L_2__R2;
            clSetq(L_2__R2,
                   clSymbolValue(clstarLOOP_REAL_DATA_TYPEstar,
                                 clEOA));
            clSetq(L_1__R2,
                   clListSTAR(clLOOP_SUM_COLLECTION,
                              clCOUNT,
                              L_2__R2,
                              CONS_417,
                              clEOA)); }
          clSetq(L_12, clList(clCOUNT, L_1__R2, clEOA)); }
        { clObject L_1__R2;
          { clObject L_2__R2;
            clSetq(L_2__R2,
                   clSymbolValue(clstarLOOP_REAL_DATA_TYPEstar,
                                 clEOA));
            clSetq(L_1__R2,
                   clListSTAR(clLOOP_SUM_COLLECTION,
                              clCOUNT,
                              L_2__R2,
                              CONS_417,
                              clEOA)); }
          clSetq(L_13, clList(clCOUNTING, L_1__R2, clEOA)); }
        clSetq(L_1,
               clListSTAR(CONS_387,
                          CONS_390,
                          CONS_393,
                          CONS_396,
                          CONS_399,
                          CONS_400,
                          CONS_403,
                          CONS_407,
                          CONS_408,
                          CONS_411,
                          CONS_412,
                          CONS_416,
                          L_12,
                          L_13,
                          CONS_418,
                          clEOA)); }
      clSetq(L_11, (clTrue(extended_p) ? keyEXTENDED : clT));
      clSetq(w,
             clMakeStandardLoopUniverse(keyKEYWORDS,
                                        L_1,
                                        keyFOR_KEYWORDS,
                                        CONS_485,
                                        keyITERATION_KEYWORDS,
                                        CONS_532,
                                        keyTYPE_SYMBOLS,
                                        CONS_542,
                                        keyTYPE_KEYWORDS,
                                        clNIL,
                                        keyANSI,
                                        L_11,
                                        clEOA)); }
    clAddLoopPath(CONS_583, clLOOP_HASH_TABLE_ITERATION_PATH, w,
                  keyPREPOSITION_GROUPS, CONS_585,
                  keyINCLUSIVE_PERMITTED, clNIL, keyUSER_DATA,
                  CONS_586, clEOA);
    clAddLoopPath(CONS_588, clLOOP_HASH_TABLE_ITERATION_PATH, w,
                  keyPREPOSITION_GROUPS, CONS_585,
                  keyINCLUSIVE_PERMITTED, clNIL, keyUSER_DATA,
                  CONS_590, clEOA);
    clAddLoopPath(CONS_592, clLOOP_PACKAGE_SYMBOLS_ITERATION_PATH, w,
                  keyPREPOSITION_GROUPS, CONS_585,
                  keyINCLUSIVE_PERMITTED, clNIL, keyUSER_DATA,
                  CONS_594, clEOA);
    clAddLoopPath(CONS_599, clLOOP_PACKAGE_SYMBOLS_ITERATION_PATH, w,
                  keyPREPOSITION_GROUPS, CONS_585,
                  keyINCLUSIVE_PERMITTED, clNIL, keyUSER_DATA,
                  CONS_601, clEOA);
    clAddLoopPath(CONS_604, clLOOP_PACKAGE_SYMBOLS_ITERATION_PATH, w,
                  keyPREPOSITION_GROUPS, CONS_585,
                  keyINCLUSIVE_PERMITTED, clNIL, keyUSER_DATA,
                  CONS_606, clEOA);
    return(clValues1(w)); } }

clObject clLoopStandardExpansion clVdecl(_ap)
{ clObject keywords_and_forms, environment, universe;
  { clBeginParse(_ap);
    clSetq(keywords_and_forms,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(environment,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(universe,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject sample;
    clSetq(sample, clCar(keywords_and_forms, clEOA));
    if (clTrue((clTrue(sample) ? clSymbolp(sample, clEOA) : clNIL)))
      return(clLoopTranslate(keywords_and_forms,
                             environment,
                             universe,
                             clEOA));
    else
      { clObject tag;
        clSetq(tag, clGensym(STR_LOOP__136, clEOA));
        { clObject L_2;
          { clObject L_2__R1;
            clSetq(L_2__R1,
                   clListSTAR(clPROGN, keywords_and_forms, clEOA));
            clSetq(L_2,
                   clList(clTAGBODY,
                          tag,
                          L_2__R1,
                          clList(clGO, tag, clEOA),
                          clEOA)); }
          return(clList(clBLOCK, clNIL, L_2, clEOA)); } } } }

clObject clLoop clVdecl(_ap)
{ clObject L_form, env, keywords_and_forms;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    clSetq(keywords_and_forms, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clLoopStandardExpansion(keywords_and_forms,
                                 env,
                                 clSymbolValue(clstarLOOP_ANSI_UNIVERSEstar,
                                               clEOA),
                                 clEOA)); }

void clInitLoop __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(I_3, clIntFixnum(3));
  clSetq(CONS_2, clCons(clNIL, clNIL, clEOA));
  clSetq(CONS_1, clCons(clLIST, CONS_2, clEOA));
  clSetq(CONS_0, clCons(CONS_1, clNIL, clEOA));
  clSetq(I_5, clIntFixnum(5));
  clSetq(I_4, clIntFixnum(4));
  clSetq(CONS_4, clCons(clCONS, clNIL, clEOA));
  clSetq(CONS_3, clCons(clLISTstar, CONS_4, clEOA));
  clSetq(CONS_7, clCons(clQUOTE, CONS_2, clEOA));
  clSetq(CONS_6, clCons(CONS_7, clNIL, clEOA));
  clSetq(CONS_5, clCons(clNIL, CONS_6, clEOA));
  clSetq(I_0, clIntFixnum(0));
  clSetq(STR_CONSTRUCTORS__0,
         clCharpSimpleBaseString("CONSTRUCTORS"));
  clSetq(keyCONSTRUCTORS, clMakeKeyword(STR_CONSTRUCTORS__0, clEOA));
  clSetq(CONS_11, clCons(clMAKE_LOOP_MINIMAX_INTERNAL, clNIL, clEOA));
  clSetq(CONS_10, clCons(CONS_11, clNIL, clEOA));
  clSetq(STR_COPIER__1,
         clCharpSimpleBaseString("COPIER"));
  clSetq(keyCOPIER, clMakeKeyword(STR_COPIER__1, clEOA));
  clSetq(STR_PREDICATE__2,
         clCharpSimpleBaseString("PREDICATE"));
  clSetq(keyPREDICATE, clMakeKeyword(STR_PREDICATE__2, clEOA));
  clSetq(STR_DIRECT_SLOTS__3,
         clCharpSimpleBaseString("DIRECT-SLOTS"));
  clSetq(keyDIRECT_SLOTS, clMakeKeyword(STR_DIRECT_SLOTS__3, clEOA));
  clSetq(STR_NAME__4,
         clCharpSimpleBaseString("NAME"));
  clSetq(keyNAME, clMakeKeyword(STR_NAME__4, clEOA));
  clSetq(CONS_20, clCons(clANSWER_VARIABLE, clNIL, clEOA));
  clSetq(CONS_19, clCons(keyNAME, CONS_20, clEOA));
  clSetq(CONS_23, clCons(clTYPE, clNIL, clEOA));
  clSetq(CONS_22, clCons(keyNAME, CONS_23, clEOA));
  clSetq(CONS_26, clCons(clTEMP_VARIABLE, clNIL, clEOA));
  clSetq(CONS_25, clCons(keyNAME, CONS_26, clEOA));
  clSetq(CONS_29, clCons(clFLAG_VARIABLE, clNIL, clEOA));
  clSetq(CONS_28, clCons(keyNAME, CONS_29, clEOA));
  clSetq(CONS_32, clCons(clOPERATIONS, clNIL, clEOA));
  clSetq(CONS_31, clCons(keyNAME, CONS_32, clEOA));
  clSetq(CONS_35, clCons(clINFINITY_DATA, clNIL, clEOA));
  clSetq(CONS_34, clCons(keyNAME, CONS_35, clEOA));
  clSetq(CONS_33, clCons(CONS_34, clNIL, clEOA));
  clSetq(CONS_30, clCons(CONS_31, CONS_33, clEOA));
  clSetq(CONS_27, clCons(CONS_28, CONS_30, clEOA));
  clSetq(CONS_24, clCons(CONS_25, CONS_27, clEOA));
  clSetq(CONS_21, clCons(CONS_22, CONS_24, clEOA));
  clSetq(CONS_18, clCons(CONS_19, CONS_21, clEOA));
  clSetq(CONS_17, clCons(CONS_18, clNIL, clEOA));
  clSetq(CONS_16, clCons(keyDIRECT_SLOTS, CONS_17, clEOA));
  clSetq(CONS_15, clCons(clNIL, CONS_16, clEOA));
  clSetq(CONS_14, clCons(keyPREDICATE, CONS_15, clEOA));
  clSetq(CONS_13, clCons(clNIL, CONS_14, clEOA));
  clSetq(CONS_12, clCons(keyCOPIER, CONS_13, clEOA));
  clSetq(CONS_9, clCons(CONS_10, CONS_12, clEOA));
  clSetq(CONS_8, clCons(keyCONSTRUCTORS, CONS_9, clEOA));
  clSetq(STR_ANSWER_VARIABLE__5,
         clCharpSimpleBaseString("ANSWER-VARIABLE"));
  clSetq(keyANSWER_VARIABLE,
         clMakeKeyword(STR_ANSWER_VARIABLE__5, clEOA));
  clSetq(STR_TYPE__6,
         clCharpSimpleBaseString("TYPE"));
  clSetq(keyTYPE, clMakeKeyword(STR_TYPE__6, clEOA));
  clSetq(STR_TEMP_VARIABLE__7,
         clCharpSimpleBaseString("TEMP-VARIABLE"));
  clSetq(keyTEMP_VARIABLE, clMakeKeyword(STR_TEMP_VARIABLE__7, clEOA));
  clSetq(STR_FLAG_VARIABLE__8,
         clCharpSimpleBaseString("FLAG-VARIABLE"));
  clSetq(keyFLAG_VARIABLE, clMakeKeyword(STR_FLAG_VARIABLE__8, clEOA));
  clSetq(STR_OPERATIONS__9,
         clCharpSimpleBaseString("OPERATIONS"));
  clSetq(keyOPERATIONS, clMakeKeyword(STR_OPERATIONS__9, clEOA));
  clSetq(STR_INFINITY_DATA__10,
         clCharpSimpleBaseString("INFINITY-DATA"));
  clSetq(keyINFINITY_DATA,
         clMakeKeyword(STR_INFINITY_DATA__10, clEOA));
  clSetq(CONS_41, clCons(keyANSWER_VARIABLE, clNIL, clEOA));
  clSetq(CONS_40, clCons(keyTYPE, CONS_41, clEOA));
  clSetq(CONS_39, clCons(keyTEMP_VARIABLE, CONS_40, clEOA));
  clSetq(CONS_38, clCons(keyFLAG_VARIABLE, CONS_39, clEOA));
  clSetq(CONS_37, clCons(keyOPERATIONS, CONS_38, clEOA));
  clSetq(CONS_36, clCons(keyINFINITY_DATA, CONS_37, clEOA));
  clSetq(CONS_43,
         clCons(clLOOP_MINIMAX_ANSWER_VARIABLE, clNIL, clEOA));
  clSetq(CONS_42, clCons(clSETF, CONS_43, clEOA));
  clSetq(CONS_45, clCons(clLOOP_MINIMAX_TYPE, clNIL, clEOA));
  clSetq(CONS_44, clCons(clSETF, CONS_45, clEOA));
  clSetq(CONS_47, clCons(clLOOP_MINIMAX_TEMP_VARIABLE, clNIL, clEOA));
  clSetq(CONS_46, clCons(clSETF, CONS_47, clEOA));
  clSetq(CONS_49, clCons(clLOOP_MINIMAX_FLAG_VARIABLE, clNIL, clEOA));
  clSetq(CONS_48, clCons(clSETF, CONS_49, clEOA));
  clSetq(CONS_51, clCons(clLOOP_MINIMAX_OPERATIONS, clNIL, clEOA));
  clSetq(CONS_50, clCons(clSETF, CONS_51, clEOA));
  clSetq(CONS_53, clCons(clLOOP_MINIMAX_INFINITY_DATA, clNIL, clEOA));
  clSetq(CONS_52, clCons(clSETF, CONS_53, clEOA));
  clSetq(CONS_57, clCons(clMOST_NEGATIVE_FIXNUM, clNIL, clEOA));
  clSetq(CONS_56, clCons(clMOST_POSITIVE_FIXNUM, CONS_57, clEOA));
  clSetq(CONS_55, clCons(clFIXNUM, CONS_56, clEOA));
  clSetq(CONS_54, clCons(CONS_55, clNIL, clEOA));
  clSetq(STR_TEST__11,
         clCharpSimpleBaseString("TEST"));
  clSetq(keyTEST, clMakeKeyword(STR_TEST__11, clEOA));
  clSetq(STR_DATUM__12,
         clCharpSimpleBaseString("DATUM"));
  clSetq(keyDATUM, clMakeKeyword(STR_DATUM__12, clEOA));
  clSetq(STR_EXPECTED_TYPE__13,
         clCharpSimpleBaseString("EXPECTED-TYPE"));
  clSetq(keyEXPECTED_TYPE,
         clMakeKeyword(STR_EXPECTED_TYPE__13, clEOA));
  clSetq(CONS_60, clCons(clMAX, clNIL, clEOA));
  clSetq(CONS_59, clCons(clMIN, CONS_60, clEOA));
  clSetq(CONS_58, clCons(clMEMBER, CONS_59, clEOA));
  clSetq(CONS_61, clCons(clT, clNIL, clEOA));
  clSetq(CONS_65, clCons(clMAKE_LOOP_UNIVERSE, clNIL, clEOA));
  clSetq(CONS_64, clCons(CONS_65, clNIL, clEOA));
  clSetq(CONS_74, clCons(clKEYWORDS, clNIL, clEOA));
  clSetq(CONS_73, clCons(keyNAME, CONS_74, clEOA));
  clSetq(CONS_77, clCons(clITERATION_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_76, clCons(keyNAME, CONS_77, clEOA));
  clSetq(CONS_80, clCons(clFOR_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_79, clCons(keyNAME, CONS_80, clEOA));
  clSetq(CONS_83, clCons(clPATH_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_82, clCons(keyNAME, CONS_83, clEOA));
  clSetq(CONS_86, clCons(clTYPE_SYMBOLS, clNIL, clEOA));
  clSetq(CONS_85, clCons(keyNAME, CONS_86, clEOA));
  clSetq(CONS_89, clCons(clTYPE_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_88, clCons(keyNAME, CONS_89, clEOA));
  clSetq(CONS_92, clCons(clANSI, clNIL, clEOA));
  clSetq(CONS_91, clCons(keyNAME, CONS_92, clEOA));
  clSetq(CONS_95, clCons(clIMPLICIT_FOR_REQUIRED, clNIL, clEOA));
  clSetq(CONS_94, clCons(keyNAME, CONS_95, clEOA));
  clSetq(CONS_93, clCons(CONS_94, clNIL, clEOA));
  clSetq(CONS_90, clCons(CONS_91, CONS_93, clEOA));
  clSetq(CONS_87, clCons(CONS_88, CONS_90, clEOA));
  clSetq(CONS_84, clCons(CONS_85, CONS_87, clEOA));
  clSetq(CONS_81, clCons(CONS_82, CONS_84, clEOA));
  clSetq(CONS_78, clCons(CONS_79, CONS_81, clEOA));
  clSetq(CONS_75, clCons(CONS_76, CONS_78, clEOA));
  clSetq(CONS_72, clCons(CONS_73, CONS_75, clEOA));
  clSetq(CONS_71, clCons(CONS_72, clNIL, clEOA));
  clSetq(CONS_70, clCons(keyDIRECT_SLOTS, CONS_71, clEOA));
  clSetq(CONS_69, clCons(clNIL, CONS_70, clEOA));
  clSetq(CONS_68, clCons(keyPREDICATE, CONS_69, clEOA));
  clSetq(CONS_67, clCons(clNIL, CONS_68, clEOA));
  clSetq(CONS_66, clCons(keyCOPIER, CONS_67, clEOA));
  clSetq(CONS_63, clCons(CONS_64, CONS_66, clEOA));
  clSetq(CONS_62, clCons(keyCONSTRUCTORS, CONS_63, clEOA));
  clSetq(STR_QUALIFIERS__14,
         clCharpSimpleBaseString("QUALIFIERS"));
  clSetq(keyQUALIFIERS, clMakeKeyword(STR_QUALIFIERS__14, clEOA));
  clSetq(STR_LAMBDA_LIST__15,
         clCharpSimpleBaseString("LAMBDA-LIST"));
  clSetq(keyLAMBDA_LIST, clMakeKeyword(STR_LAMBDA_LIST__15, clEOA));
  clSetq(STR_OBJECT2__16,
         clCharpSimpleBaseString("OBJECT2"));
  clSetq(SYM_0_OBJECT2, clMakeSymbol(STR_OBJECT2__16, clEOA));
  clSetq(STR_STREAM3__17,
         clCharpSimpleBaseString("STREAM3"));
  clSetq(SYM_0_STREAM3, clMakeSymbol(STR_STREAM3__17, clEOA));
  clSetq(CONS_97, clCons(SYM_0_STREAM3, clNIL, clEOA));
  clSetq(CONS_96, clCons(SYM_0_OBJECT2, CONS_97, clEOA));
  clSetq(STR_SPECIALIZERS__18,
         clCharpSimpleBaseString("SPECIALIZERS"));
  clSetq(keySPECIALIZERS, clMakeKeyword(STR_SPECIALIZERS__18, clEOA));
  clSetq(STR_FUNCTION__19,
         clCharpSimpleBaseString("FUNCTION"));
  clSetq(keyFUNCTION, clMakeKeyword(STR_FUNCTION__19, clEOA));
  clSetq(STR_DECLARATIONS__20,
         clCharpSimpleBaseString("DECLARATIONS"));
  clSetq(keyDECLARATIONS, clMakeKeyword(STR_DECLARATIONS__20, clEOA));
  clSetq(STR_DOCUMENTATION__21,
         clCharpSimpleBaseString("DOCUMENTATION"));
  clSetq(keyDOCUMENTATION,
         clMakeKeyword(STR_DOCUMENTATION__21, clEOA));
  clSetq(STR_KEYWORDS__22,
         clCharpSimpleBaseString("KEYWORDS"));
  clSetq(keyKEYWORDS, clMakeKeyword(STR_KEYWORDS__22, clEOA));
  clSetq(STR_ITERATION_KEYWORDS__23,
         clCharpSimpleBaseString("ITERATION-KEYWORDS"));
  clSetq(keyITERATION_KEYWORDS,
         clMakeKeyword(STR_ITERATION_KEYWORDS__23, clEOA));
  clSetq(STR_FOR_KEYWORDS__24,
         clCharpSimpleBaseString("FOR-KEYWORDS"));
  clSetq(keyFOR_KEYWORDS, clMakeKeyword(STR_FOR_KEYWORDS__24, clEOA));
  clSetq(STR_PATH_KEYWORDS__25,
         clCharpSimpleBaseString("PATH-KEYWORDS"));
  clSetq(keyPATH_KEYWORDS,
         clMakeKeyword(STR_PATH_KEYWORDS__25, clEOA));
  clSetq(STR_TYPE_SYMBOLS__26,
         clCharpSimpleBaseString("TYPE-SYMBOLS"));
  clSetq(keyTYPE_SYMBOLS, clMakeKeyword(STR_TYPE_SYMBOLS__26, clEOA));
  clSetq(STR_TYPE_KEYWORDS__27,
         clCharpSimpleBaseString("TYPE-KEYWORDS"));
  clSetq(keyTYPE_KEYWORDS,
         clMakeKeyword(STR_TYPE_KEYWORDS__27, clEOA));
  clSetq(STR_ANSI__28,
         clCharpSimpleBaseString("ANSI"));
  clSetq(keyANSI, clMakeKeyword(STR_ANSI__28, clEOA));
  clSetq(STRn_29,
         clCharpSimpleBaseString("IMPLICIT-FOR-REQUIRED"));
  clSetq(keyIMPLICIT_FOR_REQUIRED, clMakeKeyword(STRn_29, clEOA));
  clSetq(CONS_105, clCons(keyKEYWORDS, clNIL, clEOA));
  clSetq(CONS_104, clCons(keyITERATION_KEYWORDS, CONS_105, clEOA));
  clSetq(CONS_103, clCons(keyFOR_KEYWORDS, CONS_104, clEOA));
  clSetq(CONS_102, clCons(keyPATH_KEYWORDS, CONS_103, clEOA));
  clSetq(CONS_101, clCons(keyTYPE_SYMBOLS, CONS_102, clEOA));
  clSetq(CONS_100, clCons(keyTYPE_KEYWORDS, CONS_101, clEOA));
  clSetq(CONS_99, clCons(keyANSI, CONS_100, clEOA));
  clSetq(CONS_98, clCons(keyIMPLICIT_FOR_REQUIRED, CONS_99, clEOA));
  clSetq(CONS_107, clCons(clLOOP_UNIVERSE_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_106, clCons(clSETF, CONS_107, clEOA));
  clSetq(CONS_109,
         clCons(clLOOP_UNIVERSE_ITERATION_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_108, clCons(clSETF, CONS_109, clEOA));
  clSetq(CONS_111, clCons(clLOOP_UNIVERSE_FOR_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_110, clCons(clSETF, CONS_111, clEOA));
  clSetq(CONS_113,
         clCons(clLOOP_UNIVERSE_PATH_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_112, clCons(clSETF, CONS_113, clEOA));
  clSetq(CONS_115, clCons(clLOOP_UNIVERSE_TYPE_SYMBOLS, clNIL, clEOA));
  clSetq(CONS_114, clCons(clSETF, CONS_115, clEOA));
  clSetq(CONS_117,
         clCons(clLOOP_UNIVERSE_TYPE_KEYWORDS, clNIL, clEOA));
  clSetq(CONS_116, clCons(clSETF, CONS_117, clEOA));
  clSetq(I_6, clIntFixnum(6));
  clSetq(CONS_119, clCons(clLOOP_UNIVERSE_ANSI, clNIL, clEOA));
  clSetq(CONS_118, clCons(clSETF, CONS_119, clEOA));
  clSetq(I_7, clIntFixnum(7));
  clSetq(CONS_121,
         clCons(clLOOP_UNIVERSE_IMPLICIT_FOR_REQUIRED, clNIL, clEOA));
  clSetq(CONS_120, clCons(clSETF, CONS_121, clEOA));
  clSetq(STR_Non_ANSI__30,
         clCharpSimpleBaseString("Non-ANSI"));
  clSetq(STR_EXTENDED__31,
         clCharpSimpleBaseString("EXTENDED"));
  clSetq(keyEXTENDED, clMakeKeyword(STR_EXTENDED__31, clEOA));
  clSetq(STR_Extended_ANSI__32,
         clCharpSimpleBaseString("Extended-ANSI"));
  clSetq(STR_hashlesstildeS_tildeAgreater__33,
         clCharpSimpleBaseString("#<~S ~A>"));
  clSetq(CONS_127, clCons(keyFOR_KEYWORDS, CONS_105, clEOA));
  clSetq(CONS_126, clCons(keyITERATION_KEYWORDS, CONS_127, clEOA));
  clSetq(CONS_125, clCons(keyPATH_KEYWORDS, CONS_126, clEOA));
  clSetq(CONS_124, clCons(keyTYPE_KEYWORDS, CONS_125, clEOA));
  clSetq(CONS_123, clCons(keyTYPE_SYMBOLS, CONS_124, clEOA));
  clSetq(CONS_122, clCons(keyANSI, CONS_123, clEOA));
  clSetq(STR_SIZE__34,
         clCharpSimpleBaseString("SIZE"));
  clSetq(keySIZE, clMakeKeyword(STR_SIZE__34, clEOA));
  clSetq(I_10, clIntFixnum(10));
  clSetq(CONS_129, clCons(clGETHASH, clNIL, clEOA));
  clSetq(CONS_128, clCons(clSETF, CONS_129, clEOA));
  clSetq(STR_LOOP_DESETQ_TEMP__35,
         clCharpSimpleBaseString("LOOP-DESETQ-TEMP"));
  clSetq(STRn_36,
         clCharpSimpleBaseString("The form ~S evaluated to ~S, which was not of the anticipated type ~S."));
  clSetq(STR_LOOP_NOT_FIRST_TIME__37,
         clCharpSimpleBaseString("LOOP-NOT-FIRST-TIME"));
  clSetq(I_40, clIntFixnum(40));
  clSetq(STRn_38,
         clCharpSimpleBaseString("LOOP-BODY called with non-synched before- and after-loop lists."));
  clSetq(CONS_132, clCons(clRETURN_FROM, clNIL, clEOA));
  clSetq(CONS_131, clCons(clRETURN, CONS_132, clEOA));
  clSetq(CONS_130, clCons(clGO, CONS_131, clEOA));
  clSetq(CONS_135, clCons(clNEXT_LOOP, clNIL, clEOA));
  clSetq(CONS_134, clCons(clGO, CONS_135, clEOA));
  clSetq(CONS_133, clCons(CONS_134, clNIL, clEOA));
  clSetq(CONS_138, clCons(I_0, clNIL, clEOA));
  clSetq(CONS_137, clCons(clRETURN, CONS_138, clEOA));
  clSetq(CONS_140, clCons(clPROGN, CONS_138, clEOA));
  clSetq(CONS_143, clCons(I_1, clNIL, clEOA));
  clSetq(CONS_142, clCons(clNULL, CONS_143, clEOA));
  clSetq(CONS_145, clCons(clNOT, CONS_143, clEOA));
  clSetq(CONS_147, clCons(clEQ, CONS_143, clEOA));
  clSetq(CONS_149, clCons(clCAR, CONS_143, clEOA));
  clSetq(CONS_151, clCons(clCDR, CONS_143, clEOA));
  clSetq(CONS_153, clCons(clWHEN, CONS_143, clEOA));
  clSetq(CONS_155, clCons(clUNLESS, CONS_143, clEOA));
  clSetq(CONS_157, clCons(clIF, CONS_143, clEOA));
  clSetq(CONS_160, clCons(I_2, clNIL, clEOA));
  clSetq(CONS_159, clCons(clCAAR, CONS_160, clEOA));
  clSetq(CONS_162, clCons(clCADR, CONS_160, clEOA));
  clSetq(CONS_164, clCons(clCDAR, CONS_160, clEOA));
  clSetq(CONS_166, clCons(clCDDR, CONS_160, clEOA));
  clSetq(CONS_169, clCons(I_3, clNIL, clEOA));
  clSetq(CONS_168, clCons(clCAAAR, CONS_169, clEOA));
  clSetq(CONS_171, clCons(clCAADR, CONS_169, clEOA));
  clSetq(CONS_173, clCons(clCADAR, CONS_169, clEOA));
  clSetq(CONS_175, clCons(clCADDR, CONS_169, clEOA));
  clSetq(CONS_177, clCons(clCDAAR, CONS_169, clEOA));
  clSetq(CONS_179, clCons(clCDADR, CONS_169, clEOA));
  clSetq(CONS_181, clCons(clCDDAR, CONS_169, clEOA));
  clSetq(CONS_183, clCons(clCDDDR, CONS_169, clEOA));
  clSetq(CONS_186, clCons(I_4, clNIL, clEOA));
  clSetq(CONS_185, clCons(clCAAAAR, CONS_186, clEOA));
  clSetq(CONS_188, clCons(clCAAADR, CONS_186, clEOA));
  clSetq(CONS_190, clCons(clCAADAR, CONS_186, clEOA));
  clSetq(CONS_192, clCons(clCAADDR, CONS_186, clEOA));
  clSetq(CONS_194, clCons(clCADAAR, CONS_186, clEOA));
  clSetq(CONS_196, clCons(clCADADR, CONS_186, clEOA));
  clSetq(CONS_198, clCons(clCADDAR, CONS_186, clEOA));
  clSetq(CONS_200, clCons(clCADDDR, CONS_186, clEOA));
  clSetq(CONS_202, clCons(clCDAAAR, CONS_186, clEOA));
  clSetq(CONS_204, clCons(clCDAADR, CONS_186, clEOA));
  clSetq(CONS_206, clCons(clCDADAR, CONS_186, clEOA));
  clSetq(CONS_208, clCons(clCDADDR, CONS_186, clEOA));
  clSetq(CONS_210, clCons(clCDDAAR, CONS_186, clEOA));
  clSetq(CONS_212, clCons(clCDDADR, CONS_186, clEOA));
  clSetq(CONS_214, clCons(clCDDDAR, CONS_186, clEOA));
  clSetq(CONS_216, clCons(clCDDDDR, CONS_186, clEOA));
  clSetq(CONS_215, clCons(CONS_216, clNIL, clEOA));
  clSetq(CONS_213, clCons(CONS_214, CONS_215, clEOA));
  clSetq(CONS_211, clCons(CONS_212, CONS_213, clEOA));
  clSetq(CONS_209, clCons(CONS_210, CONS_211, clEOA));
  clSetq(CONS_207, clCons(CONS_208, CONS_209, clEOA));
  clSetq(CONS_205, clCons(CONS_206, CONS_207, clEOA));
  clSetq(CONS_203, clCons(CONS_204, CONS_205, clEOA));
  clSetq(CONS_201, clCons(CONS_202, CONS_203, clEOA));
  clSetq(CONS_199, clCons(CONS_200, CONS_201, clEOA));
  clSetq(CONS_197, clCons(CONS_198, CONS_199, clEOA));
  clSetq(CONS_195, clCons(CONS_196, CONS_197, clEOA));
  clSetq(CONS_193, clCons(CONS_194, CONS_195, clEOA));
  clSetq(CONS_191, clCons(CONS_192, CONS_193, clEOA));
  clSetq(CONS_189, clCons(CONS_190, CONS_191, clEOA));
  clSetq(CONS_187, clCons(CONS_188, CONS_189, clEOA));
  clSetq(CONS_184, clCons(CONS_185, CONS_187, clEOA));
  clSetq(CONS_182, clCons(CONS_183, CONS_184, clEOA));
  clSetq(CONS_180, clCons(CONS_181, CONS_182, clEOA));
  clSetq(CONS_178, clCons(CONS_179, CONS_180, clEOA));
  clSetq(CONS_176, clCons(CONS_177, CONS_178, clEOA));
  clSetq(CONS_174, clCons(CONS_175, CONS_176, clEOA));
  clSetq(CONS_172, clCons(CONS_173, CONS_174, clEOA));
  clSetq(CONS_170, clCons(CONS_171, CONS_172, clEOA));
  clSetq(CONS_167, clCons(CONS_168, CONS_170, clEOA));
  clSetq(CONS_165, clCons(CONS_166, CONS_167, clEOA));
  clSetq(CONS_163, clCons(CONS_164, CONS_165, clEOA));
  clSetq(CONS_161, clCons(CONS_162, CONS_163, clEOA));
  clSetq(CONS_158, clCons(CONS_159, CONS_161, clEOA));
  clSetq(CONS_156, clCons(CONS_157, CONS_158, clEOA));
  clSetq(CONS_154, clCons(CONS_155, CONS_156, clEOA));
  clSetq(CONS_152, clCons(CONS_153, CONS_154, clEOA));
  clSetq(CONS_150, clCons(CONS_151, CONS_152, clEOA));
  clSetq(CONS_148, clCons(CONS_149, CONS_150, clEOA));
  clSetq(CONS_146, clCons(CONS_147, CONS_148, clEOA));
  clSetq(CONS_144, clCons(CONS_145, CONS_146, clEOA));
  clSetq(CONS_141, clCons(CONS_142, CONS_144, clEOA));
  clSetq(CONS_139, clCons(CONS_140, CONS_141, clEOA));
  clSetq(CONS_136, clCons(CONS_137, CONS_139, clEOA));
  clSetq(CONS_234, clCons(clWITH_OPEN_FILE, clNIL, clEOA));
  clSetq(CONS_233, clCons(clUNWIND_PROTECT, CONS_234, clEOA));
  clSetq(CONS_232, clCons(clTAGBODY, CONS_233, clEOA));
  clSetq(CONS_231, clCons(clSYMBOL_MACROLET, CONS_232, clEOA));
  clSetq(CONS_230, clCons(clPROGstar, CONS_231, clEOA));
  clSetq(CONS_229, clCons(clPROG, CONS_230, clEOA));
  clSetq(CONS_228, clCons(clMULTIPLE_VALUE_BIND, CONS_229, clEOA));
  clSetq(CONS_227, clCons(clMACROLET, CONS_228, clEOA));
  clSetq(CONS_226, clCons(clLOCALLY, CONS_227, clEOA));
  clSetq(CONS_225, clCons(clLETstar, CONS_226, clEOA));
  clSetq(CONS_224, clCons(clLET, CONS_225, clEOA));
  clSetq(CONS_223, clCons(clLAMBDA, CONS_224, clEOA));
  clSetq(CONS_222, clCons(clLABELS, CONS_223, clEOA));
  clSetq(CONS_221, clCons(clFLET, CONS_222, clEOA));
  clSetq(CONS_220, clCons(clDOLIST, CONS_221, clEOA));
  clSetq(CONS_219, clCons(clDOstar, CONS_220, clEOA));
  clSetq(CONS_218, clCons(clDO, CONS_219, clEOA));
  clSetq(CONS_217, clCons(clBLOCK, CONS_218, clEOA));
  clSetq(CONS_236, clCons(clPSETQ, clNIL, clEOA));
  clSetq(CONS_235, clCons(clSETQ, CONS_236, clEOA));
  clSetq(STRn_39,
         clCharpSimpleBaseString("~?~%Current LOOP context:~{ ~S~}."));
  clSetq(STRn_40,
         clCharpSimpleBaseString("LOOP couldn\'t verify that ~S is a subtype of the required type ~S."));
  clSetq(STRn_41,
         clCharpSimpleBaseString("Specified data type ~S is not a subtype of ~S."));
  clSetq(CONS_238, clCons(clEND_LOOP, clNIL, clEOA));
  clSetq(CONS_237, clCons(clGO, CONS_238, clEOA));
  clSetq(STRn_42,
         clCharpSimpleBaseString("~S found where LOOP keyword expected."));
  clSetq(CONS_240, clCons(clELSE, clNIL, clEOA));
  clSetq(CONS_239, clCons(clAND, CONS_240, clEOA));
  clSetq(STRn_43,
         clCharpSimpleBaseString("Secondary clause misplaced at top level in LOOP macro: ~S ~S ~S ..."));
  clSetq(STRn_44,
         clCharpSimpleBaseString("~S is an unknown keyword in LOOP macro."));
  clSetq(STRn_45,
         clCharpSimpleBaseString("LOOP source code ran out when another token was expected."));
  clSetq(STRn_46,
         clCharpSimpleBaseString("LOOP code ran out where a form was expected."));
  clSetq(STRn_47,
         clCharpSimpleBaseString("LOOP clause is providing a value for the iteration,~@\n\t        however one was already established by a ~S clause."));
  clSetq(STRn_48,
         clCharpSimpleBaseString("~:[This LOOP~;The LOOP ~:*~S~] clause is not permitted inside a conditional."));
  clSetq(CONS_242, clCons(clFLOAT, clNIL, clEOA));
  clSetq(CONS_241, clCons(clCOMPLEX, CONS_242, clEOA));
  clSetq(C_Null, clIntCharacter('\0'));
  clSetq(A_49, clMakeGeneralVector(I_0));
  clSetq(STRn_49,
         clCharpSimpleBaseString("~S found where a LOOP keyword, LOOP type keyword, or LOOP type pattern expected."));
  clSetq(STRn_50,
         clCharpSimpleBaseString("~S found where a LOOP keyword or LOOP type keyword expected."));
  clSetq(STRn_51,
         clCharpSimpleBaseString("Destructuring type pattern ~S contains unrecognized type keyword ~S."));
  clSetq(STRn_52,
         clCharpSimpleBaseString("Destructuring type pattern ~S doesn\'t match variable pattern ~S."));
  clSetq(STRn_53,
         clCharpSimpleBaseString("Duplicated LOOP iteration variable ~S."));
  clSetq(STRn_54,
         clCharpSimpleBaseString("Duplicated variable ~S in LOOP parallel binding."));
  clSetq(STRn_55,
         clCharpSimpleBaseString("Bad variable ~S somewhere in LOOP."));
  clSetq(STRn_56,
         clCharpSimpleBaseString("Invalid LOOP variable passed in: ~S."));
  clSetq(STRn_57,
         clCharpSimpleBaseString("~S found where keyword expected getting LOOP clause after ~S."));
  clSetq(STRn_58,
         clCharpSimpleBaseString("~S does not introduce a LOOP clause that can follow ~S."));
  clSetq(STR_AND__59,
         clCharpSimpleBaseString("AND"));
  clSetq(keyAND, clMakeKeyword(STR_AND__59, clEOA));
  clSetq(STR_ELSE__60,
         clCharpSimpleBaseString("ELSE"));
  clSetq(keyELSE, clMakeKeyword(STR_ELSE__60, clEOA));
  clSetq(STR_END__61,
         clCharpSimpleBaseString("END"));
  clSetq(keyEND, clMakeKeyword(STR_END__61, clEOA));
  clSetq(STR_INITIALLY__62,
         clCharpSimpleBaseString("INITIALLY"));
  clSetq(keyINITIALLY, clMakeKeyword(STR_INITIALLY__62, clEOA));
  clSetq(STR_FINALLY__63,
         clCharpSimpleBaseString("FINALLY"));
  clSetq(keyFINALLY, clMakeKeyword(STR_FINALLY__63, clEOA));
  clSetq(STRn_64,
         clCharpSimpleBaseString("~S is an invalid name for your LOOP."));
  clSetq(STRn_65,
         clCharpSimpleBaseString("The NAMED ~S clause occurs too late."));
  clSetq(STRn_66,
         clCharpSimpleBaseString("You may only use one NAMED clause in your loop: NAMED ~S ... NAMED ~S."));
  clSetq(CONS_246, clCons(clMAKE_LOOP_COLLECTOR, clNIL, clEOA));
  clSetq(CONS_245, clCons(CONS_246, clNIL, clEOA));
  clSetq(CONS_255, clCons(clNAME, clNIL, clEOA));
  clSetq(CONS_254, clCons(keyNAME, CONS_255, clEOA));
  clSetq(CONS_258, clCons(clCLASS, clNIL, clEOA));
  clSetq(CONS_257, clCons(keyNAME, CONS_258, clEOA));
  clSetq(STR_INITFORM__67,
         clCharpSimpleBaseString("INITFORM"));
  clSetq(keyINITFORM, clMakeKeyword(STR_INITFORM__67, clEOA));
  clSetq(STR_READ_ONLY__68,
         clCharpSimpleBaseString("READ-ONLY"));
  clSetq(keyREAD_ONLY, clMakeKeyword(STR_READ_ONLY__68, clEOA));
  clSetq(CONS_266, clCons(keyREAD_ONLY, CONS_2, clEOA));
  clSetq(CONS_265, clCons(clT, CONS_266, clEOA));
  clSetq(CONS_264, clCons(keyTYPE, CONS_265, clEOA));
  clSetq(CONS_263, clCons(clNIL, CONS_264, clEOA));
  clSetq(CONS_262, clCons(keyINITFORM, CONS_263, clEOA));
  clSetq(CONS_261, clCons(clHISTORY, CONS_262, clEOA));
  clSetq(CONS_260, clCons(keyNAME, CONS_261, clEOA));
  clSetq(CONS_269, clCons(clTEMPVARS, CONS_262, clEOA));
  clSetq(CONS_268, clCons(keyNAME, CONS_269, clEOA));
  clSetq(CONS_272, clCons(clDTYPE, clNIL, clEOA));
  clSetq(CONS_271, clCons(keyNAME, CONS_272, clEOA));
  clSetq(CONS_275, clCons(clDATA, CONS_262, clEOA));
  clSetq(CONS_274, clCons(keyNAME, CONS_275, clEOA));
  clSetq(CONS_273, clCons(CONS_274, clNIL, clEOA));
  clSetq(CONS_270, clCons(CONS_271, CONS_273, clEOA));
  clSetq(CONS_267, clCons(CONS_268, CONS_270, clEOA));
  clSetq(CONS_259, clCons(CONS_260, CONS_267, clEOA));
  clSetq(CONS_256, clCons(CONS_257, CONS_259, clEOA));
  clSetq(CONS_253, clCons(CONS_254, CONS_256, clEOA));
  clSetq(CONS_252, clCons(CONS_253, clNIL, clEOA));
  clSetq(CONS_251, clCons(keyDIRECT_SLOTS, CONS_252, clEOA));
  clSetq(CONS_250, clCons(clNIL, CONS_251, clEOA));
  clSetq(CONS_249, clCons(keyPREDICATE, CONS_250, clEOA));
  clSetq(CONS_248, clCons(clNIL, CONS_249, clEOA));
  clSetq(CONS_247, clCons(keyCOPIER, CONS_248, clEOA));
  clSetq(CONS_244, clCons(CONS_245, CONS_247, clEOA));
  clSetq(CONS_243, clCons(keyCONSTRUCTORS, CONS_244, clEOA));
  clSetq(STR_CLASS__69,
         clCharpSimpleBaseString("CLASS"));
  clSetq(keyCLASS, clMakeKeyword(STR_CLASS__69, clEOA));
  clSetq(STR_HISTORY__70,
         clCharpSimpleBaseString("HISTORY"));
  clSetq(keyHISTORY, clMakeKeyword(STR_HISTORY__70, clEOA));
  clSetq(STR_TEMPVARS__71,
         clCharpSimpleBaseString("TEMPVARS"));
  clSetq(keyTEMPVARS, clMakeKeyword(STR_TEMPVARS__71, clEOA));
  clSetq(STR_DTYPE__72,
         clCharpSimpleBaseString("DTYPE"));
  clSetq(keyDTYPE, clMakeKeyword(STR_DTYPE__72, clEOA));
  clSetq(STR_DATA__73,
         clCharpSimpleBaseString("DATA"));
  clSetq(keyDATA, clMakeKeyword(STR_DATA__73, clEOA));
  clSetq(CONS_281, clCons(keyNAME, clNIL, clEOA));
  clSetq(CONS_280, clCons(keyCLASS, CONS_281, clEOA));
  clSetq(CONS_279, clCons(keyHISTORY, CONS_280, clEOA));
  clSetq(CONS_278, clCons(keyTEMPVARS, CONS_279, clEOA));
  clSetq(CONS_277, clCons(keyDTYPE, CONS_278, clEOA));
  clSetq(CONS_276, clCons(keyDATA, CONS_277, clEOA));
  clSetq(CONS_283, clCons(clLOOP_COLLECTOR_NAME, clNIL, clEOA));
  clSetq(CONS_282, clCons(clSETF, CONS_283, clEOA));
  clSetq(CONS_285, clCons(clLOOP_COLLECTOR_CLASS, clNIL, clEOA));
  clSetq(CONS_284, clCons(clSETF, CONS_285, clEOA));
  clSetq(CONS_287, clCons(clLOOP_COLLECTOR_HISTORY, clNIL, clEOA));
  clSetq(CONS_286, clCons(clSETF, CONS_287, clEOA));
  clSetq(CONS_289, clCons(clLOOP_COLLECTOR_TEMPVARS, clNIL, clEOA));
  clSetq(CONS_288, clCons(clSETF, CONS_289, clEOA));
  clSetq(CONS_291, clCons(clLOOP_COLLECTOR_DTYPE, clNIL, clEOA));
  clSetq(CONS_290, clCons(clSETF, CONS_291, clEOA));
  clSetq(CONS_293, clCons(clLOOP_COLLECTOR_DATA, clNIL, clEOA));
  clSetq(CONS_292, clCons(clSETF, CONS_293, clEOA));
  clSetq(STRn_74,
         clCharpSimpleBaseString("Value accumulation recipient name, ~S, is not a symbol."));
  clSetq(STR_KEY__75,
         clCharpSimpleBaseString("KEY"));
  clSetq(keyKEY, clMakeKeyword(STR_KEY__75, clEOA));
  clSetq(STRn_76,
         clCharpSimpleBaseString("Incompatible kinds of LOOP value accumulation specified for collecting~@\n\t\t    ~:[as the value of the LOOP~;~:*INTO ~S~]: ~S and ~S."));
  clSetq(STRn_77,
         clCharpSimpleBaseString("Unequal datatypes specified in different LOOP value accumulations~@\n\t\t   into ~S: ~S and ~S."));
  clSetq(CONS_297, clCons(clAPPEND, clNIL, clEOA));
  clSetq(CONS_296, clCons(clNCONC, CONS_297, clEOA));
  clSetq(CONS_295, clCons(clLIST, CONS_296, clEOA));
  clSetq(CONS_294, clCons(clMEMBER, CONS_295, clEOA));
  clSetq(CONS_298, clCons(CONS_237, clNIL, clEOA));
  clSetq(STR_WITH__78,
         clCharpSimpleBaseString("WITH"));
  clSetq(keyWITH, clMakeKeyword(STR_WITH__78, clEOA));
  clSetq(STR_equal__79,
         clCharpSimpleBaseString("="));
  clSetq(keyequalsymbol, clMakeKeyword(STR_equal__79, clEOA));
  clSetq(STRn_80,
         clCharpSimpleBaseString("Iteration in LOOP follows body code."));
  clSetq(STRn_81,
         clCharpSimpleBaseString("~S is an unknown keyword in FOR or AS clause in LOOP."));
  clSetq(CONS_300, clCons(clNIL, CONS_2, clEOA));
  clSetq(CONS_299, clCons(clNIL, CONS_300, clEOA));
  clSetq(CONS_304, clCons(clNIL, CONS_299, clEOA));
  clSetq(CONS_303, clCons(clNIL, CONS_304, clEOA));
  clSetq(CONS_302, clCons(clNIL, CONS_303, clEOA));
  clSetq(CONS_301, clCons(clNIL, CONS_302, clEOA));
  clSetq(STR_THEN__82,
         clCharpSimpleBaseString("THEN"));
  clSetq(keyTHEN, clMakeKeyword(STR_THEN__82, clEOA));
  clSetq(STR_BY__83,
         clCharpSimpleBaseString("BY"));
  clSetq(keyBY, clMakeKeyword(STR_BY__83, clEOA));
  clSetq(CONS_306, clCons(clCDR, clNIL, clEOA));
  clSetq(CONS_305, clCons(clFUNCTION, CONS_306, clEOA));
  clSetq(STRn_84,
         clCharpSimpleBaseString("Use of QUOTE around stepping function in LOOP will be left verbatim."));
  clSetq(CONS_310, clCons(clMAKE_LOOP_PATH, clNIL, clEOA));
  clSetq(CONS_309, clCons(CONS_310, clNIL, clEOA));
  clSetq(CONS_319, clCons(clNAMES, clNIL, clEOA));
  clSetq(CONS_318, clCons(keyNAME, CONS_319, clEOA));
  clSetq(CONS_322, clCons(clPREPOSITION_GROUPS, clNIL, clEOA));
  clSetq(CONS_321, clCons(keyNAME, CONS_322, clEOA));
  clSetq(CONS_325, clCons(clINCLUSIVE_PERMITTED, clNIL, clEOA));
  clSetq(CONS_324, clCons(keyNAME, CONS_325, clEOA));
  clSetq(CONS_328, clCons(clFUNCTION, clNIL, clEOA));
  clSetq(CONS_327, clCons(keyNAME, CONS_328, clEOA));
  clSetq(CONS_331, clCons(clUSER_DATA, clNIL, clEOA));
  clSetq(CONS_330, clCons(keyNAME, CONS_331, clEOA));
  clSetq(CONS_329, clCons(CONS_330, clNIL, clEOA));
  clSetq(CONS_326, clCons(CONS_327, CONS_329, clEOA));
  clSetq(CONS_323, clCons(CONS_324, CONS_326, clEOA));
  clSetq(CONS_320, clCons(CONS_321, CONS_323, clEOA));
  clSetq(CONS_317, clCons(CONS_318, CONS_320, clEOA));
  clSetq(CONS_316, clCons(CONS_317, clNIL, clEOA));
  clSetq(CONS_315, clCons(keyDIRECT_SLOTS, CONS_316, clEOA));
  clSetq(CONS_314, clCons(clNIL, CONS_315, clEOA));
  clSetq(CONS_313, clCons(keyPREDICATE, CONS_314, clEOA));
  clSetq(CONS_312, clCons(clNIL, CONS_313, clEOA));
  clSetq(CONS_311, clCons(keyCOPIER, CONS_312, clEOA));
  clSetq(CONS_308, clCons(CONS_309, CONS_311, clEOA));
  clSetq(CONS_307, clCons(keyCONSTRUCTORS, CONS_308, clEOA));
  clSetq(STR_NAMES__85,
         clCharpSimpleBaseString("NAMES"));
  clSetq(keyNAMES, clMakeKeyword(STR_NAMES__85, clEOA));
  clSetq(STR_PREPOSITION_GROUPS__86,
         clCharpSimpleBaseString("PREPOSITION-GROUPS"));
  clSetq(keyPREPOSITION_GROUPS,
         clMakeKeyword(STR_PREPOSITION_GROUPS__86, clEOA));
  clSetq(STR_INCLUSIVE_PERMITTED__87,
         clCharpSimpleBaseString("INCLUSIVE-PERMITTED"));
  clSetq(keyINCLUSIVE_PERMITTED,
         clMakeKeyword(STR_INCLUSIVE_PERMITTED__87, clEOA));
  clSetq(STR_USER_DATA__88,
         clCharpSimpleBaseString("USER-DATA"));
  clSetq(keyUSER_DATA, clMakeKeyword(STR_USER_DATA__88, clEOA));
  clSetq(CONS_336, clCons(keyNAMES, clNIL, clEOA));
  clSetq(CONS_335, clCons(keyPREPOSITION_GROUPS, CONS_336, clEOA));
  clSetq(CONS_334, clCons(keyINCLUSIVE_PERMITTED, CONS_335, clEOA));
  clSetq(CONS_333, clCons(keyFUNCTION, CONS_334, clEOA));
  clSetq(CONS_332, clCons(keyUSER_DATA, CONS_333, clEOA));
  clSetq(CONS_338, clCons(clLOOP_PATH_NAMES, clNIL, clEOA));
  clSetq(CONS_337, clCons(clSETF, CONS_338, clEOA));
  clSetq(CONS_340,
         clCons(clLOOP_PATH_PREPOSITION_GROUPS, clNIL, clEOA));
  clSetq(CONS_339, clCons(clSETF, CONS_340, clEOA));
  clSetq(CONS_342,
         clCons(clLOOP_PATH_INCLUSIVE_PERMITTED, clNIL, clEOA));
  clSetq(CONS_341, clCons(clSETF, CONS_342, clEOA));
  clSetq(CONS_344, clCons(clLOOP_PATH_FUNCTION, clNIL, clEOA));
  clSetq(CONS_343, clCons(clSETF, CONS_344, clEOA));
  clSetq(CONS_346, clCons(clLOOP_PATH_USER_DATA, clNIL, clEOA));
  clSetq(CONS_345, clCons(clSETF, CONS_346, clEOA));
  clSetq(CONS_349, clCons(keyPREPOSITION_GROUPS, clNIL, clEOA));
  clSetq(CONS_348, clCons(keyINCLUSIVE_PERMITTED, CONS_349, clEOA));
  clSetq(CONS_347, clCons(keyUSER_DATA, CONS_348, clEOA));
  clSetq(STR_EACH__89,
         clCharpSimpleBaseString("EACH"));
  clSetq(keyEACH, clMakeKeyword(STR_EACH__89, clEOA));
  clSetq(STR_THE__90,
         clCharpSimpleBaseString("THE"));
  clSetq(keyTHE, clMakeKeyword(STR_THE__90, clEOA));
  clSetq(CONS_351, clCons(keyTHE, clNIL, clEOA));
  clSetq(CONS_350, clCons(keyEACH, CONS_351, clEOA));
  clSetq(STR_ITS__91,
         clCharpSimpleBaseString("ITS"));
  clSetq(keyITS, clMakeKeyword(STR_ITS__91, clEOA));
  clSetq(STR_HIS__92,
         clCharpSimpleBaseString("HIS"));
  clSetq(keyHIS, clMakeKeyword(STR_HIS__92, clEOA));
  clSetq(STR_HER__93,
         clCharpSimpleBaseString("HER"));
  clSetq(keyHER, clMakeKeyword(STR_HER__93, clEOA));
  clSetq(CONS_355, clCons(keyHER, clNIL, clEOA));
  clSetq(CONS_354, clCons(keyHIS, CONS_355, clEOA));
  clSetq(CONS_353, clCons(keyEACH, CONS_354, clEOA));
  clSetq(CONS_352, clCons(keyITS, CONS_353, clEOA));
  clSetq(STRn_94,
         clCharpSimpleBaseString("~S found where ITS or EACH expected in LOOP iteration path syntax."));
  clSetq(STR_IN__95,
         clCharpSimpleBaseString("IN"));
  clSetq(keyIN, clMakeKeyword(STR_IN__95, clEOA));
  clSetq(STRn_96,
         clCharpSimpleBaseString("Unrecognizable LOOP iteration path syntax.  Missing EACH or THE?"));
  clSetq(STRn_97,
         clCharpSimpleBaseString("~S found where a LOOP iteration path name was expected."));
  clSetq(STRn_98,
         clCharpSimpleBaseString("~S is not the name of a LOOP iteration path."));
  clSetq(STRn_99,
         clCharpSimpleBaseString("\"Inclusive\" iteration is not possible with the ~S LOOP iteration path."));
  clSetq(STR_INCLUSIVE__100,
         clCharpSimpleBaseString("INCLUSIVE"));
  clSetq(keyINCLUSIVE, clMakeKeyword(STR_INCLUSIVE__100, clEOA));
  clSetq(STRn_101,
         clCharpSimpleBaseString("Unused USING variables: ~S."));
  clSetq(CONS_357, clCons(I_10, clNIL, clEOA));
  clSetq(CONS_356, clCons(I_6, CONS_357, clEOA));
  clSetq(STRn_102,
         clCharpSimpleBaseString("Value passed back by LOOP iteration path function for path ~S has invalid length."));
  clSetq(STRn_103,
         clCharpSimpleBaseString("A ~S prepositional phrase occurs multiply for some LOOP clause."));
  clSetq(STRn_104,
         clCharpSimpleBaseString("Preposition ~S used when some other preposition has subsumed it."));
  clSetq(STRn_105,
         clCharpSimpleBaseString("~S bad variable pair in path USING phrase."));
  clSetq(STRn_106,
         clCharpSimpleBaseString("The variable substitution for ~S occurs twice in a USING phrase,~@\n\t\t        with ~S and ~S."));
  clSetq(I_8, clIntFixnum(8));
  clSetq(I_9, clIntFixnum(9));
  clSetq(STR_OF__107,
         clCharpSimpleBaseString("OF"));
  clSetq(keyOF, clMakeKeyword(STR_OF__107, clEOA));
  clSetq(CONS_359, clCons(keyIN, clNIL, clEOA));
  clSetq(CONS_358, clCons(keyOF, CONS_359, clEOA));
  clSetq(STR_FROM__108,
         clCharpSimpleBaseString("FROM"));
  clSetq(keyFROM, clMakeKeyword(STR_FROM__108, clEOA));
  clSetq(STR_DOWNFROM__109,
         clCharpSimpleBaseString("DOWNFROM"));
  clSetq(keyDOWNFROM, clMakeKeyword(STR_DOWNFROM__109, clEOA));
  clSetq(STR_UPFROM__110,
         clCharpSimpleBaseString("UPFROM"));
  clSetq(keyUPFROM, clMakeKeyword(STR_UPFROM__110, clEOA));
  clSetq(CONS_362, clCons(keyUPFROM, clNIL, clEOA));
  clSetq(CONS_361, clCons(keyDOWNFROM, CONS_362, clEOA));
  clSetq(CONS_360, clCons(keyFROM, CONS_361, clEOA));
  clSetq(STR_DOWN__111,
         clCharpSimpleBaseString("DOWN"));
  clSetq(keyDOWN, clMakeKeyword(STR_DOWN__111, clEOA));
  clSetq(STR_UP__112,
         clCharpSimpleBaseString("UP"));
  clSetq(keyUP, clMakeKeyword(STR_UP__112, clEOA));
  clSetq(STR_UPTO__113,
         clCharpSimpleBaseString("UPTO"));
  clSetq(keyUPTO, clMakeKeyword(STR_UPTO__113, clEOA));
  clSetq(STR_TO__114,
         clCharpSimpleBaseString("TO"));
  clSetq(keyTO, clMakeKeyword(STR_TO__114, clEOA));
  clSetq(STR_DOWNTO__115,
         clCharpSimpleBaseString("DOWNTO"));
  clSetq(keyDOWNTO, clMakeKeyword(STR_DOWNTO__115, clEOA));
  clSetq(STR_ABOVE__116,
         clCharpSimpleBaseString("ABOVE"));
  clSetq(keyABOVE, clMakeKeyword(STR_ABOVE__116, clEOA));
  clSetq(STR_BELOW__117,
         clCharpSimpleBaseString("BELOW"));
  clSetq(keyBELOW, clMakeKeyword(STR_BELOW__117, clEOA));
  clSetq(CONS_367, clCons(keyBELOW, clNIL, clEOA));
  clSetq(CONS_366, clCons(keyABOVE, CONS_367, clEOA));
  clSetq(CONS_365, clCons(keyDOWNTO, CONS_366, clEOA));
  clSetq(CONS_364, clCons(keyTO, CONS_365, clEOA));
  clSetq(CONS_363, clCons(keyUPTO, CONS_364, clEOA));
  clSetq(STRn_118,
         clCharpSimpleBaseString("~S invalid preposition in sequencing or sequence path.~@\n\t       Invalid prepositions specified in iteration path descriptor or something?"));
  clSetq(STRn_119,
         clCharpSimpleBaseString("Conflicting stepping directions in LOOP sequencing path"));
  clSetq(STRn_120,
         clCharpSimpleBaseString("Missing OF or IN phrase in sequence path"));
  clSetq(CONS_369, clCons(keyUP, clNIL, clEOA));
  clSetq(CONS_368, clCons(clNIL, CONS_369, clEOA));
  clSetq(STRn_121,
         clCharpSimpleBaseString("Don\'t know where to start stepping."));
  clSetq(CONS_373, clCons(keyDOWNFROM, clNIL, clEOA));
  clSetq(CONS_372, clCons(keyUPFROM, CONS_373, clEOA));
  clSetq(CONS_371, clCons(keyFROM, CONS_372, clEOA));
  clSetq(CONS_376, clCons(keyUPTO, CONS_365, clEOA));
  clSetq(CONS_375, clCons(keyTO, CONS_376, clEOA));
  clSetq(CONS_378, clCons(keyBY, clNIL, clEOA));
  clSetq(CONS_377, clCons(CONS_378, clNIL, clEOA));
  clSetq(CONS_374, clCons(CONS_375, CONS_377, clEOA));
  clSetq(CONS_370, clCons(CONS_371, CONS_374, clEOA));
  clSetq(STR_FETCH_FUNCTION__122,
         clCharpSimpleBaseString("FETCH-FUNCTION"));
  clSetq(keyFETCH_FUNCTION,
         clMakeKeyword(STR_FETCH_FUNCTION__122, clEOA));
  clSetq(STR_SIZE_FUNCTION__123,
         clCharpSimpleBaseString("SIZE-FUNCTION"));
  clSetq(keySIZE_FUNCTION,
         clMakeKeyword(STR_SIZE_FUNCTION__123, clEOA));
  clSetq(STR_SEQUENCE_TYPE__124,
         clCharpSimpleBaseString("SEQUENCE-TYPE"));
  clSetq(keySEQUENCE_TYPE,
         clMakeKeyword(STR_SEQUENCE_TYPE__124, clEOA));
  clSetq(STR_ELEMENT_TYPE__125,
         clCharpSimpleBaseString("ELEMENT-TYPE"));
  clSetq(keyELEMENT_TYPE, clMakeKeyword(STR_ELEMENT_TYPE__125, clEOA));
  clSetq(CONS_382, clCons(keyFETCH_FUNCTION, clNIL, clEOA));
  clSetq(CONS_381, clCons(keySIZE_FUNCTION, CONS_382, clEOA));
  clSetq(CONS_380, clCons(keySEQUENCE_TYPE, CONS_381, clEOA));
  clSetq(CONS_379, clCons(keyELEMENT_TYPE, CONS_380, clEOA));
  clSetq(STR_WHICH__126,
         clCharpSimpleBaseString("WHICH"));
  clSetq(keyWHICH, clMakeKeyword(STR_WHICH__126, clEOA));
  clSetq(CONS_383, clCons(keyWHICH, clNIL, clEOA));
  clSetq(CONS_385, clCons(keyOF, clNIL, clEOA));
  clSetq(CONS_384, clCons(keyIN, CONS_385, clEOA));
  clSetq(STRn_127,
         clCharpSimpleBaseString("Too many prepositions!"));
  clSetq(STRn_128,
         clCharpSimpleBaseString("Missing OF or IN in ~S iteration path."));
  clSetq(STR_SYMBOL_TYPES__129,
         clCharpSimpleBaseString("SYMBOL-TYPES"));
  clSetq(keySYMBOL_TYPES, clMakeKeyword(STR_SYMBOL_TYPES__129, clEOA));
  clSetq(CONS_386, clCons(keySYMBOL_TYPES, clNIL, clEOA));
  clSetq(STRn_130,
         clCharpSimpleBaseString("Destructuring is not valid for package symbol iteration."));
  clSetq(CONS_389, clCons(clLOOP_DO_NAMED, clNIL, clEOA));
  clSetq(CONS_388, clCons(CONS_389, clNIL, clEOA));
  clSetq(CONS_387, clCons(clNAMED, CONS_388, clEOA));
  clSetq(CONS_392, clCons(clLOOP_DO_INITIALLY, clNIL, clEOA));
  clSetq(CONS_391, clCons(CONS_392, clNIL, clEOA));
  clSetq(CONS_390, clCons(clINITIALLY, CONS_391, clEOA));
  clSetq(CONS_395, clCons(clLOOP_DO_FINALLY, clNIL, clEOA));
  clSetq(CONS_394, clCons(CONS_395, clNIL, clEOA));
  clSetq(CONS_393, clCons(clFINALLY, CONS_394, clEOA));
  clSetq(CONS_398, clCons(clLOOP_DO_DO, clNIL, clEOA));
  clSetq(CONS_397, clCons(CONS_398, clNIL, clEOA));
  clSetq(CONS_396, clCons(clDO, CONS_397, clEOA));
  clSetq(CONS_399, clCons(clDOING, CONS_397, clEOA));
  clSetq(CONS_402, clCons(clLOOP_DO_RETURN, clNIL, clEOA));
  clSetq(CONS_401, clCons(CONS_402, clNIL, clEOA));
  clSetq(CONS_400, clCons(clRETURN, CONS_401, clEOA));
  clSetq(CONS_406, clCons(clLIST, clNIL, clEOA));
  clSetq(CONS_405, clCons(clLOOP_LIST_COLLECTION, CONS_406, clEOA));
  clSetq(CONS_404, clCons(CONS_405, clNIL, clEOA));
  clSetq(CONS_403, clCons(clCOLLECT, CONS_404, clEOA));
  clSetq(CONS_407, clCons(clCOLLECTING, CONS_404, clEOA));
  clSetq(CONS_410, clCons(clLOOP_LIST_COLLECTION, CONS_297, clEOA));
  clSetq(CONS_409, clCons(CONS_410, clNIL, clEOA));
  clSetq(CONS_408, clCons(clAPPEND, CONS_409, clEOA));
  clSetq(CONS_411, clCons(clAPPENDING, CONS_409, clEOA));
  clSetq(CONS_415, clCons(clNCONC, clNIL, clEOA));
  clSetq(CONS_414, clCons(clLOOP_LIST_COLLECTION, CONS_415, clEOA));
  clSetq(CONS_413, clCons(CONS_414, clNIL, clEOA));
  clSetq(CONS_412, clCons(clNCONC, CONS_413, clEOA));
  clSetq(CONS_416, clCons(clNCONCING, CONS_413, clEOA));
  clSetq(CONS_417, clCons(clFIXNUM, clNIL, clEOA));
  clSetq(CONS_424, clCons(clNUMBER, clNIL, clEOA));
  clSetq(CONS_423, clCons(clNUMBER, CONS_424, clEOA));
  clSetq(CONS_422, clCons(clSUM, CONS_423, clEOA));
  clSetq(CONS_421, clCons(clLOOP_SUM_COLLECTION, CONS_422, clEOA));
  clSetq(CONS_420, clCons(CONS_421, clNIL, clEOA));
  clSetq(CONS_419, clCons(clSUM, CONS_420, clEOA));
  clSetq(CONS_426, clCons(clSUMMING, CONS_420, clEOA));
  clSetq(CONS_430, clCons(clLOOP_MAXMIN_COLLECTION, CONS_60, clEOA));
  clSetq(CONS_429, clCons(CONS_430, clNIL, clEOA));
  clSetq(CONS_428, clCons(clMAXIMIZE, CONS_429, clEOA));
  clSetq(CONS_435, clCons(clMIN, clNIL, clEOA));
  clSetq(CONS_434, clCons(clLOOP_MAXMIN_COLLECTION, CONS_435, clEOA));
  clSetq(CONS_433, clCons(CONS_434, clNIL, clEOA));
  clSetq(CONS_432, clCons(clMINIMIZE, CONS_433, clEOA));
  clSetq(CONS_437, clCons(clMAXIMIZING, CONS_429, clEOA));
  clSetq(CONS_439, clCons(clMINIMIZING, CONS_433, clEOA));
  clSetq(CONS_444, clCons(clT, CONS_2, clEOA));
  clSetq(CONS_443, clCons(clLOOP_DO_ALWAYS, CONS_444, clEOA));
  clSetq(CONS_442, clCons(CONS_443, clNIL, clEOA));
  clSetq(CONS_441, clCons(clALWAYS, CONS_442, clEOA));
  clSetq(CONS_449, clCons(clT, CONS_61, clEOA));
  clSetq(CONS_448, clCons(clLOOP_DO_ALWAYS, CONS_449, clEOA));
  clSetq(CONS_447, clCons(CONS_448, clNIL, clEOA));
  clSetq(CONS_446, clCons(clNEVER, CONS_447, clEOA));
  clSetq(CONS_453, clCons(clLOOP_DO_THEREIS, CONS_61, clEOA));
  clSetq(CONS_452, clCons(CONS_453, clNIL, clEOA));
  clSetq(CONS_451, clCons(clTHEREIS, CONS_452, clEOA));
  clSetq(STR_WHILE__131,
         clCharpSimpleBaseString("WHILE"));
  clSetq(keyWHILE, clMakeKeyword(STR_WHILE__131, clEOA));
  clSetq(CONS_459, clCons(keyWHILE, clNIL, clEOA));
  clSetq(CONS_458, clCons(clNIL, CONS_459, clEOA));
  clSetq(CONS_457, clCons(clLOOP_DO_WHILE, CONS_458, clEOA));
  clSetq(CONS_456, clCons(CONS_457, clNIL, clEOA));
  clSetq(CONS_455, clCons(clWHILE, CONS_456, clEOA));
  clSetq(STR_UNTIL__132,
         clCharpSimpleBaseString("UNTIL"));
  clSetq(keyUNTIL, clMakeKeyword(STR_UNTIL__132, clEOA));
  clSetq(CONS_465, clCons(keyUNTIL, clNIL, clEOA));
  clSetq(CONS_464, clCons(clT, CONS_465, clEOA));
  clSetq(CONS_463, clCons(clLOOP_DO_WHILE, CONS_464, clEOA));
  clSetq(CONS_462, clCons(CONS_463, clNIL, clEOA));
  clSetq(CONS_461, clCons(clUNTIL, CONS_462, clEOA));
  clSetq(CONS_470, clCons(clWHEN, CONS_2, clEOA));
  clSetq(CONS_469, clCons(clLOOP_DO_IF, CONS_470, clEOA));
  clSetq(CONS_468, clCons(CONS_469, clNIL, clEOA));
  clSetq(CONS_467, clCons(clWHEN, CONS_468, clEOA));
  clSetq(CONS_475, clCons(clIF, CONS_2, clEOA));
  clSetq(CONS_474, clCons(clLOOP_DO_IF, CONS_475, clEOA));
  clSetq(CONS_473, clCons(CONS_474, clNIL, clEOA));
  clSetq(CONS_472, clCons(clIF, CONS_473, clEOA));
  clSetq(CONS_480, clCons(clUNLESS, CONS_61, clEOA));
  clSetq(CONS_479, clCons(clLOOP_DO_IF, CONS_480, clEOA));
  clSetq(CONS_478, clCons(CONS_479, clNIL, clEOA));
  clSetq(CONS_477, clCons(clUNLESS, CONS_478, clEOA));
  clSetq(CONS_484, clCons(clLOOP_DO_WITH, clNIL, clEOA));
  clSetq(CONS_483, clCons(CONS_484, clNIL, clEOA));
  clSetq(CONS_482, clCons(clWITH, CONS_483, clEOA));
  clSetq(CONS_481, clCons(CONS_482, clNIL, clEOA));
  clSetq(CONS_476, clCons(CONS_477, CONS_481, clEOA));
  clSetq(CONS_471, clCons(CONS_472, CONS_476, clEOA));
  clSetq(CONS_466, clCons(CONS_467, CONS_471, clEOA));
  clSetq(CONS_460, clCons(CONS_461, CONS_466, clEOA));
  clSetq(CONS_454, clCons(CONS_455, CONS_460, clEOA));
  clSetq(CONS_450, clCons(CONS_451, CONS_454, clEOA));
  clSetq(CONS_445, clCons(CONS_446, CONS_450, clEOA));
  clSetq(CONS_440, clCons(CONS_441, CONS_445, clEOA));
  clSetq(CONS_438, clCons(CONS_439, CONS_440, clEOA));
  clSetq(CONS_436, clCons(CONS_437, CONS_438, clEOA));
  clSetq(CONS_431, clCons(CONS_432, CONS_436, clEOA));
  clSetq(CONS_427, clCons(CONS_428, CONS_431, clEOA));
  clSetq(CONS_425, clCons(CONS_426, CONS_427, clEOA));
  clSetq(CONS_418, clCons(CONS_419, CONS_425, clEOA));
  clSetq(CONS_488, clCons(clLOOP_ANSI_FOR_EQUALS, clNIL, clEOA));
  clSetq(CONS_487, clCons(CONS_488, clNIL, clEOA));
  clSetq(CONS_486, clCons(clequalsymbol, CONS_487, clEOA));
  clSetq(CONS_492, clCons(clLOOP_FOR_ACROSS, clNIL, clEOA));
  clSetq(CONS_491, clCons(CONS_492, clNIL, clEOA));
  clSetq(CONS_490, clCons(clACROSS, CONS_491, clEOA));
  clSetq(CONS_496, clCons(clLOOP_FOR_IN, clNIL, clEOA));
  clSetq(CONS_495, clCons(CONS_496, clNIL, clEOA));
  clSetq(CONS_494, clCons(clIN, CONS_495, clEOA));
  clSetq(CONS_500, clCons(clLOOP_FOR_ON, clNIL, clEOA));
  clSetq(CONS_499, clCons(CONS_500, clNIL, clEOA));
  clSetq(CONS_498, clCons(clON, CONS_499, clEOA));
  clSetq(CONS_505, clCons(keyFROM, clNIL, clEOA));
  clSetq(CONS_504, clCons(clLOOP_FOR_ARITHMETIC, CONS_505, clEOA));
  clSetq(CONS_503, clCons(CONS_504, clNIL, clEOA));
  clSetq(CONS_502, clCons(clFROM, CONS_503, clEOA));
  clSetq(CONS_509, clCons(clLOOP_FOR_ARITHMETIC, CONS_373, clEOA));
  clSetq(CONS_508, clCons(CONS_509, clNIL, clEOA));
  clSetq(CONS_507, clCons(clDOWNFROM, CONS_508, clEOA));
  clSetq(CONS_513, clCons(clLOOP_FOR_ARITHMETIC, CONS_362, clEOA));
  clSetq(CONS_512, clCons(CONS_513, clNIL, clEOA));
  clSetq(CONS_511, clCons(clUPFROM, CONS_512, clEOA));
  clSetq(CONS_517, clCons(clLOOP_FOR_ARITHMETIC, CONS_367, clEOA));
  clSetq(CONS_516, clCons(CONS_517, clNIL, clEOA));
  clSetq(CONS_515, clCons(clBELOW, CONS_516, clEOA));
  clSetq(CONS_522, clCons(keyTO, clNIL, clEOA));
  clSetq(CONS_521, clCons(clLOOP_FOR_ARITHMETIC, CONS_522, clEOA));
  clSetq(CONS_520, clCons(CONS_521, clNIL, clEOA));
  clSetq(CONS_519, clCons(clTO, CONS_520, clEOA));
  clSetq(CONS_527, clCons(keyUPTO, clNIL, clEOA));
  clSetq(CONS_526, clCons(clLOOP_FOR_ARITHMETIC, CONS_527, clEOA));
  clSetq(CONS_525, clCons(CONS_526, clNIL, clEOA));
  clSetq(CONS_524, clCons(clUPTO, CONS_525, clEOA));
  clSetq(CONS_531, clCons(clLOOP_FOR_BEING, clNIL, clEOA));
  clSetq(CONS_530, clCons(CONS_531, clNIL, clEOA));
  clSetq(CONS_529, clCons(clBEING, CONS_530, clEOA));
  clSetq(CONS_528, clCons(CONS_529, clNIL, clEOA));
  clSetq(CONS_523, clCons(CONS_524, CONS_528, clEOA));
  clSetq(CONS_518, clCons(CONS_519, CONS_523, clEOA));
  clSetq(CONS_514, clCons(CONS_515, CONS_518, clEOA));
  clSetq(CONS_510, clCons(CONS_511, CONS_514, clEOA));
  clSetq(CONS_506, clCons(CONS_507, CONS_510, clEOA));
  clSetq(CONS_501, clCons(CONS_502, CONS_506, clEOA));
  clSetq(CONS_497, clCons(CONS_498, CONS_501, clEOA));
  clSetq(CONS_493, clCons(CONS_494, CONS_497, clEOA));
  clSetq(CONS_489, clCons(CONS_490, CONS_493, clEOA));
  clSetq(CONS_485, clCons(CONS_486, CONS_489, clEOA));
  clSetq(CONS_535, clCons(clLOOP_DO_FOR, clNIL, clEOA));
  clSetq(CONS_534, clCons(CONS_535, clNIL, clEOA));
  clSetq(CONS_533, clCons(clFOR, CONS_534, clEOA));
  clSetq(CONS_537, clCons(clAS, CONS_534, clEOA));
  clSetq(CONS_541, clCons(clLOOP_DO_REPEAT, clNIL, clEOA));
  clSetq(CONS_540, clCons(CONS_541, clNIL, clEOA));
  clSetq(CONS_539, clCons(clREPEAT, CONS_540, clEOA));
  clSetq(CONS_538, clCons(CONS_539, clNIL, clEOA));
  clSetq(CONS_536, clCons(CONS_537, CONS_538, clEOA));
  clSetq(CONS_532, clCons(CONS_533, CONS_536, clEOA));
  clSetq(CONS_582, clCons(clVECTOR, clNIL, clEOA));
  clSetq(CONS_581, clCons(clT, CONS_582, clEOA));
  clSetq(CONS_580, clCons(clSYMBOL, CONS_581, clEOA));
  clSetq(CONS_579, clCons(clSTRING_CHAR, CONS_580, clEOA));
  clSetq(CONS_578, clCons(clSTRING, CONS_579, clEOA));
  clSetq(CONS_577, clCons(clSTREAM, CONS_578, clEOA));
  clSetq(CONS_576, clCons(clSTANDARD_CHAR, CONS_577, clEOA));
  clSetq(CONS_575, clCons(clSINGLE_FLOAT, CONS_576, clEOA));
  clSetq(CONS_574, clCons(clSIMPLE_VECTOR, CONS_575, clEOA));
  clSetq(CONS_573, clCons(clSIMPLE_STRING, CONS_574, clEOA));
  clSetq(CONS_572, clCons(clSIMPLE_BIT_VECTOR, CONS_573, clEOA));
  clSetq(CONS_571, clCons(clSIMPLE_ARRAY, CONS_572, clEOA));
  clSetq(CONS_570, clCons(clSHORT_FLOAT, CONS_571, clEOA));
  clSetq(CONS_569, clCons(clSEQUENCE, CONS_570, clEOA));
  clSetq(CONS_568, clCons(clREADTABLE, CONS_569, clEOA));
  clSetq(CONS_567, clCons(clRATIONAL, CONS_568, clEOA));
  clSetq(CONS_566, clCons(clRATIO, CONS_567, clEOA));
  clSetq(CONS_565, clCons(clRANDOM_STATE, CONS_566, clEOA));
  clSetq(CONS_564, clCons(clPATHNAME, CONS_565, clEOA));
  clSetq(CONS_563, clCons(clPACKAGE, CONS_564, clEOA));
  clSetq(CONS_562, clCons(clNUMBER, CONS_563, clEOA));
  clSetq(CONS_561, clCons(clNULL, CONS_562, clEOA));
  clSetq(CONS_560, clCons(clNIL, CONS_561, clEOA));
  clSetq(CONS_559, clCons(clLONG_FLOAT, CONS_560, clEOA));
  clSetq(CONS_558, clCons(clLIST, CONS_559, clEOA));
  clSetq(CONS_557, clCons(clKEYWORD, CONS_558, clEOA));
  clSetq(CONS_556, clCons(clINTEGER, CONS_557, clEOA));
  clSetq(CONS_555, clCons(clHASH_TABLE, CONS_556, clEOA));
  clSetq(CONS_554, clCons(clFUNCTION, CONS_555, clEOA));
  clSetq(CONS_553, clCons(clFLOAT, CONS_554, clEOA));
  clSetq(CONS_552, clCons(clFIXNUM, CONS_553, clEOA));
  clSetq(CONS_551, clCons(clDOUBLE_FLOAT, CONS_552, clEOA));
  clSetq(CONS_550, clCons(clCONS, CONS_551, clEOA));
  clSetq(CONS_549, clCons(clCOMPLEX, CONS_550, clEOA));
  clSetq(CONS_548, clCons(clCOMPILED_FUNCTION, CONS_549, clEOA));
  clSetq(CONS_547, clCons(clCHARACTER, CONS_548, clEOA));
  clSetq(CONS_546, clCons(clBIT_VECTOR, CONS_547, clEOA));
  clSetq(CONS_545, clCons(clBIT, CONS_546, clEOA));
  clSetq(CONS_544, clCons(clBIGNUM, CONS_545, clEOA));
  clSetq(CONS_543, clCons(clATOM, CONS_544, clEOA));
  clSetq(CONS_542, clCons(clARRAY, CONS_543, clEOA));
  clSetq(CONS_584, clCons(clHASH_KEYS, clNIL, clEOA));
  clSetq(CONS_583, clCons(clHASH_KEY, CONS_584, clEOA));
  clSetq(CONS_585, clCons(CONS_358, clNIL, clEOA));
  clSetq(CONS_587, clCons(clHASH_KEY, clNIL, clEOA));
  clSetq(CONS_586, clCons(keyWHICH, CONS_587, clEOA));
  clSetq(CONS_589, clCons(clHASH_VALUES, clNIL, clEOA));
  clSetq(CONS_588, clCons(clHASH_VALUE, CONS_589, clEOA));
  clSetq(CONS_591, clCons(clHASH_VALUE, clNIL, clEOA));
  clSetq(CONS_590, clCons(keyWHICH, CONS_591, clEOA));
  clSetq(CONS_593, clCons(clSYMBOLS, clNIL, clEOA));
  clSetq(CONS_592, clCons(clSYMBOL, CONS_593, clEOA));
  clSetq(STR_INTERNAL__133,
         clCharpSimpleBaseString("INTERNAL"));
  clSetq(keyINTERNAL, clMakeKeyword(STR_INTERNAL__133, clEOA));
  clSetq(STR_EXTERNAL__134,
         clCharpSimpleBaseString("EXTERNAL"));
  clSetq(keyEXTERNAL, clMakeKeyword(STR_EXTERNAL__134, clEOA));
  clSetq(STR_INHERITED__135,
         clCharpSimpleBaseString("INHERITED"));
  clSetq(keyINHERITED, clMakeKeyword(STR_INHERITED__135, clEOA));
  clSetq(CONS_598, clCons(keyINHERITED, clNIL, clEOA));
  clSetq(CONS_597, clCons(keyEXTERNAL, CONS_598, clEOA));
  clSetq(CONS_596, clCons(keyINTERNAL, CONS_597, clEOA));
  clSetq(CONS_595, clCons(CONS_596, clNIL, clEOA));
  clSetq(CONS_594, clCons(keySYMBOL_TYPES, CONS_595, clEOA));
  clSetq(CONS_600, clCons(clEXTERNAL_SYMBOLS, clNIL, clEOA));
  clSetq(CONS_599, clCons(clEXTERNAL_SYMBOL, CONS_600, clEOA));
  clSetq(CONS_603, clCons(keyEXTERNAL, clNIL, clEOA));
  clSetq(CONS_602, clCons(CONS_603, clNIL, clEOA));
  clSetq(CONS_601, clCons(keySYMBOL_TYPES, CONS_602, clEOA));
  clSetq(CONS_605, clCons(clPRESENT_SYMBOLS, clNIL, clEOA));
  clSetq(CONS_604, clCons(clPRESENT_SYMBOL, CONS_605, clEOA));
  clSetq(CONS_608, clCons(keyINTERNAL, clNIL, clEOA));
  clSetq(CONS_607, clCons(CONS_608, clNIL, clEOA));
  clSetq(CONS_606, clCons(keySYMBOL_TYPES, CONS_607, clEOA));
  clSetq(STR_LOOP__136,
         clCharpSimpleBaseString("LOOP"));


  { clObject L_value57;
    clSetq(L_value57,
           clMakeClosure(0, clLoopCopylistSTAR, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value57, clLOOP_COPYLISTstar, clEOA); }
  (void) clLOOP_COPYLISTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_GENTEMPstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_GENTEMPstar, clEOA), clEOA)))
    clSetSymbolValueValue(clstarLOOP_GENTEMPstar, clNIL);
  (void) clstarLOOP_GENTEMPstar;
  clSetSymbolFunctionValue(clLOOP_GENTEMP,
                           clMakeClosure(0,
                                         clLoopGentemp,
                                         clNULL_HOOK));
  (void) clLOOP_GENTEMP;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_REAL_DATA_TYPEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_REAL_DATA_TYPEstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_REAL_DATA_TYPEstar, clREAL);
  (void) clstarLOOP_REAL_DATA_TYPEstar;
  clSetSymbolFunctionValue(clLOOP_OPTIMIZATION_QUANTITIES,
                           clMakeClosure(0,
                                         clLoopOptimizationQuantities,
                                         clNULL_HOOK));
  (void) clLOOP_OPTIMIZATION_QUANTITIES;
  clSetSymbolFunctionValue(clHIDE_VARIABLE_REFERENCES,
                           clMakeClosure(0,
                                         clHideVariableReferences,
                                         clNULL_HOOK));
  (void) clHIDE_VARIABLE_REFERENCES;
  clSetSymbolFunctionValue(clHIDE_VARIABLE_REFERENCE,
                           clMakeClosure(0,
                                         clHideVariableReference,
                                         clNULL_HOOK));
  (void) clHIDE_VARIABLE_REFERENCE;
  { clObject L_value74;
    clSetq(L_value74,
           clMakeClosure(0,
                         clWithLoopListCollectionHead,
                         clNULL_HOOK));
    cl_SETF_MacroFunction(L_value74,
                          clWITH_LOOP_LIST_COLLECTION_HEAD,
                          clEOA); }
  (void) clWITH_LOOP_LIST_COLLECTION_HEAD;
  { clObject L_value81;
    clSetq(L_value81,
           clMakeClosure(0, clLoopCollectRplacd, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value81, clLOOP_COLLECT_RPLACD, clEOA); }
  (void) clLOOP_COLLECT_RPLACD;
  { clObject L_value92;
    clSetq(L_value92,
           clMakeClosure(0, clLoopCollectAnswer, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value92, clLOOP_COLLECT_ANSWER, clEOA); }
  (void) clLOOP_COLLECT_ANSWER;
  { clObject L_g0;
    { clObject L_0;
      clSetq(L_0, clSymbolFunctionValue(clENSURE_STRUCTURE));
      clSetq(L_g0, clApply(L_0, clLOOP_MINIMAX, CONS_8, clEOA)); }
    clSetSymbolFunctionValue(clMAKE_LOOP_MINIMAX_INTERNAL,
                             clMakeClosure(0,
                                           clMakeLoopMinimaxInternal,
                                           clNULL_HOOK));
    (void) clMAKE_LOOP_MINIMAX_INTERNAL;
    clSetSymbolFunctionValue(clLOOP_MINIMAX_ANSWER_VARIABLE,
                             clMakeClosure(0,
                                           clLoopMinimaxAnswerVariable,
                                           clNULL_HOOK));
    (void) clLOOP_MINIMAX_ANSWER_VARIABLE;
    clSetSymbolSetfFunctionValue(clLOOP_MINIMAX_ANSWER_VARIABLE,
                                 clMakeClosure(0,
                                               cl_SETF_LoopMinimaxAnswerVariable,
                                               clNULL_HOOK));
    (void) CONS_42;
    clSetSymbolFunctionValue(clLOOP_MINIMAX_TYPE,
                             clMakeClosure(0,
                                           clLoopMinimaxType,
                                           clNULL_HOOK));
    (void) clLOOP_MINIMAX_TYPE;
    clSetSymbolSetfFunctionValue(clLOOP_MINIMAX_TYPE,
                                 clMakeClosure(0,
                                               cl_SETF_LoopMinimaxType,
                                               clNULL_HOOK));
    (void) CONS_44;
    clSetSymbolFunctionValue(clLOOP_MINIMAX_TEMP_VARIABLE,
                             clMakeClosure(0,
                                           clLoopMinimaxTempVariable,
                                           clNULL_HOOK));
    (void) clLOOP_MINIMAX_TEMP_VARIABLE;
    clSetSymbolSetfFunctionValue(clLOOP_MINIMAX_TEMP_VARIABLE,
                                 clMakeClosure(0,
                                               cl_SETF_LoopMinimaxTempVariable,
                                               clNULL_HOOK));
    (void) CONS_46;
    clSetSymbolFunctionValue(clLOOP_MINIMAX_FLAG_VARIABLE,
                             clMakeClosure(0,
                                           clLoopMinimaxFlagVariable,
                                           clNULL_HOOK));
    (void) clLOOP_MINIMAX_FLAG_VARIABLE;
    clSetSymbolSetfFunctionValue(clLOOP_MINIMAX_FLAG_VARIABLE,
                                 clMakeClosure(0,
                                               cl_SETF_LoopMinimaxFlagVariable,
                                               clNULL_HOOK));
    (void) CONS_48;
    clSetSymbolFunctionValue(clLOOP_MINIMAX_OPERATIONS,
                             clMakeClosure(0,
                                           clLoopMinimaxOperations,
                                           clNULL_HOOK));
    (void) clLOOP_MINIMAX_OPERATIONS;
    clSetSymbolSetfFunctionValue(clLOOP_MINIMAX_OPERATIONS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopMinimaxOperations,
                                               clNULL_HOOK));
    (void) CONS_50;
    clSetSymbolFunctionValue(clLOOP_MINIMAX_INFINITY_DATA,
                             clMakeClosure(0,
                                           clLoopMinimaxInfinityData,
                                           clNULL_HOOK));
    (void) clLOOP_MINIMAX_INFINITY_DATA;
    clSetSymbolSetfFunctionValue(clLOOP_MINIMAX_INFINITY_DATA,
                                 clMakeClosure(0,
                                               cl_SETF_LoopMinimaxInfinityData,
                                               clNULL_HOOK));
    (void) CONS_52;
    (void) clLOOP_MINIMAX; }
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_MINIMAX_TYPE_INFINITIES_ALISTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_MINIMAX_TYPE_INFINITIES_ALISTstar,
                            clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_MINIMAX_TYPE_INFINITIES_ALISTstar,
                          CONS_54);
  (void) clstarLOOP_MINIMAX_TYPE_INFINITIES_ALISTstar;
  clSetSymbolFunctionValue(clMAKE_LOOP_MINIMAX,
                           clMakeClosure(0,
                                         clMakeLoopMinimax,
                                         clNULL_HOOK));
  (void) clMAKE_LOOP_MINIMAX;
  clSetSymbolFunctionValue(clLOOP_NOTE_MINIMAX_OPERATION,
                           clMakeClosure(0,
                                         clLoopNoteMinimaxOperation,
                                         clNULL_HOOK));
  (void) clLOOP_NOTE_MINIMAX_OPERATION;
  { clObject L_value123;
    clSetq(L_value123,
           clMakeClosure(0, clWithMinimaxValue, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value123, clWITH_MINIMAX_VALUE, clEOA); }
  (void) clWITH_MINIMAX_VALUE;
  { clObject L_value126;
    clSetq(L_value126,
           clMakeClosure(0,
                         clLoopAccumulateMinimaxValue,
                         clNULL_HOOK));
    cl_SETF_MacroFunction(L_value126,
                          clLOOP_ACCUMULATE_MINIMAX_VALUE,
                          clEOA); }
  (void) clLOOP_ACCUMULATE_MINIMAX_VALUE;
  clSetSymbolFunctionValue(clLOOP_TEQUAL,
                           clMakeClosure(0,
                                         clLoopTequal,
                                         clNULL_HOOK));
  (void) clLOOP_TEQUAL;
  clSetSymbolFunctionValue(clLOOP_TASSOC,
                           clMakeClosure(0,
                                         clLoopTassoc,
                                         clNULL_HOOK));
  (void) clLOOP_TASSOC;
  clSetSymbolFunctionValue(clLOOP_TMEMBER,
                           clMakeClosure(0,
                                         clLoopTmember,
                                         clNULL_HOOK));
  (void) clLOOP_TMEMBER;
  clSetSymbolFunctionValue(clLOOP_LOOKUP_KEYWORD,
                           clMakeClosure(0,
                                         clLoopLookupKeyword,
                                         clNULL_HOOK));
  (void) clLOOP_LOOKUP_KEYWORD;
  { clObject L_value138;
    clSetq(L_value138,
           clMakeClosure(0, clLoopStoreTableData, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value138,
                          clLOOP_STORE_TABLE_DATA,
                          clEOA); }
  (void) clLOOP_STORE_TABLE_DATA;
  { clObject L_g1;
    { clObject L_0;
      clSetq(L_0, clSymbolFunctionValue(clENSURE_STRUCTURE));
      clSetq(L_g1, clApply(L_0, clLOOP_UNIVERSE, CONS_62, clEOA)); }
    { clObject L_8, L_6, L_0;
      clSetq(L_0, clEnsureGenericFunction(clPRINT_OBJECT, clEOA));
      { clObject L_0__R1;
        clSetq(L_0__R1,
               clCanonicalizeSpecializer(clLOOP_UNIVERSE, clEOA));
        clSetq(L_6,
               clList(L_0__R1,
                      clCanonicalizeSpecializer(clT, clEOA),
                      clEOA)); }
      clSetq(L_8,
             clMakeClosure(0,
                           clPrintObject_clLOOP_UNIVERSE_clT,
                           clNULL_HOOK));
      clEnsureMethod(L_0, keyQUALIFIERS, clNIL, keyLAMBDA_LIST,
                     CONS_96, keySPECIALIZERS, L_6, keyFUNCTION, L_8,
                     keyDECLARATIONS, clNIL, keyDOCUMENTATION, clNIL,
                     clEOA); }
    clSetSymbolFunctionValue(clMAKE_LOOP_UNIVERSE,
                             clMakeClosure(0,
                                           clMakeLoopUniverse,
                                           clNULL_HOOK));
    (void) clMAKE_LOOP_UNIVERSE;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_KEYWORDS,
                             clMakeClosure(0,
                                           clLoopUniverseKeywords,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_KEYWORDS;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_KEYWORDS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseKeywords,
                                               clNULL_HOOK));
    (void) CONS_106;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_ITERATION_KEYWORDS,
                             clMakeClosure(0,
                                           clLoopUniverseIterationKeywords,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_ITERATION_KEYWORDS;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_ITERATION_KEYWORDS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseIterationKeywords,
                                               clNULL_HOOK));
    (void) CONS_108;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_FOR_KEYWORDS,
                             clMakeClosure(0,
                                           clLoopUniverseForKeywords,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_FOR_KEYWORDS;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_FOR_KEYWORDS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseForKeywords,
                                               clNULL_HOOK));
    (void) CONS_110;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_PATH_KEYWORDS,
                             clMakeClosure(0,
                                           clLoopUniversePathKeywords,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_PATH_KEYWORDS;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_PATH_KEYWORDS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniversePathKeywords,
                                               clNULL_HOOK));
    (void) CONS_112;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_TYPE_SYMBOLS,
                             clMakeClosure(0,
                                           clLoopUniverseTypeSymbols,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_TYPE_SYMBOLS;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_TYPE_SYMBOLS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseTypeSymbols,
                                               clNULL_HOOK));
    (void) CONS_114;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_TYPE_KEYWORDS,
                             clMakeClosure(0,
                                           clLoopUniverseTypeKeywords,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_TYPE_KEYWORDS;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_TYPE_KEYWORDS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseTypeKeywords,
                                               clNULL_HOOK));
    (void) CONS_116;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_ANSI,
                             clMakeClosure(0,
                                           clLoopUniverseAnsi,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_ANSI;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_ANSI,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseAnsi,
                                               clNULL_HOOK));
    (void) CONS_118;
    clSetSymbolFunctionValue(clLOOP_UNIVERSE_IMPLICIT_FOR_REQUIRED,
                             clMakeClosure(0,
                                           clLoopUniverseImplicitForRequired,
                                           clNULL_HOOK));
    (void) clLOOP_UNIVERSE_IMPLICIT_FOR_REQUIRED;
    clSetSymbolSetfFunctionValue(clLOOP_UNIVERSE_IMPLICIT_FOR_REQUIRED,
                                 clMakeClosure(0,
                                               cl_SETF_LoopUniverseImplicitForRequired,
                                               clNULL_HOOK));
    (void) CONS_120;
    (void) clLOOP_UNIVERSE; }
  clSetSymbolFunctionValue(clPRINT_LOOP_UNIVERSE,
                           clMakeClosure(0,
                                         clPrintLoopUniverse,
                                         clNULL_HOOK));
  (void) clPRINT_LOOP_UNIVERSE;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_UNIVERSEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_UNIVERSEstar;
  clSetSymbolFunctionValue(clMAKE_STANDARD_LOOP_UNIVERSE,
                           clMakeClosure(0,
                                         clMakeStandardLoopUniverse,
                                         clNULL_HOOK));
  (void) clMAKE_STANDARD_LOOP_UNIVERSE;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_DESTRUCTURING_HOOKSstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_DESTRUCTURING_HOOKSstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_DESTRUCTURING_HOOKSstar, clNIL);
  (void) clstarLOOP_DESTRUCTURING_HOOKSstar;
  clSetSymbolFunctionValue(clLOOP_MAKE_PSETQ,
                           clMakeClosure(0,
                                         clLoopMakePsetq,
                                         clNULL_HOOK));
  (void) clLOOP_MAKE_PSETQ;
  clSetSymbolFunctionValue(clLOOP_MAKE_DESETQ,
                           clMakeClosure(0,
                                         clLoopMakeDesetq,
                                         clNULL_HOOK));
  (void) clLOOP_MAKE_DESETQ;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_DESETQ_TEMPORARYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_DESETQ_TEMPORARYstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_DESETQ_TEMPORARYstar,
                          clMakeSymbol(STR_LOOP_DESETQ_TEMP__35,
                                       clEOA));
  (void) clstarLOOP_DESETQ_TEMPORARYstar;
  { clObject L_value199;
    clSetq(L_value199,
           clMakeClosure(0, clLoopReallyDesetq, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value199, clLOOP_REALLY_DESETQ, clEOA); }
  (void) clLOOP_REALLY_DESETQ;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_SOURCE_CODEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_SOURCE_CODEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_ORIGINAL_SOURCE_CODEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_ORIGINAL_SOURCE_CODEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_SOURCE_CONTEXTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_SOURCE_CONTEXTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_NAMESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_NAMESstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_MACRO_ENVIRONMENTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_MACRO_ENVIRONMENTstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_NAMED_VARIABLESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_NAMED_VARIABLESstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_VARIABLESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_VARIABLESstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_DECLARATIONSstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_DECLARATIONSstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_DESETQ_CROCKSstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_DESETQ_CROCKSstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_WRAPPERSstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_WRAPPERSstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_BIND_STACKstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_BIND_STACKstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_NODECLAREstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_NODECLAREstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_ITERATION_VARIABLESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_ITERATION_VARIABLESstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_PROLOGUEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_PROLOGUEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_BEFORE_LOOPstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_BEFORE_LOOPstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_BODYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_BODYstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_AFTER_BODYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_AFTER_BODYstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_EMITTED_BODYstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_EMITTED_BODYstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_EPILOGUEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_EPILOGUEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_AFTER_EPILOGUEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_AFTER_EPILOGUEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_FINAL_VALUE_CULPRITstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_FINAL_VALUE_CULPRITstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_INSIDE_CONDITIONALstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_INSIDE_CONDITIONALstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_WHEN_IT_VARIABLEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_WHEN_IT_VARIABLEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_NEVER_STEPPED_VARIABLEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_NEVER_STEPPED_VARIABLEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_COLLECTION_CRUFTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  (void) clstarLOOP_COLLECTION_CRUFTstar;
  clSetSymbolFunctionValue(clLOOP_CONSTANT_FOLD_IF_POSSIBLE,
                           clMakeClosure(0,
                                         clLoopConstantFoldIfPossible,
                                         clNULL_HOOK));
  (void) clLOOP_CONSTANT_FOLD_IF_POSSIBLE;
  clSetSymbolFunctionValue(clLOOP_CONSTANTP,
                           clMakeClosure(0,
                                         clLoopConstantp,
                                         clNULL_HOOK));
  (void) clLOOP_CONSTANTP;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_DUPLICATE_CODEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_DUPLICATE_CODEstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_DUPLICATE_CODEstar, clNIL);
  (void) clstarLOOP_DUPLICATE_CODEstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_ITERATION_FLAG_VARIABLEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_ITERATION_FLAG_VARIABLEstar,
                            clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_ITERATION_FLAG_VARIABLEstar,
                          clMakeSymbol(STR_LOOP_NOT_FIRST_TIME__37,
                                       clEOA));
  (void) clstarLOOP_ITERATION_FLAG_VARIABLEstar;
  clSetSymbolFunctionValue(clLOOP_CODE_DUPLICATION_THRESHOLD,
                           clMakeClosure(0,
                                         clLoopCodeDuplicationThreshold,
                                         clNULL_HOOK));
  (void) clLOOP_CODE_DUPLICATION_THRESHOLD;
  { clObject L_value323;
    clSetq(L_value323, clMakeClosure(0, clLoopBody, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value323, clLOOP_BODY, clEOA); }
  (void) clLOOP_BODY;
  clSetSymbolFunctionValue(clDUPLICATABLE_CODE_P,
                           clMakeClosure(0,
                                         clDuplicatableCodeP,
                                         clNULL_HOOK));
  (void) clDUPLICATABLE_CODE_P;
  cl_SETF_GlobalDeclaration(clT,
                            clstarSPECIAL_CODE_SIZESstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarSPECIAL_CODE_SIZESstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarSPECIAL_CODE_SIZESstar, CONS_136);
  (void) clstarSPECIAL_CODE_SIZESstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarESTIMATE_CODE_SIZE_PUNTstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarESTIMATE_CODE_SIZE_PUNTstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarESTIMATE_CODE_SIZE_PUNTstar, CONS_217);
  (void) clstarESTIMATE_CODE_SIZE_PUNTstar;
  clSetSymbolFunctionValue(clDESTRUCTURING_SIZE,
                           clMakeClosure(0,
                                         clDestructuringSize,
                                         clNULL_HOOK));
  (void) clDESTRUCTURING_SIZE;
  clSetSymbolFunctionValue(clESTIMATE_CODE_SIZE,
                           clMakeClosure(0,
                                         clEstimateCodeSize,
                                         clNULL_HOOK));
  (void) clESTIMATE_CODE_SIZE;
  clSetSymbolFunctionValue(clESTIMATE_CODE_SIZE_1,
                           clMakeClosure(0,
                                         clEstimateCodeSize1,
                                         clNULL_HOOK));
  (void) clESTIMATE_CODE_SIZE_1;
  clSetSymbolFunctionValue(clLOOP_CONTEXT,
                           clMakeClosure(0,
                                         clLoopContext,
                                         clNULL_HOOK));
  (void) clLOOP_CONTEXT;
  clSetSymbolFunctionValue(clLOOP_ERROR,
                           clMakeClosure(0, clLoopError, clNULL_HOOK));
  (void) clLOOP_ERROR;
  clSetSymbolFunctionValue(clLOOP_WARN,
                           clMakeClosure(0, clLoopWarn, clNULL_HOOK));
  (void) clLOOP_WARN;
  clSetSymbolFunctionValue(clLOOP_CHECK_DATA_TYPE,
                           clMakeClosure(0,
                                         clLoopCheckDataType,
                                         clNULL_HOOK));
  (void) clLOOP_CHECK_DATA_TYPE;
  { clObject L_value398;
    clSetq(L_value398, clMakeClosure(0, clLoopFinish, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value398, clLOOP_FINISH, clEOA); }
  (void) clLOOP_FINISH;
  clSetSymbolFunctionValue(clLOOP_TRANSLATE,
                           clMakeClosure(0,
                                         clLoopTranslate,
                                         clNULL_HOOK));
  (void) clLOOP_TRANSLATE;
  clSetSymbolFunctionValue(clLOOP_ITERATION_DRIVER,
                           clMakeClosure(0,
                                         clLoopIterationDriver,
                                         clNULL_HOOK));
  (void) clLOOP_ITERATION_DRIVER;
  clSetSymbolFunctionValue(clLOOP_POP_SOURCE,
                           clMakeClosure(0,
                                         clLoopPopSource,
                                         clNULL_HOOK));
  (void) clLOOP_POP_SOURCE;
  clSetSymbolFunctionValue(clLOOP_GET_PROGN,
                           clMakeClosure(0,
                                         clLoopGetProgn,
                                         clNULL_HOOK));
  (void) clLOOP_GET_PROGN;
  clSetSymbolFunctionValue(clLOOP_GET_FORM,
                           clMakeClosure(0,
                                         clLoopGetForm,
                                         clNULL_HOOK));
  (void) clLOOP_GET_FORM;
  clSetSymbolFunctionValue(clLOOP_CONSTRUCT_RETURN,
                           clMakeClosure(0,
                                         clLoopConstructReturn,
                                         clNULL_HOOK));
  (void) clLOOP_CONSTRUCT_RETURN;
  clSetSymbolFunctionValue(clLOOP_PSEUDO_BODY,
                           clMakeClosure(0,
                                         clLoopPseudoBody,
                                         clNULL_HOOK));
  (void) clLOOP_PSEUDO_BODY;
  clSetSymbolFunctionValue(clLOOP_EMIT_BODY,
                           clMakeClosure(0,
                                         clLoopEmitBody,
                                         clNULL_HOOK));
  (void) clLOOP_EMIT_BODY;
  clSetSymbolFunctionValue(clLOOP_EMIT_FINAL_VALUE,
                           clMakeClosure(0,
                                         clLoopEmitFinalValue,
                                         clNULL_HOOK));
  (void) clLOOP_EMIT_FINAL_VALUE;
  clSetSymbolFunctionValue(clLOOP_DISALLOW_CONDITIONAL,
                           clMakeClosure(0,
                                         clLoopDisallowConditional,
                                         clNULL_HOOK));
  (void) clLOOP_DISALLOW_CONDITIONAL;
  clSetSymbolFunctionValue(clLOOP_TYPED_INIT,
                           clMakeClosure(0,
                                         clLoopTypedInit,
                                         clNULL_HOOK));
  (void) clLOOP_TYPED_INIT;
  clSetSymbolFunctionValue(clLOOP_OPTIONAL_TYPE,
                           clMakeClosure(0,
                                         clLoopOptionalType,
                                         clNULL_HOOK));
  (void) clLOOP_OPTIONAL_TYPE;
  clSetSymbolFunctionValue(clLOOP_BIND_BLOCK,
                           clMakeClosure(0,
                                         clLoopBindBlock,
                                         clNULL_HOOK));
  (void) clLOOP_BIND_BLOCK;
  clSetSymbolFunctionValue(clLOOP_MAKE_VARIABLE,
                           clMakeClosure(0,
                                         clLoopMakeVariable,
                                         clNULL_HOOK));
  (void) clLOOP_MAKE_VARIABLE;
  clSetSymbolFunctionValue(clLOOP_MAKE_ITERATION_VARIABLE,
                           clMakeClosure(0,
                                         clLoopMakeIterationVariable,
                                         clNULL_HOOK));
  (void) clLOOP_MAKE_ITERATION_VARIABLE;
  clSetSymbolFunctionValue(clLOOP_DECLARE_VARIABLE,
                           clMakeClosure(0,
                                         clLoopDeclareVariable,
                                         clNULL_HOOK));
  (void) clLOOP_DECLARE_VARIABLE;
  clSetSymbolFunctionValue(clLOOP_MAYBE_BIND_FORM,
                           clMakeClosure(0,
                                         clLoopMaybeBindForm,
                                         clNULL_HOOK));
  (void) clLOOP_MAYBE_BIND_FORM;
  clSetSymbolFunctionValue(clLOOP_DO_IF,
                           clMakeClosure(0, clLoopDoIf, clNULL_HOOK));
  (void) clLOOP_DO_IF;
  clSetSymbolFunctionValue(clLOOP_DO_INITIALLY,
                           clMakeClosure(0,
                                         clLoopDoInitially,
                                         clNULL_HOOK));
  (void) clLOOP_DO_INITIALLY;
  clSetSymbolFunctionValue(clLOOP_DO_FINALLY,
                           clMakeClosure(0,
                                         clLoopDoFinally,
                                         clNULL_HOOK));
  (void) clLOOP_DO_FINALLY;
  clSetSymbolFunctionValue(clLOOP_DO_DO,
                           clMakeClosure(0, clLoopDoDo, clNULL_HOOK));
  (void) clLOOP_DO_DO;
  clSetSymbolFunctionValue(clLOOP_DO_NAMED,
                           clMakeClosure(0,
                                         clLoopDoNamed,
                                         clNULL_HOOK));
  (void) clLOOP_DO_NAMED;
  clSetSymbolFunctionValue(clLOOP_DO_RETURN,
                           clMakeClosure(0,
                                         clLoopDoReturn,
                                         clNULL_HOOK));
  (void) clLOOP_DO_RETURN;
  { clObject L_g4;
    { clObject L_0;
      clSetq(L_0, clSymbolFunctionValue(clENSURE_STRUCTURE));
      clSetq(L_g4, clApply(L_0, clLOOP_COLLECTOR, CONS_243, clEOA)); }
    clSetSymbolFunctionValue(clMAKE_LOOP_COLLECTOR,
                             clMakeClosure(0,
                                           clMakeLoopCollector,
                                           clNULL_HOOK));
    (void) clMAKE_LOOP_COLLECTOR;
    clSetSymbolFunctionValue(clLOOP_COLLECTOR_NAME,
                             clMakeClosure(0,
                                           clLoopCollectorName,
                                           clNULL_HOOK));
    (void) clLOOP_COLLECTOR_NAME;
    clSetSymbolSetfFunctionValue(clLOOP_COLLECTOR_NAME,
                                 clMakeClosure(0,
                                               cl_SETF_LoopCollectorName,
                                               clNULL_HOOK));
    (void) CONS_282;
    clSetSymbolFunctionValue(clLOOP_COLLECTOR_CLASS,
                             clMakeClosure(0,
                                           clLoopCollectorClass,
                                           clNULL_HOOK));
    (void) clLOOP_COLLECTOR_CLASS;
    clSetSymbolSetfFunctionValue(clLOOP_COLLECTOR_CLASS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopCollectorClass,
                                               clNULL_HOOK));
    (void) CONS_284;
    clSetSymbolFunctionValue(clLOOP_COLLECTOR_HISTORY,
                             clMakeClosure(0,
                                           clLoopCollectorHistory,
                                           clNULL_HOOK));
    (void) clLOOP_COLLECTOR_HISTORY;
    clSetSymbolSetfFunctionValue(clLOOP_COLLECTOR_HISTORY,
                                 clMakeClosure(0,
                                               cl_SETF_LoopCollectorHistory,
                                               clNULL_HOOK));
    (void) CONS_286;
    clSetSymbolFunctionValue(clLOOP_COLLECTOR_TEMPVARS,
                             clMakeClosure(0,
                                           clLoopCollectorTempvars,
                                           clNULL_HOOK));
    (void) clLOOP_COLLECTOR_TEMPVARS;
    clSetSymbolSetfFunctionValue(clLOOP_COLLECTOR_TEMPVARS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopCollectorTempvars,
                                               clNULL_HOOK));
    (void) CONS_288;
    clSetSymbolFunctionValue(clLOOP_COLLECTOR_DTYPE,
                             clMakeClosure(0,
                                           clLoopCollectorDtype,
                                           clNULL_HOOK));
    (void) clLOOP_COLLECTOR_DTYPE;
    clSetSymbolSetfFunctionValue(clLOOP_COLLECTOR_DTYPE,
                                 clMakeClosure(0,
                                               cl_SETF_LoopCollectorDtype,
                                               clNULL_HOOK));
    (void) CONS_290;
    clSetSymbolFunctionValue(clLOOP_COLLECTOR_DATA,
                             clMakeClosure(0,
                                           clLoopCollectorData,
                                           clNULL_HOOK));
    (void) clLOOP_COLLECTOR_DATA;
    clSetSymbolSetfFunctionValue(clLOOP_COLLECTOR_DATA,
                                 clMakeClosure(0,
                                               cl_SETF_LoopCollectorData,
                                               clNULL_HOOK));
    (void) CONS_292;
    (void) clLOOP_COLLECTOR; }
  clSetSymbolFunctionValue(clLOOP_GET_COLLECTION_INFO,
                           clMakeClosure(0,
                                         clLoopGetCollectionInfo,
                                         clNULL_HOOK));
  (void) clLOOP_GET_COLLECTION_INFO;
  clSetSymbolFunctionValue(clLOOP_LIST_COLLECTION,
                           clMakeClosure(0,
                                         clLoopListCollection,
                                         clNULL_HOOK));
  (void) clLOOP_LIST_COLLECTION;
  clSetSymbolFunctionValue(clLOOP_SUM_COLLECTION,
                           clMakeClosure(0,
                                         clLoopSumCollection,
                                         clNULL_HOOK));
  (void) clLOOP_SUM_COLLECTION;
  clSetSymbolFunctionValue(clLOOP_MAXMIN_COLLECTION,
                           clMakeClosure(0,
                                         clLoopMaxminCollection,
                                         clNULL_HOOK));
  (void) clLOOP_MAXMIN_COLLECTION;
  clSetSymbolFunctionValue(clLOOP_DO_ALWAYS,
                           clMakeClosure(0,
                                         clLoopDoAlways,
                                         clNULL_HOOK));
  (void) clLOOP_DO_ALWAYS;
  clSetSymbolFunctionValue(clLOOP_DO_THEREIS,
                           clMakeClosure(0,
                                         clLoopDoThereis,
                                         clNULL_HOOK));
  (void) clLOOP_DO_THEREIS;
  clSetSymbolFunctionValue(clLOOP_DO_WHILE,
                           clMakeClosure(0,
                                         clLoopDoWhile,
                                         clNULL_HOOK));
  (void) clLOOP_DO_WHILE;
  clSetSymbolFunctionValue(clLOOP_DO_WITH,
                           clMakeClosure(0,
                                         clLoopDoWith,
                                         clNULL_HOOK));
  (void) clLOOP_DO_WITH;
  clSetSymbolFunctionValue(clLOOP_HACK_ITERATION,
                           clMakeClosure(0,
                                         clLoopHackIteration,
                                         clNULL_HOOK));
  (void) clLOOP_HACK_ITERATION;
  clSetSymbolFunctionValue(clLOOP_DO_FOR,
                           clMakeClosure(0, clLoopDoFor, clNULL_HOOK));
  (void) clLOOP_DO_FOR;
  clSetSymbolFunctionValue(clLOOP_DO_REPEAT,
                           clMakeClosure(0,
                                         clLoopDoRepeat,
                                         clNULL_HOOK));
  (void) clLOOP_DO_REPEAT;
  clSetSymbolFunctionValue(clLOOP_WHEN_IT_VARIABLE,
                           clMakeClosure(0,
                                         clLoopWhenItVariable,
                                         clNULL_HOOK));
  (void) clLOOP_WHEN_IT_VARIABLE;
  clSetSymbolFunctionValue(clLOOP_ANSI_FOR_EQUALS,
                           clMakeClosure(0,
                                         clLoopAnsiForEquals,
                                         clNULL_HOOK));
  (void) clLOOP_ANSI_FOR_EQUALS;
  clSetSymbolFunctionValue(clLOOP_FOR_ACROSS,
                           clMakeClosure(0,
                                         clLoopForAcross,
                                         clNULL_HOOK));
  (void) clLOOP_FOR_ACROSS;
  clSetSymbolFunctionValue(clLOOP_LIST_STEP,
                           clMakeClosure(0,
                                         clLoopListStep,
                                         clNULL_HOOK));
  (void) clLOOP_LIST_STEP;
  clSetSymbolFunctionValue(clLOOP_FOR_ON,
                           clMakeClosure(0, clLoopForOn, clNULL_HOOK));
  (void) clLOOP_FOR_ON;
  clSetSymbolFunctionValue(clLOOP_FOR_IN,
                           clMakeClosure(0, clLoopForIn, clNULL_HOOK));
  (void) clLOOP_FOR_IN;
  { clObject L_g5;
    { clObject L_0;
      clSetq(L_0, clSymbolFunctionValue(clENSURE_STRUCTURE));
      clSetq(L_g5, clApply(L_0, clLOOP_PATH, CONS_307, clEOA)); }
    clSetSymbolFunctionValue(clMAKE_LOOP_PATH,
                             clMakeClosure(0,
                                           clMakeLoopPath,
                                           clNULL_HOOK));
    (void) clMAKE_LOOP_PATH;
    clSetSymbolFunctionValue(clLOOP_PATH_NAMES,
                             clMakeClosure(0,
                                           clLoopPathNames,
                                           clNULL_HOOK));
    (void) clLOOP_PATH_NAMES;
    clSetSymbolSetfFunctionValue(clLOOP_PATH_NAMES,
                                 clMakeClosure(0,
                                               cl_SETF_LoopPathNames,
                                               clNULL_HOOK));
    (void) CONS_337;
    clSetSymbolFunctionValue(clLOOP_PATH_PREPOSITION_GROUPS,
                             clMakeClosure(0,
                                           clLoopPathPrepositionGroups,
                                           clNULL_HOOK));
    (void) clLOOP_PATH_PREPOSITION_GROUPS;
    clSetSymbolSetfFunctionValue(clLOOP_PATH_PREPOSITION_GROUPS,
                                 clMakeClosure(0,
                                               cl_SETF_LoopPathPrepositionGroups,
                                               clNULL_HOOK));
    (void) CONS_339;
    clSetSymbolFunctionValue(clLOOP_PATH_INCLUSIVE_PERMITTED,
                             clMakeClosure(0,
                                           clLoopPathInclusivePermitted,
                                           clNULL_HOOK));
    (void) clLOOP_PATH_INCLUSIVE_PERMITTED;
    clSetSymbolSetfFunctionValue(clLOOP_PATH_INCLUSIVE_PERMITTED,
                                 clMakeClosure(0,
                                               cl_SETF_LoopPathInclusivePermitted,
                                               clNULL_HOOK));
    (void) CONS_341;
    clSetSymbolFunctionValue(clLOOP_PATH_FUNCTION,
                             clMakeClosure(0,
                                           clLoopPathFunction,
                                           clNULL_HOOK));
    (void) clLOOP_PATH_FUNCTION;
    clSetSymbolSetfFunctionValue(clLOOP_PATH_FUNCTION,
                                 clMakeClosure(0,
                                               cl_SETF_LoopPathFunction,
                                               clNULL_HOOK));
    (void) CONS_343;
    clSetSymbolFunctionValue(clLOOP_PATH_USER_DATA,
                             clMakeClosure(0,
                                           clLoopPathUserData,
                                           clNULL_HOOK));
    (void) clLOOP_PATH_USER_DATA;
    clSetSymbolSetfFunctionValue(clLOOP_PATH_USER_DATA,
                                 clMakeClosure(0,
                                               cl_SETF_LoopPathUserData,
                                               clNULL_HOOK));
    (void) CONS_345;
    (void) clLOOP_PATH; }
  clSetSymbolFunctionValue(clADD_LOOP_PATH,
                           clMakeClosure(0,
                                         clAddLoopPath,
                                         clNULL_HOOK));
  (void) clADD_LOOP_PATH;
  clSetSymbolFunctionValue(clLOOP_FOR_BEING,
                           clMakeClosure(0,
                                         clLoopForBeing,
                                         clNULL_HOOK));
  (void) clLOOP_FOR_BEING;
  clSetSymbolFunctionValue(clNAMED_VARIABLE,
                           clMakeClosure(0,
                                         clNamedVariable,
                                         clNULL_HOOK));
  (void) clNAMED_VARIABLE;
  clSetSymbolFunctionValue(clLOOP_COLLECT_PREPOSITIONAL_PHRASES,
                           clMakeClosure(0,
                                         clLoopCollectPrepositionalPhrases,
                                         clNULL_HOOK));
  (void) clLOOP_COLLECT_PREPOSITIONAL_PHRASES;
  clSetSymbolFunctionValue(clLOOP_SEQUENCER,
                           clMakeClosure(0,
                                         clLoopSequencer,
                                         clNULL_HOOK));
  (void) clLOOP_SEQUENCER;
  clSetSymbolFunctionValue(clLOOP_FOR_ARITHMETIC,
                           clMakeClosure(0,
                                         clLoopForArithmetic,
                                         clNULL_HOOK));
  (void) clLOOP_FOR_ARITHMETIC;
  clSetSymbolFunctionValue(clLOOP_SEQUENCE_ELEMENTS_PATH,
                           clMakeClosure(0,
                                         clLoopSequenceElementsPath,
                                         clNULL_HOOK));
  (void) clLOOP_SEQUENCE_ELEMENTS_PATH;
  clSetSymbolFunctionValue(clLOOP_HASH_TABLE_ITERATION_PATH,
                           clMakeClosure(0,
                                         clLoopHashTableIterationPath,
                                         clNULL_HOOK));
  (void) clLOOP_HASH_TABLE_ITERATION_PATH;
  clSetSymbolFunctionValue(clLOOP_PACKAGE_SYMBOLS_ITERATION_PATH,
                           clMakeClosure(0,
                                         clLoopPackageSymbolsIterationPath,
                                         clNULL_HOOK));
  (void) clLOOP_PACKAGE_SYMBOLS_ITERATION_PATH;
  clSetSymbolFunctionValue(clMAKE_ANSI_LOOP_UNIVERSE,
                           clMakeClosure(0,
                                         clMakeAnsiLoopUniverse,
                                         clNULL_HOOK));
  (void) clMAKE_ANSI_LOOP_UNIVERSE;
  clSetSymbolFunctionValue(clLOOP_STANDARD_EXPANSION,
                           clMakeClosure(0,
                                         clLoopStandardExpansion,
                                         clNULL_HOOK));
  (void) clLOOP_STANDARD_EXPANSION;
  cl_SETF_GlobalDeclaration(clT,
                            clstarLOOP_ANSI_UNIVERSEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clNot(clBoundp(clstarLOOP_ANSI_UNIVERSEstar, clEOA),
                   clEOA)))
    clSetSymbolValueValue(clstarLOOP_ANSI_UNIVERSEstar,
                          clMakeAnsiLoopUniverse(clNIL, clEOA));
  (void) clstarLOOP_ANSI_UNIVERSEstar;
  { clObject L_value569;
    clSetq(L_value569, clMakeClosure(0, clLoop, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value569, clLOOP, clEOA); }
  (void) clLOOP;
  clUnwind(4); }
