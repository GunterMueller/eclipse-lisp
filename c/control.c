/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Tuesday the seventh of April, 1998, 5:27:24 pm CDT. */
#include <eclipse.h>

clObject clApply(clProto), clAtom(clProto), clBoundp(clProto),
  clCanonicalizeDeclarations(clProto), clCar(clProto), clCddr(clProto),
  clCdr(clProto), clCharpSimpleBaseString __P((clCharp)),
  clCons(clProto), clConstantp(clProto), clEq(clProto),
  clError(clProto), clExtraArgs(clProto), clFunctionNameKey(clProto),
  cl_SETF_Get(clProto), clGlobalDeclaration(clProto),
  cl_SETF_GlobalDeclaration(clProto), clIntern(clProto),
  clKeywordp(clProto), clList(clProto), clListSTAR(clProto),
  cl_SETF_MacroFunction(clProto), clMakeKeyword(clProto),
  clMap1(clProto), clMissingArgs(clProto), clPkg(clProto),
  clRedefineConstant(clProto), clSetfFunctionNameP(clProto);

extern clObject clBLOCK, clCATCH, clCOMPILATION_SPEED, clCONS,
  clEVAL_WHEN, clGO, clIF, clLABELS, clLAMBDA, clLET, clLETstar,
  clLOAD_TIME_VALUE, clLOCALLY, clMACROLET, clMULTIPLE_VALUE_CALL,
  clMULTIPLE_VALUE_PROG1, clOPTIMIZE, clPROGN, clPROGV, clQUOTE,
  clRETURN_FROM, clSAFETY, clSETQ, clSPACE, clSPECIAL, clSPEED,
  clSYMBOL, clSYMBOL_MACROLET, clTAGBODY, clTHROW, clUNWIND_PROTECT,
  clstarCONSTANT_CHECK_HOOKstar, clCALL_ARGUMENTS_LIMIT, clCONSTANT,
  clCONSTANTP, clDECLAIM, clFLET, clFUNCTION, clGLOBAL_DECLARATION,
  clGLOBAL_FUNCTION, clGLOBAL_SETF_FUNCTION, clGLOBAL_VARIABLE,
  clGLOBALLY_SPECIAL_P, clLAMBDA_PARAMETERS_LIMIT, clLIST,
  clMAKUNBOUND, clMAPC, clMAPCON, clMAPL, clMAPLIST,
  clMULTIPLE_VALUES_LIMIT, clNAMED_FUNCTION, clNULL, clOR, clPROCLAIM,
  clSET, clSETF, clSPECIAL_OPERATOR_P, clSYMBOL_FUNCTION,
  clSYMBOL_VALUE, clTHE, clTYPE_ERROR, clUNBOUND_FLAG, clDEBUG,
  clUNBOUND_VARIABLE, clUNDEFINED_FUNCTION, clVALUES, clVALUES_LIST;

static clObject CONS_0, CONS_1, CONS_10, CONS_11, CONS_12, CONS_13,
  CONS_14, CONS_15, CONS_16, CONS_17, CONS_18, CONS_19, CONS_2,
  CONS_20, CONS_21, CONS_22, CONS_23, CONS_24, CONS_25, CONS_26,
  CONS_27, CONS_28, CONS_29, CONS_3, CONS_30, CONS_31, CONS_32,
  CONS_33, CONS_34, CONS_35, CONS_36, CONS_37, CONS_38, CONS_39,
  CONS_4, CONS_40, CONS_41, CONS_42, CONS_43, CONS_44, CONS_45,
  CONS_46, CONS_47, CONS_5, CONS_6, CONS_7, CONS_8, CONS_9, 
  I_1, I_2, I_20, I_50, keyCOMPILE_TOPLEVEL, keyDATUM, keyEXECUTE,
  keyEXPECTED_TYPE, keyLIST, keyLOAD_TOPLEVEL, keyNAME, keyNCONC,
  STR_COMPILE_TOPLEVEL__8, STR_DATUM__1, 
  STR_EXECUTE__10, STR_EXPECTED_TYPE__2, 
  STR_LIST__4, STR_LOAD_TOPLEVEL__9, STR_NAME__0, STR_NCONC__5, STRn_3;

clObject clSymbolValue clVdecl(_ap)
{ clObject symbol;
  { clBeginParse(_ap);
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(clBoundp(symbol, clEOA)))
    return(clValues1(clSymbolValueValue(symbol)));
  else return(clError(clUNBOUND_VARIABLE, keyNAME, symbol, clEOA)); }

clObject clSymbolFunction clVdecl(_ap)
{ clObject symbol;
  { clBeginParse(_ap);
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g460;
    { clObject L_class_name463;
      clSetq(L_class_name463, clInstanceTag(symbol));
      clSetq(L_g460,
             (clTrue((_clEq(L_class_name463, clSYMBOL) ?
                      CONS_0 :
                      (_clEq(L_class_name463, clNULL) ?
                       CONS_1 :
                       clNIL))) ?
              clSymbolFunctionValue(symbol) :
              clError(clTYPE_ERROR,
                      keyDATUM,
                      symbol,
                      keyEXPECTED_TYPE,
                      CONS_2,
                      clEOA))); }
    if (clTrue(L_g460))
      return(clValues1(L_g460));
    else
      return(clError(clUNDEFINED_FUNCTION, keyNAME, symbol, clEOA)); } }

clObject cl_SETF_SymbolFunction clVdecl(_ap)
{ clObject value, symbol;
  { clBeginParse(_ap);
    clSetq(value,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_class_name469;
    clSetq(L_class_name469, clInstanceTag(symbol));
    if (clTrue((_clEq(L_class_name469, clSYMBOL) ? CONS_0 :
                (_clEq(L_class_name469, clNULL) ? CONS_1 : clNIL))))
      return(clValues1(clSetSymbolFunctionValue(symbol, value)));
    else
      return(clError(clTYPE_ERROR, keyDATUM, symbol, keyEXPECTED_TYPE,
                     CONS_2, clEOA)); } }

clObject clSet clVdecl(_ap)
{ clObject symbol, value;
  { clBeginParse(_ap);
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(value,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_class_name475;
    clSetq(L_class_name475, clInstanceTag(symbol));
    if (clTrue((_clEq(L_class_name475, clSYMBOL) ? CONS_0 :
                (_clEq(L_class_name475, clNULL) ? CONS_1 : clNIL))))
      if (clTrue(clConstantp(symbol, clEOA)))
        return(clError(STRn_3, symbol, clEOA));
      else return(clValues1(clSetSymbolValueValue(symbol, value)));
    else
      return(clError(clTYPE_ERROR, keyDATUM, symbol, keyEXPECTED_TYPE,
                     CONS_2, clEOA)); } }

clObject clMakunbound clVdecl(_ap)
{ clObject symbol;
  { clBeginParse(_ap);
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_class_name481;
    clSetq(L_class_name481, clInstanceTag(symbol));
    if (clTrue((_clEq(L_class_name481, clSYMBOL) ? CONS_0 :
                (_clEq(L_class_name481, clNULL) ? CONS_1 : clNIL))))
      clSetSymbolValueValue(symbol,
                            clSymbolValueValue(clUNBOUND_FLAG));
    else
      clError(clTYPE_ERROR, keyDATUM, symbol, keyEXPECTED_TYPE, CONS_2,
              clEOA); }
  return(clValues1(symbol)); }

clObject clSpecialOperatorP clVdecl(_ap)
{ clObject name;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (_clEq(name, clBLOCK))
    return(clValues1(CONS_6));
  else if (_clEq(name, clLETstar))
    return(clValues1(CONS_7));
  else if (_clEq(name, clRETURN_FROM))
    return(clValues1(CONS_8));
  else if (_clEq(name, clCATCH))
    return(clValues1(CONS_9));
  else if (_clEq(name, clLOAD_TIME_VALUE))
    return(clValues1(CONS_10));
  else if (_clEq(name, clSETQ))
    return(clValues1(CONS_11));
  else if (_clEq(name, clEVAL_WHEN))
    return(clValues1(CONS_12));
  else if (_clEq(name, clLOCALLY))
    return(clValues1(CONS_13));
  else if (_clEq(name, clSYMBOL_MACROLET))
    return(clValues1(CONS_14));
  else if (_clEq(name, clFLET))
    return(clValues1(CONS_15));
  else if (_clEq(name, clMACROLET))
    return(clValues1(CONS_16));
  else if (_clEq(name, clFUNCTION))
    return(clValues1(CONS_17));
  else if (_clEq(name, clMULTIPLE_VALUE_CALL))
    return(clValues1(CONS_18));
  else if (_clEq(name, clTHE))
    return(clValues1(CONS_19));
  else if (_clEq(name, clTAGBODY))
    return(clValues1(CONS_20));
  else if (_clEq(name, clGO))
    return(clValues1(CONS_21));
  else if (_clEq(name, clMULTIPLE_VALUE_PROG1))
    return(clValues1(CONS_22));
  else if (_clEq(name, clTHROW))
    return(clValues1(CONS_23));
  else if (_clEq(name, clIF))
    return(clValues1(CONS_24));
  else if (_clEq(name, clPROGN))
    return(clValues1(CONS_25));
  else if (_clEq(name, clUNWIND_PROTECT))
    return(clValues1(CONS_26));
  else if (_clEq(name, clLABELS))
    return(clValues1(CONS_27));
  else if (_clEq(name, clPROGV))
    return(clValues1(CONS_28));
  else if (_clEq(name, clLET))
    return(clValues1(CONS_29));
  else if (_clEq(name, clQUOTE))
    return(clValues1(CONS_30));
  else return(clValues1(clNIL)); }

clObject clNamedFunction clVdecl(_ap)
{ clObject L_form, L_ignored, name, lambda_list, body;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top488;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top488, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(name, L_top488); }
    else clSetq(name, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form))
      { clObject L_top489;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top489, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(lambda_list, L_top489); }
    else clSetq(lambda_list, clMissingArgs(I_2, clEOA));
    clSetq(body, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clListSTAR(clLAMBDA, lambda_list, body, clEOA)); }

clObject clMapl clVdecl(_ap)
{ clObject function, lists;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lists, clVargs(_ap));
    clEndParse(_ap); }
  return(clMap1(function, lists, clNIL, clNIL, clEOA)); }

clObject clMaplist clVdecl(_ap)
{ clObject function, lists;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lists, clVargs(_ap));
    clEndParse(_ap); }
  return(clMap1(function, lists, keyLIST, clNIL, clEOA)); }

clObject clMapcon clVdecl(_ap)
{ clObject function, lists;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lists, clVargs(_ap));
    clEndParse(_ap); }
  return(clMap1(function, lists, keyNCONC, clNIL, clEOA)); }

clObject clValuesList clVdecl(_ap)
{ clObject list;
  { clBeginParse(_ap);
    clSetq(list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, clSymbolFunctionValue(clVALUES));
    return(clApply(L_0, list, clEOA)); } }

static clObject clProclaim_DefDecs clVdecl(_ap)
{ clObject decs, category, adjustp;
  { clBeginParse(_ap);
    clSetq(decs,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(category,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(adjustp, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g2, symbol, plist;
    clSetq(L_g2, decs);
    clSetq(symbol, clNIL);
    clSetq(plist, clNIL);
    { clObject setfp;
      clSetq(setfp, clNIL);
      { clObject name;
        clSetq(name, clNIL);
        { clObject cat;
          clSetq(cat, clNIL);
          clLabel(NEXT_LOOP);
          if (clTrue(clAtom(L_g2, clEOA))) goto END_LOOP;
          { clObject L_loop_desetq_temp;
            clSetq(L_loop_desetq_temp, L_g2);
            clSetq(symbol, clCar(L_loop_desetq_temp, clEOA));
            { clObject L_0;
              clSetq(L_0, L_loop_desetq_temp);
              clSetq(L_loop_desetq_temp, clCdr(L_0, clEOA)); }
            { clObject L_0;
              clSetq(L_0, L_loop_desetq_temp);
              clSetq(plist, clCar(L_0, clEOA)); } }
          { clObject L_0;
            clSetq(L_0, L_g2);
            clSetq(L_g2, clCddr(L_0, clEOA)); }
          if (clTrue(adjustp))
            { clObject L_0;
              clSetq(L_0, symbol);
              clSetq(setfp, clSetfFunctionNameP(L_0, clEOA)); }
          else clSetq(setfp, clNIL);
          { clObject L_1, L_0;
            clSetq(L_0, symbol);
            clSetq(L_1, setfp);
            clSetq(name, clFunctionNameKey(L_0, L_1, clEOA)); }
          clSetq(cat,
                 (clTrue(setfp) ? clGLOBAL_SETF_FUNCTION : category));
          { clObject L_g3, prop, val;
            clSetq(L_g3, plist);
            clSetq(prop, clNIL);
            clSetq(val, clNIL);
            clLabel(NEXT_LOOP__r1);
            if (clTrue(clAtom(L_g3, clEOA))) goto END_LOOP__r1;
            { clObject L_loop_desetq_temp;
              clSetq(L_loop_desetq_temp, L_g3);
              clSetq(prop, clCar(L_loop_desetq_temp, clEOA));
              { clObject L_0;
                clSetq(L_0, L_loop_desetq_temp);
                clSetq(L_loop_desetq_temp, clCdr(L_0, clEOA)); }
              { clObject L_0;
                clSetq(L_0, L_loop_desetq_temp);
                clSetq(val, clCar(L_0, clEOA)); } }
            { clObject L_0;
              clSetq(L_0, L_g3);
              clSetq(L_g3, clCddr(L_0, clEOA)); }
            { clObject L_arg503, L_arg504, L_arg505, L_value502;
              clSetq(L_arg503, name);
              clSetq(L_arg504, cat);
              clSetq(L_arg505, prop);
              clSetq(L_value502, val);
              cl_SETF_GlobalDeclaration(L_value502,
                                        L_arg503,
                                        L_arg504,
                                        L_arg505,
                                        clEOA); }
            goto NEXT_LOOP__r1;
            clLabel(END_LOOP__r1); }
          goto NEXT_LOOP;
          clLabel(END_LOOP);
          return(clValues1(clNIL)); } } } } }

clObject clProclaim clVdecl(_ap)
{ clObject decl_spec;
  { clBeginParse(_ap);
    clSetq(decl_spec,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values501, vars, funcs, decs;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      { clObject L_0;
        clSetq(L_0, clList(decl_spec, clEOA));
        clCanonicalizeDeclarations(L_0, clNIL, clEOA); }
      clAccumulateValues(MVC);
      clSetq(L_values501, clMultipleValueFuncall(MVC)); }
    clSetq(vars, clCar(L_values501, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values501);
        clSetq(L_0, clSetq(L_values501, clCdr(L_0__R1, clEOA))); }
      clSetq(funcs, clCar(L_0, clEOA)); }
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values501);
        clSetq(L_0, clSetq(L_values501, clCdr(L_0__R1, clEOA))); }
      clSetq(decs, clCar(L_0, clEOA)); }
    { clObject _DefDecs_;
      clSetq(_DefDecs_,
             clMakeClosure(0, clProclaim_DefDecs, clNULL_HOOK));
      clFuncallFunction(_DefDecs_, vars, clGLOBAL_VARIABLE, clEOA);
      clFuncallFunction(_DefDecs_,
                        funcs,
                        clGLOBAL_FUNCTION,
                        clT,
                        clEOA);
      clFuncallFunction(_DefDecs_, decs, clGLOBAL_DECLARATION, clEOA);
      return(clValues1(clNIL)); } } }

clObject clDeclaim clVdecl(_ap)
{ clObject L_form, L_ignored, decl_specs;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    clSetq(decl_specs, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2;
    clSetq(L_2,
           clList(clMAPC, CONS_45, clList(clQUOTE, decl_specs, clEOA),
                  clEOA));
    return(clListSTAR(clEVAL_WHEN, CONS_42, L_2, CONS_47, clEOA)); } }

clObject clGloballySpecialP clVdecl(_ap)
{ clObject variable;
  { clBeginParse(_ap);
    clSetq(variable,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clGlobalDeclaration(variable,
                             clGLOBAL_VARIABLE,
                             clSPECIAL,
                             clEOA)); }

clObject clConstantp clVdecl(_ap)
{ clObject form, env;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(env, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_class_name509;
    clSetq(L_class_name509, clInstanceTag(form));
    if (clTrue((_clEq(L_class_name509, clSYMBOL) ? CONS_0 :
                (_clEq(L_class_name509, clNULL) ? CONS_1 : clNIL))))
      { clObject L_g513;
        clSetq(L_g513,
               clGlobalDeclaration(form,
                                   clGLOBAL_VARIABLE,
                                   clCONSTANT,
                                   clEOA));
        if (clTrue(L_g513))
          return(clValues1(L_g513));
        else return(clKeywordp(form, clEOA)); }
    else if (_clEq(L_class_name509, clCONS))
      { clObject L_0;
        clSetq(L_0, clCar(form, clEOA));
        return(clEq(L_0, clQUOTE, clEOA)); }
    else return(clValues1(clT)); } }

void clInitControl __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_50, clIntFixnum(50));
  clSetq(I_1, clIntFixnum(1));
  clSetq(STR_NAME__0,
         clCharpSimpleBaseString("NAME"));
  clSetq(keyNAME, clMakeKeyword(STR_NAME__0, clEOA));
  clSetq(CONS_1, clCons(clNULL, clNIL, clEOA));
  clSetq(CONS_0, clCons(clSYMBOL, CONS_1, clEOA));
  clSetq(STR_DATUM__1,
         clCharpSimpleBaseString("DATUM"));
  clSetq(keyDATUM, clMakeKeyword(STR_DATUM__1, clEOA));
  clSetq(STR_EXPECTED_TYPE__2,
         clCharpSimpleBaseString("EXPECTED-TYPE"));
  clSetq(keyEXPECTED_TYPE, clMakeKeyword(STR_EXPECTED_TYPE__2, clEOA));
  clSetq(CONS_3, clCons(clSYMBOL, clNIL, clEOA));
  clSetq(CONS_2, clCons(clOR, CONS_3, clEOA));
  clSetq(I_2, clIntFixnum(2));
  clSetq(CONS_5, clCons(clSYMBOL_FUNCTION, clNIL, clEOA));
  clSetq(CONS_4, clCons(clSETF, CONS_5, clEOA));
  clSetq(STRn_3,
         clCharpSimpleBaseString("Attempt to assign value to constant ~s."));
  clSetq(CONS_30, clCons(clQUOTE, clNIL, clEOA));
  clSetq(CONS_29, clCons(clLET, CONS_30, clEOA));
  clSetq(CONS_28, clCons(clPROGV, CONS_29, clEOA));
  clSetq(CONS_27, clCons(clLABELS, CONS_28, clEOA));
  clSetq(CONS_26, clCons(clUNWIND_PROTECT, CONS_27, clEOA));
  clSetq(CONS_25, clCons(clPROGN, CONS_26, clEOA));
  clSetq(CONS_24, clCons(clIF, CONS_25, clEOA));
  clSetq(CONS_23, clCons(clTHROW, CONS_24, clEOA));
  clSetq(CONS_22, clCons(clMULTIPLE_VALUE_PROG1, CONS_23, clEOA));
  clSetq(CONS_21, clCons(clGO, CONS_22, clEOA));
  clSetq(CONS_20, clCons(clTAGBODY, CONS_21, clEOA));
  clSetq(CONS_19, clCons(clTHE, CONS_20, clEOA));
  clSetq(CONS_18, clCons(clMULTIPLE_VALUE_CALL, CONS_19, clEOA));
  clSetq(CONS_17, clCons(clFUNCTION, CONS_18, clEOA));
  clSetq(CONS_16, clCons(clMACROLET, CONS_17, clEOA));
  clSetq(CONS_15, clCons(clFLET, CONS_16, clEOA));
  clSetq(CONS_14, clCons(clSYMBOL_MACROLET, CONS_15, clEOA));
  clSetq(CONS_13, clCons(clLOCALLY, CONS_14, clEOA));
  clSetq(CONS_12, clCons(clEVAL_WHEN, CONS_13, clEOA));
  clSetq(CONS_11, clCons(clSETQ, CONS_12, clEOA));
  clSetq(CONS_10, clCons(clLOAD_TIME_VALUE, CONS_11, clEOA));
  clSetq(CONS_9, clCons(clCATCH, CONS_10, clEOA));
  clSetq(CONS_8, clCons(clRETURN_FROM, CONS_9, clEOA));
  clSetq(CONS_7, clCons(clLETstar, CONS_8, clEOA));
  clSetq(CONS_6, clCons(clBLOCK, CONS_7, clEOA));
  clSetq(STR_LIST__4,
         clCharpSimpleBaseString("LIST"));
  clSetq(keyLIST, clMakeKeyword(STR_LIST__4, clEOA));
  clSetq(STR_NCONC__5,
         clCharpSimpleBaseString("NCONC"));
  clSetq(keyNCONC, clMakeKeyword(STR_NCONC__5, clEOA));
  clSetq(CONS_33, clCons(I_1, clNIL, clEOA));
  clSetq(CONS_32, clCons(clSPEED, CONS_33, clEOA));
  clSetq(CONS_35, clCons(clSAFETY, CONS_33, clEOA));
  clSetq(CONS_37, clCons(clSPACE, CONS_33, clEOA));
  clSetq(CONS_39, clCons(clDEBUG, CONS_33, clEOA));
  clSetq(CONS_41, clCons(clCOMPILATION_SPEED, CONS_33, clEOA));
  clSetq(CONS_40, clCons(CONS_41, clNIL, clEOA));
  clSetq(CONS_38, clCons(CONS_39, CONS_40, clEOA));
  clSetq(CONS_36, clCons(CONS_37, CONS_38, clEOA));
  clSetq(CONS_34, clCons(CONS_35, CONS_36, clEOA));
  clSetq(CONS_31, clCons(CONS_32, CONS_34, clEOA));
  clSetq(STR_COMPILE_TOPLEVEL__8,
         clCharpSimpleBaseString("COMPILE-TOPLEVEL"));
  clSetq(keyCOMPILE_TOPLEVEL,
         clMakeKeyword(STR_COMPILE_TOPLEVEL__8, clEOA));
  clSetq(STR_LOAD_TOPLEVEL__9,
         clCharpSimpleBaseString("LOAD-TOPLEVEL"));
  clSetq(keyLOAD_TOPLEVEL, clMakeKeyword(STR_LOAD_TOPLEVEL__9, clEOA));
  clSetq(STR_EXECUTE__10,
         clCharpSimpleBaseString("EXECUTE"));
  clSetq(keyEXECUTE, clMakeKeyword(STR_EXECUTE__10, clEOA));
  clSetq(CONS_44, clCons(keyEXECUTE, clNIL, clEOA));
  clSetq(CONS_43, clCons(keyLOAD_TOPLEVEL, CONS_44, clEOA));
  clSetq(CONS_42, clCons(keyCOMPILE_TOPLEVEL, CONS_43, clEOA));
  clSetq(CONS_46, clCons(clPROCLAIM, clNIL, clEOA));
  clSetq(CONS_45, clCons(clFUNCTION, CONS_46, clEOA));
  clSetq(CONS_47, clCons(clNIL, clNIL, clEOA));
  clSetq(I_20, clIntFixnum(20));

  cl_SETF_GlobalDeclaration(clT,
                            clLAMBDA_PARAMETERS_LIMIT,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clBoundp(clLAMBDA_PARAMETERS_LIMIT, clEOA)))
    { if (clTrue(clSymbolValue(clstarCONSTANT_CHECK_HOOKstar, clEOA)))
        clRedefineConstant(clLAMBDA_PARAMETERS_LIMIT, I_50, clEOA); }
  else clSetSymbolValueValue(clLAMBDA_PARAMETERS_LIMIT, I_50);
  cl_SETF_GlobalDeclaration(clT,
                            clLAMBDA_PARAMETERS_LIMIT,
                            clGLOBAL_VARIABLE,
                            clCONSTANT,
                            clEOA);
  (void) clLAMBDA_PARAMETERS_LIMIT;
  clSetSymbolFunctionValue(clSYMBOL_VALUE,
                           clMakeClosure(0,
                                         clSymbolValue,
                                         clNULL_HOOK));
  (void) clSYMBOL_VALUE;
  clSetSymbolFunctionValue(clSYMBOL_FUNCTION,
                           clMakeClosure(0,
                                         clSymbolFunction,
                                         clNULL_HOOK));
  (void) clSYMBOL_FUNCTION;
  clSetSymbolSetfFunctionValue(clSYMBOL_FUNCTION,
                               clMakeClosure(0,
                                             cl_SETF_SymbolFunction,
                                             clNULL_HOOK));
  (void) CONS_4;
  clSetSymbolFunctionValue(clSET,
                           clMakeClosure(0, clSet, clNULL_HOOK));
  (void) clSET;
  clSetSymbolFunctionValue(clMAKUNBOUND,
                           clMakeClosure(0,
                                         clMakunbound,
                                         clNULL_HOOK));
  (void) clMAKUNBOUND;
  clSetSymbolFunctionValue(clSPECIAL_OPERATOR_P,
                           clMakeClosure(0,
                                         clSpecialOperatorP,
                                         clNULL_HOOK));
  (void) clSPECIAL_OPERATOR_P;
  { clObject L_value486;
    clSetq(L_value486, clMakeClosure(0, clNamedFunction, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value486, clNAMED_FUNCTION, clEOA); }
  (void) clNAMED_FUNCTION;
  cl_SETF_GlobalDeclaration(clT,
                            clCALL_ARGUMENTS_LIMIT,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clBoundp(clCALL_ARGUMENTS_LIMIT, clEOA)))
    { if (clTrue(clSymbolValue(clstarCONSTANT_CHECK_HOOKstar, clEOA)))
        clRedefineConstant(clCALL_ARGUMENTS_LIMIT, I_50, clEOA); }
  else clSetSymbolValueValue(clCALL_ARGUMENTS_LIMIT, I_50);
  cl_SETF_GlobalDeclaration(clT,
                            clCALL_ARGUMENTS_LIMIT,
                            clGLOBAL_VARIABLE,
                            clCONSTANT,
                            clEOA);
  (void) clCALL_ARGUMENTS_LIMIT;
  clSetSymbolFunctionValue(clMAPL,
                           clMakeClosure(0, clMapl, clNULL_HOOK));
  (void) clMAPL;
  clSetSymbolFunctionValue(clMAPLIST,
                           clMakeClosure(0, clMaplist, clNULL_HOOK));
  (void) clMAPLIST;
  clSetSymbolFunctionValue(clMAPCON,
                           clMakeClosure(0, clMapcon, clNULL_HOOK));
  (void) clMAPCON;
  clSetSymbolFunctionValue(clVALUES_LIST,
                           clMakeClosure(0,
                                         clValuesList,
                                         clNULL_HOOK));
  (void) clVALUES_LIST;
  cl_SETF_Get(CONS_31, clOPTIMIZE, clGLOBAL_DECLARATION, clEOA);
  clSetSymbolFunctionValue(clPROCLAIM,
                           clMakeClosure(0, clProclaim, clNULL_HOOK));
  (void) clPROCLAIM;
  { clObject L_value506;
    clSetq(L_value506, clMakeClosure(0, clDeclaim, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value506, clDECLAIM, clEOA); }
  (void) clDECLAIM;
  clSetSymbolFunctionValue(clGLOBALLY_SPECIAL_P,
                           clMakeClosure(0,
                                         clGloballySpecialP,
                                         clNULL_HOOK));
  (void) clGLOBALLY_SPECIAL_P;
  clSetSymbolFunctionValue(clCONSTANTP,
                           clMakeClosure(0, clConstantp, clNULL_HOOK));
  (void) clCONSTANTP;
  cl_SETF_GlobalDeclaration(clT,
                            clMULTIPLE_VALUES_LIMIT,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  if (clTrue(clBoundp(clMULTIPLE_VALUES_LIMIT, clEOA)))
    { if (clTrue(clSymbolValue(clstarCONSTANT_CHECK_HOOKstar, clEOA)))
        clRedefineConstant(clMULTIPLE_VALUES_LIMIT, I_20, clEOA); }
  else clSetSymbolValueValue(clMULTIPLE_VALUES_LIMIT, I_20);
  cl_SETF_GlobalDeclaration(clT,
                            clMULTIPLE_VALUES_LIMIT,
                            clGLOBAL_VARIABLE,
                            clCONSTANT,
                            clEOA);
  (void) clMULTIPLE_VALUES_LIMIT;
  clUnwind(4); }
